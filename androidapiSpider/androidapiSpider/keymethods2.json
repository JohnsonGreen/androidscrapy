[{"returns": [{"scri": "true if the sensor's gesture detection is available. false if it is not currently detecting gestures (for example, if it is enrolling a finger).", "type": "boolean"}], "class": "android.accounts.AccountManagerCallback\n", "type": "boolean", "name": "isGestureDetectionAvailable", "throws": null, "funcname": "boolean isGestureDetectionAvailable ()", "descri": "  Gets if the fingerprint sensor's gesture detection is available. ", "parameters": null}, {"returns": null, "class": "android.accounts.AccountManagerCallback\n", "type": "void", "name": "registerFingerprintGestureCallback", "throws": null, "funcname": "void registerFingerprintGestureCallback (FingerprintGestureController.FingerprintGestureCallback callback,                 Handler handler)", "descri": "  Register a callback to be informed of fingerprint sensor gesture events. ", "parameters": [{"scri": "FingerprintGestureController.FingerprintGestureCallback: The listener to be added.This value must never be null.", "name": "callback"}, {"scri": "Handler: The handler to use for the callback. If null, callbacks will happen on the service's main thread.", "name": "handler"}]}, {"returns": null, "class": "android.accounts.AccountManagerCallback\n", "type": "void", "name": "unregisterFingerprintGestureCallback", "throws": null, "funcname": "void unregisterFingerprintGestureCallback (FingerprintGestureController.FingerprintGestureCallback callback)", "descri": "  Unregister a listener added with registerFingerprintGestureCallback(FingerprintGestureController.FingerprintGestureCallback, Handler). ", "parameters": [{"scri": "FingerprintGestureController.FingerprintGestureCallback: The callback to remove. Removing a callback that was never added has no effect.", "name": "callback"}]}, {"returns": null, "class": "android.animation.TimeAnimator\n", "type": "void", "name": "setAnimator", "throws": null, "funcname": "void setAnimator (int transitionType,                 Animator animator)", "descri": "  Sets the animation used during one of the transition types that may run. Any Animator object can be used, but to be most useful in the context of layout transitions, the animation should either be a ObjectAnimator or a AnimatorSet of animations including PropertyAnimators. Also, these ObjectAnimator objects should be able to get and set values on their target objects automatically. For example, a ObjectAnimator that animates the property \"left\" is able to set and get the left property from the View objects being animated by the layout transition. The transition works by setting target objects and properties dynamically, according to the pre- and post-layoout values of those objects, so having animations that can handle those properties appropriately will work best for custom animation. The dynamic setting of values is only the case for the CHANGE animations; the APPEARING and DISAPPEARING animations are simply run with the values they have. It is also worth noting that any and all animations (and their underlying PropertyValuesHolder objects) will have their start and end values set according to the pre- and post-layout values. So, for example, a custom animation on \"alpha\" as the CHANGE_APPEARING animation will inherit the real value of alpha on the target object (presumably 1) as its starting and ending value when the animation begins. Animations which need to use values at the beginning and end that may not match the values queried when the transition begins may need to use a different mechanism than a standard ObjectAnimator object. ", "parameters": [{"scri": "int: One of CHANGE_APPEARING, CHANGE_DISAPPEARING, CHANGING, APPEARING, or DISAPPEARING, which determines the animation whose animator is being set.", "name": "transitionType"}, {"scri": "Animator: The animation being assigned. A value of null means that no animation will be run for the specified transitionType.", "name": "animator"}]}, {"returns": [{"scri": "true if the application successfully requested that the application's     data be erased; false otherwise.", "type": "boolean"}], "class": "android.app.ActivityManager.ProcessErrorStateInfo\n", "type": "boolean", "name": "clearApplicationUserData", "throws": null, "funcname": "boolean clearApplicationUserData ()", "descri": "  Permits an application to erase its own data from disk.  This is equivalent to the user choosing to clear the app's data from within the device settings UI.  It erases all dynamic data associated with the app -- its private data and data in its private area on external storage -- but does not remove the installed application itself, nor any OBB files. It also revokes all runtime permissions that the app has acquired, clears all notifications and removes all Uri grants related to this application. ", "parameters": null}, {"returns": [{"scri": "Value is TAG_ADB_SHELL_INTERACTIVE, TAG_ADB_SHELL_CMD, TAG_SYNC_RECV_FILE, TAG_SYNC_SEND_FILE, TAG_APP_PROCESS_START, TAG_KEYGUARD_DISMISSED, TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT, TAG_KEYGUARD_SECURED, TAG_OS_STARTUP, TAG_OS_SHUTDOWN, TAG_LOGGING_STARTED, TAG_LOGGING_STOPPED, TAG_MEDIA_MOUNT, TAG_MEDIA_UNMOUNT, TAG_LOG_BUFFER_SIZE_CRITICAL, TAG_PASSWORD_EXPIRATION_SET, TAG_PASSWORD_COMPLEXITY_SET, TAG_PASSWORD_HISTORY_LENGTH_SET, TAG_MAX_SCREEN_LOCK_TIMEOUT_SET, TAG_MAX_PASSWORD_ATTEMPTS_SET, TAG_KEYGUARD_DISABLED_FEATURES_SET, TAG_REMOTE_LOCK, TAG_USER_RESTRICTION_ADDED, TAG_USER_RESTRICTION_REMOVED, TAG_WIPE_FAILURE, TAG_KEY_GENERATED, TAG_KEY_IMPORT, TAG_KEY_DESTRUCTION, TAG_CERT_AUTHORITY_INSTALLED, TAG_CERT_AUTHORITY_REMOVED, TAG_CRYPTO_SELF_TEST_COMPLETED, TAG_KEY_INTEGRITY_VIOLATION or TAG_CERT_VALIDATION_FAILURE.", "type": "int"}], "class": "android.app.assist.AssistContent\n", "type": "int", "name": "getTag", "throws": null, "funcname": "int getTag ()", "descri": "  Returns the tag of this log entry, which specifies entry's semantics. ", "parameters": null}, {"returns": null, "class": "android.app.backup.BackupDataInput\n", "type": "final\n        \n        void", "name": "fullBackupFile", "throws": null, "funcname": "void fullBackupFile (File file,                 FullBackupDataOutput output)", "descri": "  Write an entire file as part of a full-backup operation.  The file's contents will be delivered to the backup destination along with the metadata necessary to place it with the proper location and permissions on the device where the data is restored. Attempting to back up files in directories that are ignored by the backup system will have no effect.  For example, if the app calls this method with a file inside the getNoBackupFilesDir() directory, it will be ignored. See onFullBackup(FullBackupDataOutput) for details on what directories are excluded from backups. ", "parameters": [{"scri": "File: The file to be backed up.  The file must exist and be readable by     the caller.", "name": "file"}, {"scri": "FullBackupDataOutput: The destination to which the backed-up file data will be sent.", "name": "output"}]}, {"returns": null, "class": "android.app.backup.BackupDataInput\n", "type": "void", "name": "onRestoreFile", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void onRestoreFile (ParcelFileDescriptor data,                 long size,                 File destination,                 int type,                 long mode,                 long mtime)", "descri": "  Handle the data delivered via the given file descriptor during a full restore operation.  The agent is given the path to the file's original location as well as its size and metadata. The file descriptor can only be read for size bytes; attempting to read more data has undefined behavior. The default implementation creates the destination file/directory and populates it with the data from the file descriptor, then sets the file's access mode and modification time to match the restore arguments.   ", "parameters": [{"scri": "ParcelFileDescriptor: A read-only file descriptor from which the agent can read size     bytes of file data.", "name": "data"}, {"scri": "long: The number of bytes of file content to be restored to the given     destination.  If the file system object being restored is a directory, size     will be zero.", "name": "size"}, {"scri": "File: The File on disk to be restored with the given data.", "name": "destination"}, {"scri": "int: The kind of file system object being restored.  This will be either     TYPE_FILE or TYPE_DIRECTORY.", "name": "type"}, {"scri": "long: The access mode to be assigned to the destination after its data is     written.  This is in the standard format used by chmod().", "name": "mode"}, {"scri": "long: The modification time of the file when it was backed up, suitable to     be assigned to the file after its data is written.", "name": "mtime"}]}, {"returns": null, "class": "android.app.backup.BackupHelper\n", "type": "void", "name": "setWebUri", "throws": null, "funcname": "void setWebUri (Uri uri)", "descri": "  Set a web URI associated with the current data being shown to the user. This URI could be opened in a web browser, or in the app as an ACTION_VIEW Intent, to show the same data that is currently being displayed by it.  The URI here should be something that is transportable off the device into other environments to acesss the same data as is currently being shown in the app; if the app does not have such a representation, it should leave the null and only report the local intent and clip data. ", "parameters": [{"scri": "Uri", "name": "uri"}]}, {"returns": null, "class": "android.app.Notification.Action.Builder\n", "type": "void", "name": "onPause", "throws": null, "funcname": "void onPause ()", "descri": "  Called as part of the activity lifecycle when an activity is going into the background, but has not (yet) been killed.  The counterpart to onResume(). When activity B is launched in front of activity A, this callback will be invoked on A.  B will not be created until A's onPause() returns, so be sure to not do anything lengthy here. This callback is mostly used for saving any persistent state the activity is editing, to present a \"edit in place\" model to the user and making sure nothing is lost if there are not enough resources to start the new activity without first killing this one.  This is also a good place to do things like stop animations and other things that consume a noticeable amount of CPU in order to make the switch to the next activity as fast as possible, or to close resources that are exclusive access such as the camera. In situations where the system needs more memory it may kill paused processes to reclaim resources.  Because of this, you should be sure that all of your state is saved by the time you return from this function.  In general onSaveInstanceState(Bundle) is used to save per-instance state in the activity and this method is used to store global persistent data (in content providers, files, etc.) After receiving this call you will usually receive a following call to onStop() (after the next activity has been resumed and displayed), however in some cases there will be a direct call back to onResume() without going through the stopped state. Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.", "parameters": null}, {"returns": null, "class": "android.app.Notification.Action.Builder\n", "type": "void", "name": "onResume", "throws": null, "funcname": "void onResume ()", "descri": "  Called after onRestoreInstanceState(Bundle), onRestart(), or onPause(), for your activity to start interacting with the user. This is a good place to begin animations, open exclusive-access devices (such as the camera), etc. Keep in mind that onResume is not the best indicator that your activity is visible to the user; a system window such as the keyguard may be in front.  Use onWindowFocusChanged(boolean) to know for certain that your activity is visible to the user (for example, to resume a game). Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.", "parameters": null}, {"returns": [{"scri": "true to indicate to the JobManager whether you'd like to reschedule this job based on the retry criteria provided at job creation-time; or false to end the job entirely.  Regardless of the value returned, your job must stop executing.", "type": "boolean"}], "class": "android.app.slice.SliceManager.SliceCallback\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "onStopJob", "throws": null, "funcname": "boolean onStopJob (JobParameters params)", "descri": "  This method is called if the system has determined that you must stop execution of your job even before you've had a chance to call jobFinished(JobParameters, boolean). This will happen if the requirements specified at schedule time are no longer met. For example you may have requested WiFi with setRequiredNetworkType(int), yet while your job was executing the user toggled WiFi. Another example is if you had specified setRequiresDeviceIdle(boolean), and the phone left its idle maintenance window. You are solely responsible for the behavior of your application upon receipt of this message; your app will likely start to misbehave if you ignore it. Once this method returns, the system releases the wakelock that it is holding on behalf of the job.  ", "parameters": [{"scri": "JobParameters: The parameters identifying this job, as supplied to               the job in the onStartJob(JobParameters) callback.", "name": "params"}]}, {"returns": null, "class": "android.app.TimePickerDialog\n", "type": "void", "name": "onSharedElementsArrived", "throws": null, "funcname": "void onSharedElementsArrived (List<String> sharedElementNames,                 List<View> sharedElements,                 SharedElementCallback.OnSharedElementsReadyListener listener)", "descri": "  Called during an Activity Transition when the shared elements have arrived at the final location and are ready to be transferred. This method is called for both the source and destination Activities. When the shared elements are ready to be transferred, onSharedElementsReady() must be called to trigger the transfer. The default behavior is to trigger the transfer immediately. ", "parameters": [{"scri": "List: The names of the shared elements that are being transferred..", "name": "sharedElementNames"}, {"scri": "List: The shared elements that are part of the View hierarchy.", "name": "sharedElements"}, {"scri": "SharedElementCallback.OnSharedElementsReadyListener: The listener to call when the shared elements are ready to be hidden                 in the source Activity or shown in the destination Activity.", "name": "listener"}]}, {"returns": [{"scri": "The number of rows affected.", "type": "int"}], "class": "android.app.usage.NetworkStats\n", "type": "final\n        \n        int", "name": "delete", "throws": null, "funcname": "int delete (Uri uri,                 String selection,                 String[] selectionArgs)", "descri": "  Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call notifyChange() after deleting. This method can be called from multiple threads, as described in Processes and Threads. The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in content://contacts/people/22 and the implementation is responsible for parsing the record number (22) when creating a SQL statement.  ", "parameters": [{"scri": "Uri: The full URI to query, including a row ID (if a specific record is requested).", "name": "uri"}, {"scri": "String: An optional restriction to apply to rows when deleting.", "name": "selection"}, {"scri": "String", "name": "selectionArgs"}]}, {"returns": null, "class": "android.app.usage.StorageStats\n", "type": "void", "name": "registerUsageCallback", "throws": null, "funcname": "void registerUsageCallback (int networkType,                 String subscriberId,                 long thresholdBytes,                 NetworkStatsManager.UsageCallback callback,                 Handler handler)", "descri": "  Registers to receive notifications about data usage on specified networks. The callbacks will continue to be called as long as the process is live or unregisterUsageCallback(NetworkStatsManager.UsageCallback) is called. ", "parameters": [{"scri": "int: Type of network to monitor. Either                  TYPE_MOBILE or TYPE_WIFI.", "name": "networkType"}, {"scri": "String: If applicable, the subscriber id of the network interface.", "name": "subscriberId"}, {"scri": "long: Threshold in bytes to be notified on.", "name": "thresholdBytes"}, {"scri": "NetworkStatsManager.UsageCallback: The NetworkStatsManager.UsageCallback that the system will call when data usage            has exceeded the specified threshold.", "name": "callback"}, {"scri": "Handler: to dispatch callback events through, otherwise if null it uses            the calling thread.", "name": "handler"}]}, {"returns": [{"scri": "Whether the action was successfully performed.", "type": "boolean"}], "class": "android.app.VoiceInteractor.CommandRequest\n", "type": "boolean", "name": "performGlobalAction", "throws": null, "funcname": "boolean performGlobalAction (int action)", "descri": "  Performs a global action. Such an action can be performed at any moment regardless of the current application or user location in that application. For example going back, going home, opening recents, etc.    See also: GLOBAL_ACTION_BACKGLOBAL_ACTION_HOMEGLOBAL_ACTION_NOTIFICATIONSGLOBAL_ACTION_RECENTS", "parameters": [{"scri": "int: The action to perform.", "name": "action"}]}, {"returns": null, "class": "android.app.VoiceInteractor.CompleteVoiceRequest\n", "type": "void", "name": "setNightMode", "throws": null, "funcname": "void setNightMode (int mode)", "descri": "  Sets the night mode. The mode can be one of: MODE_NIGHT_NO sets the device into       notnight mode MODE_NIGHT_YES sets the device into       night mode MODE_NIGHT_AUTO automatically switches between       night and notnight based on the device's current       location and certain other sensors  Note: On API 22 and below, changes to the night mode are only effective when the car or desk mode is enabled on a device. Starting in API 23, changes to night mode are always effective.   See also: getNightMode()", "parameters": [{"scri": "int: the night mode to setValue is MODE_NIGHT_AUTO, MODE_NIGHT_NO or MODE_NIGHT_YES.", "name": "mode"}]}, {"returns": null, "class": "android.app.WallpaperInfo\n", "type": "VoiceInteractor.PickOptionRequest.Option", "name": "VoiceInteractor.PickOptionRequest.Option", "throws": null, "funcname": "VoiceInteractor.PickOptionRequest.Option (CharSequence label,                 int index)", "descri": "  Creates an option that a user can select with their voice by matching the label or one of several synonyms. ", "parameters": [{"scri": "CharSequence: The label that will both be matched against what the user speaks     and displayed visually.", "name": "label"}, {"scri": "int: The location of this option within the overall set of options.     Can be used to help identify the option when it is returned from the     voice interactor.", "name": "index"}]}, {"returns": null, "class": "android.app.WallpaperInfo\n", "name": "VoiceInteractor.PickOptionRequest.Option", "throws": null, "funcname": "VoiceInteractor.PickOptionRequest.Option (CharSequence label,                 int index)", "parameters": [{"scri": "CharSequence: The label that will both be matched against what the user speaks     and displayed visually.", "name": "label"}, {"scri": "int: The location of this option within the overall set of options.     Can be used to help identify the option when it is returned from the     voice interactor.", "name": "index"}], "descri": "  Creates an option that a user can select with their voice by matching the label or one of several synonyms. "}, {"returns": null, "class": "android.app.WallpaperInfo\n", "name": "VoiceInteractor.PickOptionRequest.Option", "throws": null, "funcname": "VoiceInteractor.PickOptionRequest.Option (CharSequence label,                 int index)", "parameters": [{"scri": "CharSequence: The label that will both be matched against what the user speaks     and displayed visually.", "name": "label"}, {"scri": "int: The location of this option within the overall set of options.     Can be used to help identify the option when it is returned from the     voice interactor.", "name": "index"}], "descri": "  Creates an option that a user can select with their voice by matching the label or one of several synonyms. "}, {"returns": [{"scri": "the current standby bucket of the calling app. One of STANDBY_BUCKET_* constants.Value is STANDBY_BUCKET_ACTIVE, STANDBY_BUCKET_WORKING_SET, STANDBY_BUCKET_FREQUENT or STANDBY_BUCKET_RARE.", "type": "int"}], "class": "android.appwidget.AppWidgetManager\n", "type": "int", "name": "getAppStandbyBucket", "throws": null, "funcname": "int getAppStandbyBucket ()", "descri": "  Returns the current standby bucket of the calling app. The system determines the standby state of the app based on app usage patterns. Standby buckets determine how much an app will be restricted from running background tasks such as jobs and alarms. Restrictions increase progressively from STANDBY_BUCKET_ACTIVE to STANDBY_BUCKET_RARE, with STANDBY_BUCKET_ACTIVE being the least restrictive. The battery level of the device might also affect the restrictions. Apps in buckets \u2264 STANDBY_BUCKET_ACTIVE have no standby restrictions imposed. Apps in buckets > STANDBY_BUCKET_FREQUENT may have network access restricted when running in the background. The standby state of an app can change at any time either due to a user interaction or a system interaction or some algorithm determining that the app can be restricted for a period of time before the user has a need for it. You can also query the recent history of standby bucket changes by calling queryEventsForSelf(long, long) and searching for STANDBY_BUCKET_CHANGED. ", "parameters": null}, {"returns": null, "class": "android.bluetooth.BluetoothAdapter\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onLeScan", "throws": null, "funcname": "void onLeScan (BluetoothDevice device,                 int rssi,                 byte[] scanRecord)", "descri": "  Callback reporting an LE device found during a device scan initiated by the startLeScan(BluetoothAdapter.LeScanCallback) function. ", "parameters": [{"scri": "BluetoothDevice: Identifies the remote device", "name": "device"}, {"scri": "int: The RSSI value for the remote device as reported by the Bluetooth hardware. 0 if no RSSI value is available.", "name": "rssi"}, {"scri": "byte: The content of the advertisement record offered by the remote device.", "name": "scanRecord"}]}, {"returns": null, "class": "android.bluetooth.BluetoothAdapter\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onLeScan", "throws": null, "funcname": "void onLeScan (BluetoothDevice device,                 int rssi,                 byte[] scanRecord)", "descri": "  Callback reporting an LE device found during a device scan initiated by the startLeScan(BluetoothAdapter.LeScanCallback) function. ", "parameters": [{"scri": "BluetoothDevice: Identifies the remote device", "name": "device"}, {"scri": "int: The RSSI value for the remote device as reported by the Bluetooth hardware. 0 if no RSSI value is available.", "name": "rssi"}, {"scri": "byte: The content of the advertisement record offered by the remote device.", "name": "scanRecord"}]}, {"returns": null, "class": "android.bluetooth.BluetoothClass\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onServiceConnected", "throws": null, "funcname": "void onServiceConnected (int profile,                 BluetoothProfile proxy)", "descri": "  Called to notify the client when the proxy object has been connected to the service. ", "parameters": [{"scri": "int: - One of HEALTH, HEADSET or A2DP", "name": "profile"}, {"scri": "BluetoothProfile: - One of BluetoothHealth, BluetoothHeadset or BluetoothA2dp", "name": "proxy"}]}, {"returns": [{"scri": "State of the profile connection. One of STATE_CONNECTED, STATE_CONNECTING, STATE_DISCONNECTED, STATE_DISCONNECTING", "type": "int"}], "class": "android.bluetooth.BluetoothClass.Device\n", "type": "int", "name": "getConnectionState", "throws": null, "funcname": "int getConnectionState (BluetoothDevice device)", "descri": "  Get the current connection state of the profile  ", "parameters": [{"scri": "BluetoothDevice: Remote bluetooth device.", "name": "device"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device\n", "type": "boolean", "name": "isA2dpPlaying", "throws": null, "funcname": "boolean isA2dpPlaying (BluetoothDevice device)", "descri": "  Check if A2DP profile is streaming music. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothDevice: BluetoothDevice device", "name": "device"}]}, {"returns": [{"scri": "true on success, false on error", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "cancelDiscovery", "throws": null, "funcname": "boolean cancelDiscovery ()", "descri": "  Cancel the current device discovery process. Because discovery is a heavyweight procedure for the Bluetooth adapter, this method should always be called before attempting to connect to a remote device with connect(). Discovery is not managed by the  Activity, but is run as a system service, so an application should always call cancel discovery even if it did not directly request a discovery, just to be sure. If Bluetooth state is not STATE_ON, this API will return false. After turning on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated value. Requires the BLUETOOTH_ADMIN permission. ", "parameters": null}, {"returns": [{"scri": "true if the address is valid, false otherwise", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "static\n        \n        \n        boolean", "name": "checkBluetoothAddress", "throws": null, "funcname": "boolean checkBluetoothAddress (String address)", "descri": "  Validate a String Bluetooth address, such as \"00:43:A8:23:10:F0\" Alphabetic characters must be uppercase to be valid.  ", "parameters": [{"scri": "String: Bluetooth address as string", "name": "address"}]}, {"returns": null, "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "void", "name": "closeProfileProxy", "throws": null, "funcname": "void closeProfileProxy (int profile,                 BluetoothProfile proxy)", "descri": "  Close the connection of the profile proxy to the Service. Clients should call this when they are no longer using the proxy obtained from getProfileProxy(Context, BluetoothProfile.ServiceListener, int). Profile can be one of  HEALTH, HEADSET or A2DP ", "parameters": [{"scri": "BluetoothProfile: Profile proxy object", "name": "proxy"}]}, {"returns": [{"scri": "true to indicate adapter shutdown has begun, or false on immediate error", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "disable", "throws": null, "funcname": "boolean disable ()", "descri": "  Turn off the local Bluetooth adapter\u2014do not use without explicit user action to turn off Bluetooth. This gracefully shuts down all Bluetooth connections, stops Bluetooth system services, and powers down the underlying Bluetooth hardware. Bluetooth should never be disabled without direct user consent. The disable() method is provided only for applications that include a user interface for changing system settings, such as a \"power manager\" app.  This is an asynchronous call: it will return immediately, and clients should listen for ACTION_STATE_CHANGED to be notified of subsequent adapter state changes. If this call returns true, then the adapter state will immediately transition from STATE_ON to STATE_TURNING_OFF, and some time later transition to either STATE_OFF or STATE_ON. If this call returns false then there was an immediate problem that will prevent the adapter from being turned off - such as the adapter already being turned off. Requires the BLUETOOTH_ADMIN permission. ", "parameters": null}, {"returns": [{"scri": "true to indicate adapter startup has begun, or false on immediate error", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "enable", "throws": null, "funcname": "boolean enable ()", "descri": "  Turn on the local Bluetooth adapter\u2014do not use without explicit user action to turn on Bluetooth. This powers on the underlying Bluetooth hardware, and starts all Bluetooth system services. Bluetooth should never be enabled without direct user consent. If you want to turn on Bluetooth in order to create a wireless connection, you should use the ACTION_REQUEST_ENABLE Intent, which will raise a dialog that requests user permission to turn on Bluetooth. The enable() method is provided only for applications that include a user interface for changing system settings, such as a \"power manager\" app.  This is an asynchronous call: it will return immediately, and clients should listen for ACTION_STATE_CHANGED to be notified of subsequent adapter state changes. If this call returns true, then the adapter state will immediately transition from STATE_OFF to STATE_TURNING_ON, and some time later transition to either STATE_OFF or STATE_ON. If this call returns false then there was an immediate problem that will prevent the adapter from being turned on - such as Airplane mode, or the adapter is already turned on. Requires the BLUETOOTH_ADMIN permission. ", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "int", "name": "getProfileConnectionState", "throws": null, "funcname": "int getProfileConnectionState (int profile)", "descri": "  Get the current connection state of a profile. This function can be used to check whether the local Bluetooth adapter is connected to any remote device for a specific profile. Profile can be one of HEALTH, HEADSET, A2DP. Return value can be one of STATE_DISCONNECTED, STATE_CONNECTING, STATE_CONNECTED, STATE_DISCONNECTING Requires the BLUETOOTH permission.  ", "parameters": [{"scri": "int", "name": "profile"}]}, {"returns": [{"scri": "true on success, false on error", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "getProfileProxy", "throws": null, "funcname": "boolean getProfileProxy (Context context,                 BluetoothProfile.ServiceListener listener,                 int profile)", "descri": "  Get the profile proxy object associated with the profile. Profile can be one of HEALTH, HEADSET, A2DP, GATT, or GATT_SERVER. Clients must implement BluetoothProfile.ServiceListener to get notified of the connection status and to get the proxy object.  ", "parameters": [{"scri": "Context: Context of the application", "name": "context"}, {"scri": "BluetoothProfile.ServiceListener: The service Listener for connection callbacks.", "name": "listener"}, {"scri": "int: The Bluetooth profile; either HEALTH, HEADSET, A2DP. GATT or GATT_SERVER.", "name": "profile"}]}, {"returns": [{"scri": "true on success, false on error", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "getProfileProxy", "throws": null, "funcname": "boolean getProfileProxy (Context context,                 BluetoothProfile.ServiceListener listener,                 int profile)", "descri": "  Get the profile proxy object associated with the profile. Profile can be one of HEALTH, HEADSET, A2DP, GATT, or GATT_SERVER. Clients must implement BluetoothProfile.ServiceListener to get notified of the connection status and to get the proxy object.  ", "parameters": [{"scri": "Context: Context of the application", "name": "context"}, {"scri": "BluetoothProfile.ServiceListener: The service Listener for connection callbacks.", "name": "listener"}, {"scri": "int: The Bluetooth profile; either HEALTH, HEADSET, A2DP. GATT or GATT_SERVER.", "name": "profile"}]}, {"returns": [{"scri": "scan modeValue is SCAN_MODE_NONE, SCAN_MODE_CONNECTABLE or SCAN_MODE_CONNECTABLE_DISCOVERABLE.", "type": "int"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "int", "name": "getScanMode", "throws": null, "funcname": "int getScanMode ()", "descri": "  Get the current Bluetooth scan mode of the local Bluetooth adapter. The Bluetooth scan mode determines if the local adapter is connectable and/or discoverable from remote Bluetooth devices. Possible values are: SCAN_MODE_NONE, SCAN_MODE_CONNECTABLE, SCAN_MODE_CONNECTABLE_DISCOVERABLE. If Bluetooth state is not STATE_ON, this API will return SCAN_MODE_NONE. After turning on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated value. Requires the BLUETOOTH permission. ", "parameters": null}, {"returns": [{"scri": "current state of Bluetooth adapterValue is STATE_OFF, STATE_TURNING_ON, STATE_ON or STATE_TURNING_OFF.", "type": "int"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "int", "name": "getState", "throws": null, "funcname": "int getState ()", "descri": "  Get the current state of the local Bluetooth adapter. Possible return values are STATE_OFF, STATE_TURNING_ON, STATE_ON, STATE_TURNING_OFF. Requires the BLUETOOTH permission. ", "parameters": null}, {"returns": [{"scri": "true if discovering", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "isDiscovering", "throws": null, "funcname": "boolean isDiscovering ()", "descri": "  Return true if the local Bluetooth adapter is currently in the device discovery process. Device discovery is a heavyweight procedure. New connections to remote Bluetooth devices should not be attempted while discovery is in progress, and existing connections will experience limited bandwidth and high latency. Use cancelDiscovery() to cancel an ongoing discovery. Applications can also register for ACTION_DISCOVERY_STARTED or ACTION_DISCOVERY_FINISHED to be notified when discovery starts or completes. If Bluetooth state is not STATE_ON, this API will return false. After turning on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated value. Requires the BLUETOOTH permission. ", "parameters": null}, {"returns": [{"scri": "true if the local adapter is turned on", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "isEnabled", "throws": null, "funcname": "boolean isEnabled ()", "descri": "  Return true if Bluetooth is currently enabled and ready for use. Equivalent to: getBluetoothState() == STATE_ON Requires the BLUETOOTH permission. ", "parameters": null}, {"returns": [{"scri": "true if the name was set, false otherwise", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "setName", "throws": null, "funcname": "boolean setName (String name)", "descri": "  Set the friendly Bluetooth name of the local Bluetooth adapter. This name is visible to remote Bluetooth devices. Valid Bluetooth names are a maximum of 248 bytes using UTF-8 encoding, although many remote devices can only display the first 40 characters, and some may be limited to just 20. If Bluetooth state is not STATE_ON, this API will return false. After turning on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated value. Requires the BLUETOOTH_ADMIN permission.  ", "parameters": [{"scri": "String: a valid Bluetooth name", "name": "name"}]}, {"returns": [{"scri": "true on success, false on error", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "startDiscovery", "throws": null, "funcname": "boolean startDiscovery ()", "descri": "  Start the remote device discovery process. The discovery process usually involves an inquiry scan of about 12 seconds, followed by a page scan of each new device to retrieve its Bluetooth name. This is an asynchronous call, it will return immediately. Register for ACTION_DISCOVERY_STARTED and ACTION_DISCOVERY_FINISHED intents to determine exactly when the discovery starts and completes. Register for ACTION_FOUND to be notified as remote Bluetooth devices are found. Device discovery is a heavyweight procedure. New connections to remote Bluetooth devices should not be attempted while discovery is in progress, and existing connections will experience limited bandwidth and high latency. Use cancelDiscovery() to cancel an ongoing discovery. Discovery is not managed by the Activity, but is run as a system service, so an application should always call cancelDiscovery() even if it did not directly request a discovery, just to be sure. Device discovery will only find remote devices that are currently discoverable (inquiry scan enabled). Many Bluetooth devices are not discoverable by default, and need to be entered into a special mode. If Bluetooth state is not STATE_ON, this API will return false. After turning on Bluetooth, wait for ACTION_STATE_CHANGED with STATE_ON to get the updated value. Requires the BLUETOOTH_ADMIN permission. ", "parameters": null}, {"returns": [{"scri": "true, if the scan was started successfully", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "startLeScan", "throws": null, "funcname": "boolean startLeScan (UUID[] serviceUuids,                 BluetoothAdapter.LeScanCallback callback)", "descri": "   This method was deprecated      in API level 21.    use startScan(List, ScanSettings, ScanCallback) instead.  Starts a scan for Bluetooth LE devices, looking for devices that advertise given services. Devices which advertise all specified services are reported using the onLeScan(BluetoothDevice, int, byte[]) callback. Requires the BLUETOOTH_ADMIN permission.  ", "parameters": [{"scri": "UUID: Array of services to look for", "name": "serviceUuids"}, {"scri": "BluetoothAdapter.LeScanCallback: the callback LE scan results are delivered", "name": "callback"}]}, {"returns": [{"scri": "true, if the scan was started successfully", "type": "boolean"}], "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "boolean", "name": "startLeScan", "throws": null, "funcname": "boolean startLeScan (BluetoothAdapter.LeScanCallback callback)", "descri": "   This method was deprecated      in API level 21.    use startScan(List, ScanSettings, ScanCallback) instead.  Starts a scan for Bluetooth LE devices. Results of the scan are reported using the onLeScan(BluetoothDevice, int, byte[]) callback. Requires the BLUETOOTH_ADMIN permission.  ", "parameters": [{"scri": "BluetoothAdapter.LeScanCallback: the callback LE scan results are delivered", "name": "callback"}]}, {"returns": null, "class": "android.bluetooth.BluetoothClass.Device.Major\n", "type": "void", "name": "stopLeScan", "throws": null, "funcname": "void stopLeScan (BluetoothAdapter.LeScanCallback callback)", "descri": "   This method was deprecated      in API level 21.    Use stopScan(ScanCallback) instead.  Stops an ongoing Bluetooth LE device scan. Requires the BLUETOOTH_ADMIN permission. ", "parameters": [{"scri": "BluetoothAdapter.LeScanCallback: used to identify which scan to stop must be the same handle used to start the scan", "name": "callback"}]}, {"returns": [{"scri": "the device type DEVICE_TYPE_CLASSIC, DEVICE_TYPE_LE DEVICE_TYPE_DUAL. DEVICE_TYPE_UNKNOWN if it's not available", "type": "int"}], "class": "android.bluetooth.BluetoothGattCharacteristic\n", "type": "int", "name": "getType", "throws": null, "funcname": "int getType ()", "descri": "  Get the Bluetooth device type of the remote device. Requires the BLUETOOTH permission. ", "parameters": null}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onCharacteristicChanged", "throws": null, "funcname": "void onCharacteristicChanged (BluetoothGatt gatt,                 BluetoothGattCharacteristic characteristic)", "descri": "  Callback triggered as a result of a remote characteristic notification. ", "parameters": [{"scri": "BluetoothGatt: GATT client the characteristic is associated with", "name": "gatt"}, {"scri": "BluetoothGattCharacteristic: Characteristic that has been updated as a result of a remote notification event.", "name": "characteristic"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onCharacteristicChanged", "throws": null, "funcname": "void onCharacteristicChanged (BluetoothGatt gatt,                 BluetoothGattCharacteristic characteristic)", "descri": "  Callback triggered as a result of a remote characteristic notification. ", "parameters": [{"scri": "BluetoothGatt: GATT client the characteristic is associated with", "name": "gatt"}, {"scri": "BluetoothGattCharacteristic: Characteristic that has been updated as a result of a remote notification event.", "name": "characteristic"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onCharacteristicRead", "throws": null, "funcname": "void onCharacteristicRead (BluetoothGatt gatt,                 BluetoothGattCharacteristic characteristic,                 int status)", "descri": "  Callback reporting the result of a characteristic read operation. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked readCharacteristic(BluetoothGattCharacteristic)", "name": "gatt"}, {"scri": "BluetoothGattCharacteristic: Characteristic that was read from the associated remote device.", "name": "characteristic"}, {"scri": "int: GATT_SUCCESS if the read operation was completed successfully.", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onCharacteristicRead", "throws": null, "funcname": "void onCharacteristicRead (BluetoothGatt gatt,                 BluetoothGattCharacteristic characteristic,                 int status)", "descri": "  Callback reporting the result of a characteristic read operation. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked readCharacteristic(BluetoothGattCharacteristic)", "name": "gatt"}, {"scri": "BluetoothGattCharacteristic: Characteristic that was read from the associated remote device.", "name": "characteristic"}, {"scri": "int: GATT_SUCCESS if the read operation was completed successfully.", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onCharacteristicWrite", "throws": null, "funcname": "void onCharacteristicWrite (BluetoothGatt gatt,                 BluetoothGattCharacteristic characteristic,                 int status)", "descri": "  Callback indicating the result of a characteristic write operation. If this callback is invoked while a reliable write transaction is in progress, the value of the characteristic represents the value reported by the remote device. An application should compare this value to the desired value to be written. If the values don't match, the application must abort the reliable write transaction. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked writeCharacteristic(BluetoothGattCharacteristic)", "name": "gatt"}, {"scri": "BluetoothGattCharacteristic: Characteristic that was written to the associated remote device.", "name": "characteristic"}, {"scri": "int: The result of the write operation GATT_SUCCESS if the operation succeeds.", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onCharacteristicWrite", "throws": null, "funcname": "void onCharacteristicWrite (BluetoothGatt gatt,                 BluetoothGattCharacteristic characteristic,                 int status)", "descri": "  Callback indicating the result of a characteristic write operation. If this callback is invoked while a reliable write transaction is in progress, the value of the characteristic represents the value reported by the remote device. An application should compare this value to the desired value to be written. If the values don't match, the application must abort the reliable write transaction. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked writeCharacteristic(BluetoothGattCharacteristic)", "name": "gatt"}, {"scri": "BluetoothGattCharacteristic: Characteristic that was written to the associated remote device.", "name": "characteristic"}, {"scri": "int: The result of the write operation GATT_SUCCESS if the operation succeeds.", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onConnectionStateChange", "throws": null, "funcname": "void onConnectionStateChange (BluetoothGatt gatt,                 int status,                 int newState)", "descri": "  Callback indicating when GATT client has connected/disconnected to/from a remote GATT server. ", "parameters": [{"scri": "BluetoothGatt: GATT client", "name": "gatt"}, {"scri": "int: Status of the connect or disconnect operation. GATT_SUCCESS if the operation succeeds.", "name": "status"}, {"scri": "int: Returns the new connection state. Can be one of STATE_DISCONNECTED or STATE_CONNECTED", "name": "newState"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onDescriptorRead", "throws": null, "funcname": "void onDescriptorRead (BluetoothGatt gatt,                 BluetoothGattDescriptor descriptor,                 int status)", "descri": "  Callback reporting the result of a descriptor read operation. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked readDescriptor(BluetoothGattDescriptor)", "name": "gatt"}, {"scri": "BluetoothGattDescriptor: Descriptor that was read from the associated remote device.", "name": "descriptor"}, {"scri": "int: GATT_SUCCESS if the read operation was completed successfully", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onDescriptorRead", "throws": null, "funcname": "void onDescriptorRead (BluetoothGatt gatt,                 BluetoothGattDescriptor descriptor,                 int status)", "descri": "  Callback reporting the result of a descriptor read operation. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked readDescriptor(BluetoothGattDescriptor)", "name": "gatt"}, {"scri": "BluetoothGattDescriptor: Descriptor that was read from the associated remote device.", "name": "descriptor"}, {"scri": "int: GATT_SUCCESS if the read operation was completed successfully", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onDescriptorWrite", "throws": null, "funcname": "void onDescriptorWrite (BluetoothGatt gatt,                 BluetoothGattDescriptor descriptor,                 int status)", "descri": "  Callback indicating the result of a descriptor write operation. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked writeDescriptor(BluetoothGattDescriptor)", "name": "gatt"}, {"scri": "BluetoothGattDescriptor: Descriptor that was writte to the associated remote device.", "name": "descriptor"}, {"scri": "int: The result of the write operation GATT_SUCCESS if the operation succeeds.", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onDescriptorWrite", "throws": null, "funcname": "void onDescriptorWrite (BluetoothGatt gatt,                 BluetoothGattDescriptor descriptor,                 int status)", "descri": "  Callback indicating the result of a descriptor write operation. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked writeDescriptor(BluetoothGattDescriptor)", "name": "gatt"}, {"scri": "BluetoothGattDescriptor: Descriptor that was writte to the associated remote device.", "name": "descriptor"}, {"scri": "int: The result of the write operation GATT_SUCCESS if the operation succeeds.", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onMtuChanged", "throws": null, "funcname": "void onMtuChanged (BluetoothGatt gatt,                 int mtu,                 int status)", "descri": "  Callback indicating the MTU for a given device connection has changed. This callback is triggered in response to the requestMtu(int) function, or in response to a connection event. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked requestMtu(int)", "name": "gatt"}, {"scri": "int: The new MTU size", "name": "mtu"}, {"scri": "int: GATT_SUCCESS if the MTU has been changed successfully", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onPhyRead", "throws": null, "funcname": "void onPhyRead (BluetoothGatt gatt,                 int txPhy,                 int rxPhy,                 int status)", "descri": "  Callback triggered as result of readPhy() ", "parameters": [{"scri": "BluetoothGatt: GATT client", "name": "gatt"}, {"scri": "int: the transmitter PHY in use. One of PHY_LE_1M, PHY_LE_2M, and PHY_LE_CODED.", "name": "txPhy"}, {"scri": "int: the receiver PHY in use. One of PHY_LE_1M, PHY_LE_2M, and PHY_LE_CODED.", "name": "rxPhy"}, {"scri": "int: Status of the PHY read operation. GATT_SUCCESS if the operation succeeds.", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onPhyUpdate", "throws": null, "funcname": "void onPhyUpdate (BluetoothGatt gatt,                 int txPhy,                 int rxPhy,                 int status)", "descri": "  Callback triggered as result of setPreferredPhy(int, int, int), or as a result of remote device changing the PHY. ", "parameters": [{"scri": "BluetoothGatt: GATT client", "name": "gatt"}, {"scri": "int: the transmitter PHY in use. One of PHY_LE_1M, PHY_LE_2M, and PHY_LE_CODED.", "name": "txPhy"}, {"scri": "int: the receiver PHY in use. One of PHY_LE_1M, PHY_LE_2M, and PHY_LE_CODED.", "name": "rxPhy"}, {"scri": "int: Status of the PHY update operation. GATT_SUCCESS if the operation succeeds.", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onReadRemoteRssi", "throws": null, "funcname": "void onReadRemoteRssi (BluetoothGatt gatt,                 int rssi,                 int status)", "descri": "  Callback reporting the RSSI for a remote device connection. This callback is triggered in response to the readRemoteRssi() function. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked readRemoteRssi()", "name": "gatt"}, {"scri": "int: The RSSI value for the remote device", "name": "rssi"}, {"scri": "int: GATT_SUCCESS if the RSSI was read successfully", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onReliableWriteCompleted", "throws": null, "funcname": "void onReliableWriteCompleted (BluetoothGatt gatt,                 int status)", "descri": "  Callback invoked when a reliable write transaction has been completed. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked executeReliableWrite()", "name": "gatt"}, {"scri": "int: GATT_SUCCESS if the reliable write transaction was executed successfully", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattServer\n", "type": "void", "name": "onServicesDiscovered", "throws": null, "funcname": "void onServicesDiscovered (BluetoothGatt gatt,                 int status)", "descri": "  Callback invoked when the list of remote services, characteristics and descriptors for the remote device have been updated, ie new services have been discovered. ", "parameters": [{"scri": "BluetoothGatt: GATT client invoked discoverServices()", "name": "gatt"}, {"scri": "int: GATT_SUCCESS if the remote device has been explored successfully.", "name": "status"}]}, {"returns": [{"scri": "true, if the descriptor was added to the characteristic", "type": "boolean"}], "class": "android.bluetooth.BluetoothGattService\n", "type": "boolean", "name": "addDescriptor", "throws": null, "funcname": "boolean addDescriptor (BluetoothGattDescriptor descriptor)", "descri": "  Adds a descriptor to this characteristic. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothGattDescriptor: Descriptor to be added to this characteristic.", "name": "descriptor"}]}, {"returns": [{"scri": "Cached value of the characteristic", "type": "byte[]"}], "class": "android.bluetooth.BluetoothGattService\n", "type": "byte[]", "name": "getValue", "throws": null, "funcname": "byte[] getValue ()", "descri": "  Get the stored value for this characteristic. This function returns the stored value for this characteristic as retrieved by calling readCharacteristic(BluetoothGattCharacteristic). The cached value of the characteristic is updated as a result of a read characteristic operation or if a characteristic update notification has been received. ", "parameters": null}, {"returns": [{"scri": "true if the locally stored value has been set, false if the requested value could not be stored locally.", "type": "boolean"}], "class": "android.bluetooth.BluetoothGattService\n", "type": "boolean", "name": "setValue", "throws": null, "funcname": "boolean setValue (byte[] value)", "descri": "  Updates the locally stored value of this characteristic. This function modifies the locally stored cached value of this characteristic. To send the value to the remote device, call writeCharacteristic(BluetoothGattCharacteristic) to send the value to the remote device.  ", "parameters": [{"scri": "byte: New value for this characteristic", "name": "value"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattService\n", "type": "void", "name": "setWriteType", "throws": null, "funcname": "void setWriteType (int writeType)", "descri": "  Set the write type for this characteristic Setting the write type of a characteristic determines how the writeCharacteristic(BluetoothGattCharacteristic) function write this characteristic. ", "parameters": [{"scri": "int: The write type to for this characteristic. Can be one of: WRITE_TYPE_DEFAULT, WRITE_TYPE_NO_RESPONSE or WRITE_TYPE_SIGNED.", "name": "writeType"}]}, {"returns": null, "class": "android.bluetooth.BluetoothGattService\n", "name": "BluetoothGattCharacteristic", "throws": null, "funcname": "BluetoothGattCharacteristic (UUID uuid,                 int properties,                 int permissions)", "parameters": [{"scri": "UUID: The UUID for this characteristic", "name": "uuid"}, {"scri": "int: Properties of this characteristic", "name": "properties"}, {"scri": "int: Permissions for this characteristic", "name": "permissions"}], "descri": "  Create a new BluetoothGattCharacteristic. Requires BLUETOOTH permission. "}, {"returns": null, "class": "android.bluetooth.BluetoothGattService\n", "name": "BluetoothGattCharacteristic", "throws": null, "funcname": "BluetoothGattCharacteristic (UUID uuid,                 int properties,                 int permissions)", "parameters": [{"scri": "UUID: The UUID for this characteristic", "name": "uuid"}, {"scri": "int: Properties of this characteristic", "name": "properties"}, {"scri": "int: Permissions for this characteristic", "name": "permissions"}], "descri": "  Create a new BluetoothGattCharacteristic. Requires BLUETOOTH permission. "}, {"returns": [{"scri": "true, if the service has been added successfully", "type": "boolean"}], "class": "android.bluetooth.BluetoothHeadset\n", "type": "boolean", "name": "addService", "throws": null, "funcname": "boolean addService (BluetoothGattService service)", "descri": "  Add a service to the list of services to be hosted. Once a service has been addded to the the list, the service and its included characteristics will be provided by the local device. If the local device has already exposed services when this function is called, a service update notification will be sent to all clients. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothGattService: Service to be added to the list of services provided by this device.", "name": "service"}]}, {"returns": null, "class": "android.bluetooth.BluetoothHeadset\n", "type": "void", "name": "cancelConnection", "throws": null, "funcname": "void cancelConnection (BluetoothDevice device)", "descri": "  Disconnects an established connection, or cancels a connection attempt currently in progress. Requires BLUETOOTH permission. ", "parameters": [{"scri": "BluetoothDevice: Remote device", "name": "device"}]}, {"returns": [{"scri": "true, if the connection attempt was initiated successfully", "type": "boolean"}], "class": "android.bluetooth.BluetoothHeadset\n", "type": "boolean", "name": "connect", "throws": null, "funcname": "boolean connect (BluetoothDevice device,                 boolean autoConnect)", "descri": "  Initiate a connection to a Bluetooth GATT capable device. The connection may not be established right away, but will be completed when the remote device is available. A onConnectionStateChange(BluetoothDevice, int, int) callback will be invoked when the connection state changes as a result of this function. The autoConnect paramter determines whether to actively connect to the remote device, or rather passively scan and finalize the connection when the remote device is in range/available. Generally, the first ever connection to a device should be direct (autoConnect set to false) and subsequent connections to known devices should be invoked with the autoConnect parameter set to true. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothDevice", "name": "device"}, {"scri": "boolean: Whether to directly connect to the remote device (false) or to automatically connect as soon as the remote device becomes available (true).", "name": "autoConnect"}]}, {"returns": [{"scri": "State of the profile connection. One of STATE_CONNECTED, STATE_CONNECTING, STATE_DISCONNECTED, STATE_DISCONNECTING", "type": "int"}], "class": "android.bluetooth.BluetoothHeadset\n", "type": "int", "name": "getConnectionState", "throws": [{"scri": "", "type": "UnsupportedOperationException"}], "funcname": "int getConnectionState (BluetoothDevice device)", "descri": "  Not supported - please use getConnectedDevices(int) with GATT as argument    ", "parameters": [{"scri": "BluetoothDevice: Remote bluetooth device.", "name": "device"}]}, {"returns": [{"scri": "true, if the notification has been triggered successfully", "type": "boolean"}], "class": "android.bluetooth.BluetoothHeadset\n", "type": "boolean", "name": "notifyCharacteristicChanged", "throws": [{"scri": "", "type": "IllegalArgumentException"}], "funcname": "boolean notifyCharacteristicChanged (BluetoothDevice device,                 BluetoothGattCharacteristic characteristic,                 boolean confirm)", "descri": "  Send a notification or indication that a local characteristic has been updated. A notification or indication is sent to the remote device to signal that the characteristic has been updated. This function should be invoked for every client that requests notifications/indications by writing to the \"Client Configuration\" descriptor for the given characteristic. Requires BLUETOOTH permission.    ", "parameters": [{"scri": "BluetoothDevice: The remote device to receive the notification/indication", "name": "device"}, {"scri": "BluetoothGattCharacteristic: The local characteristic that has been updated", "name": "characteristic"}, {"scri": "boolean: true to request confirmation from the client (indication), false to send a notification", "name": "confirm"}]}, {"returns": [{"scri": "true, if the notification has been triggered successfully", "type": "boolean"}], "class": "android.bluetooth.BluetoothHeadset\n", "type": "boolean", "name": "notifyCharacteristicChanged", "throws": [{"scri": "", "type": "IllegalArgumentException"}], "funcname": "boolean notifyCharacteristicChanged (BluetoothDevice device,                 BluetoothGattCharacteristic characteristic,                 boolean confirm)", "descri": "  Send a notification or indication that a local characteristic has been updated. A notification or indication is sent to the remote device to signal that the characteristic has been updated. This function should be invoked for every client that requests notifications/indications by writing to the \"Client Configuration\" descriptor for the given characteristic. Requires BLUETOOTH permission.    ", "parameters": [{"scri": "BluetoothDevice: The remote device to receive the notification/indication", "name": "device"}, {"scri": "BluetoothGattCharacteristic: The local characteristic that has been updated", "name": "characteristic"}, {"scri": "boolean: true to request confirmation from the client (indication), false to send a notification", "name": "confirm"}]}, {"returns": null, "class": "android.bluetooth.BluetoothHeadset\n", "type": "void", "name": "readPhy", "throws": null, "funcname": "void readPhy (BluetoothDevice device)", "descri": "  Read the current transmitter PHY and receiver PHY of the connection. The values are returned in onPhyRead(BluetoothDevice, int, int, int) ", "parameters": [{"scri": "BluetoothDevice: The remote device to send this response to", "name": "device"}]}, {"returns": [{"scri": "true, if the service has been removed", "type": "boolean"}], "class": "android.bluetooth.BluetoothHeadset\n", "type": "boolean", "name": "removeService", "throws": null, "funcname": "boolean removeService (BluetoothGattService service)", "descri": "  Removes a service from the list of services to be provided. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothGattService: Service to be removed.", "name": "service"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.bluetooth.BluetoothHeadset\n", "type": "boolean", "name": "sendResponse", "throws": null, "funcname": "boolean sendResponse (BluetoothDevice device,                 int requestId,                 int status,                 int offset,                 byte[] value)", "descri": "  Send a response to a read or write request to a remote device. This function must be invoked in when a remote read/write request is received by one of these callback methods: onCharacteristicReadRequest(BluetoothDevice, int, int, BluetoothGattCharacteristic) onCharacteristicWriteRequest(BluetoothDevice, int, BluetoothGattCharacteristic, boolean, boolean, int, byte[]) onDescriptorReadRequest(BluetoothDevice, int, int, BluetoothGattDescriptor) onDescriptorWriteRequest(BluetoothDevice, int, BluetoothGattDescriptor, boolean, boolean, int, byte[])  Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothDevice: The remote device to send this response to", "name": "device"}, {"scri": "int: The ID of the request that was received with the callback", "name": "requestId"}, {"scri": "int: The status of the request to be sent to the remote devices", "name": "status"}, {"scri": "int: Value offset for partial read/write response", "name": "offset"}, {"scri": "byte: The value of the attribute that was read/written (optional)", "name": "value"}]}, {"returns": null, "class": "android.bluetooth.BluetoothHeadset\n", "type": "void", "name": "setPreferredPhy", "throws": null, "funcname": "void setPreferredPhy (BluetoothDevice device,                 int txPhy,                 int rxPhy,                 int phyOptions)", "descri": "  Set the preferred connection PHY for this app. Please note that this is just a recommendation, whether the PHY change will happen depends on other applications peferences, local and remote controller capabilities. Controller can override these settings. onPhyUpdate(BluetoothDevice, int, int, int) will be triggered as a result of this call, even if no PHY change happens. It is also triggered when remote device updates the PHY. ", "parameters": [{"scri": "BluetoothDevice: The remote device to send this response to", "name": "device"}, {"scri": "int: preferred transmitter PHY. Bitwise OR of any of PHY_LE_1M_MASK, PHY_LE_2M_MASK, and PHY_LE_CODED_MASK.", "name": "txPhy"}, {"scri": "int: preferred receiver PHY. Bitwise OR of any of PHY_LE_1M_MASK, PHY_LE_2M_MASK, and PHY_LE_CODED_MASK.", "name": "rxPhy"}, {"scri": "int: preferred coding to use when transmitting on the LE Coded PHY. Can be one of PHY_OPTION_NO_PREFERRED, PHY_OPTION_S2 or PHY_OPTION_S8", "name": "phyOptions"}]}, {"returns": [{"scri": "true, if the characteristic was added to the service", "type": "boolean"}], "class": "android.bluetooth.BluetoothHealthCallback\n", "type": "boolean", "name": "addCharacteristic", "throws": null, "funcname": "boolean addCharacteristic (BluetoothGattCharacteristic characteristic)", "descri": "  Add a characteristic to this service. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothGattCharacteristic: The characteristics to be added", "name": "characteristic"}]}, {"returns": [{"scri": "true, if the included service was added to the service", "type": "boolean"}], "class": "android.bluetooth.BluetoothHealthCallback\n", "type": "boolean", "name": "addService", "throws": null, "funcname": "boolean addService (BluetoothGattService service)", "descri": "  Add an included service to this service. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothGattService: The service to be added", "name": "service"}]}, {"returns": null, "class": "android.bluetooth.BluetoothHealthCallback\n", "name": "BluetoothGattService", "throws": null, "funcname": "BluetoothGattService (UUID uuid,                 int serviceType)", "parameters": [{"scri": "UUID: The UUID for this service", "name": "uuid"}, {"scri": "int: The type of this service, SERVICE_TYPE_PRIMARY or SERVICE_TYPE_SECONDARY", "name": "serviceType"}], "descri": "  Create a new BluetoothGattService. Requires BLUETOOTH permission. "}, {"returns": null, "class": "android.bluetooth.BluetoothHealthCallback\n", "name": "BluetoothGattService", "throws": null, "funcname": "BluetoothGattService (UUID uuid,                 int serviceType)", "parameters": [{"scri": "UUID: The UUID for this service", "name": "uuid"}, {"scri": "int: The type of this service, SERVICE_TYPE_PRIMARY or SERVICE_TYPE_SECONDARY", "name": "serviceType"}], "descri": "  Create a new BluetoothGattService. Requires BLUETOOTH permission. "}, {"returns": [{"scri": "If true, the callback associated with the application config will be called.", "type": "boolean"}], "class": "android.bluetooth.BluetoothHidDeviceAppQosSettings\n", "type": "boolean", "name": "connectChannelToSource", "throws": null, "funcname": "boolean connectChannelToSource (BluetoothDevice device,                 BluetoothHealthAppConfiguration config)", "descri": "  Connect to a health device which has the SOURCE_ROLE. This is an asynchronous call. If this function returns true, the callback associated with the application configuration will be called. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothDevice: The remote Bluetooth device.", "name": "device"}, {"scri": "BluetoothHealthAppConfiguration: The application configuration which has been registered using registerSinkAppConfiguration(String, int, BluetoothHealthCallback)", "name": "config"}]}, {"returns": [{"scri": "If true, the callback associated with the application config will be called.", "type": "boolean"}], "class": "android.bluetooth.BluetoothHidDeviceAppQosSettings\n", "type": "boolean", "name": "connectChannelToSource", "throws": null, "funcname": "boolean connectChannelToSource (BluetoothDevice device,                 BluetoothHealthAppConfiguration config)", "descri": "  Connect to a health device which has the SOURCE_ROLE. This is an asynchronous call. If this function returns true, the callback associated with the application configuration will be called. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothDevice: The remote Bluetooth device.", "name": "device"}, {"scri": "BluetoothHealthAppConfiguration: The application configuration which has been registered using registerSinkAppConfiguration(String, int, BluetoothHealthCallback)", "name": "config"}]}, {"returns": [{"scri": "If true, the callback associated with the application config will be called.", "type": "boolean"}], "class": "android.bluetooth.BluetoothHidDeviceAppQosSettings\n", "type": "boolean", "name": "disconnectChannel", "throws": null, "funcname": "boolean disconnectChannel (BluetoothDevice device,                 BluetoothHealthAppConfiguration config,                 int channelId)", "descri": "  Disconnect a connected health channel. This is an asynchronous call. If this function returns true, the callback associated with the application configuration will be called. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothDevice: The remote Bluetooth device.", "name": "device"}, {"scri": "BluetoothHealthAppConfiguration: The application configuration which has been registered using registerSinkAppConfiguration(String, int, BluetoothHealthCallback)", "name": "config"}, {"scri": "int: The channel id associated with the channel", "name": "channelId"}]}, {"returns": [{"scri": "If true, the callback associated with the application config will be called.", "type": "boolean"}], "class": "android.bluetooth.BluetoothHidDeviceAppQosSettings\n", "type": "boolean", "name": "disconnectChannel", "throws": null, "funcname": "boolean disconnectChannel (BluetoothDevice device,                 BluetoothHealthAppConfiguration config,                 int channelId)", "descri": "  Disconnect a connected health channel. This is an asynchronous call. If this function returns true, the callback associated with the application configuration will be called. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothDevice: The remote Bluetooth device.", "name": "device"}, {"scri": "BluetoothHealthAppConfiguration: The application configuration which has been registered using registerSinkAppConfiguration(String, int, BluetoothHealthCallback)", "name": "config"}, {"scri": "int: The channel id associated with the channel", "name": "channelId"}]}, {"returns": [{"scri": "State of the profile connection. One of STATE_CONNECTED, STATE_CONNECTING, STATE_DISCONNECTED, STATE_DISCONNECTING", "type": "int"}], "class": "android.bluetooth.BluetoothHidDeviceAppQosSettings\n", "type": "int", "name": "getConnectionState", "throws": null, "funcname": "int getConnectionState (BluetoothDevice device)", "descri": "  Get the current connection state of the profile. Requires BLUETOOTH permission. This is not specific to any application configuration but represents the connection state of the local Bluetooth adapter with the remote device. This can be used by applications like status bar which would just like to know the state of the local adapter.  ", "parameters": [{"scri": "BluetoothDevice: Remote bluetooth device.", "name": "device"}]}, {"returns": [{"scri": "If true, callback will be called.", "type": "boolean"}], "class": "android.bluetooth.BluetoothHidDeviceAppQosSettings\n", "type": "boolean", "name": "registerSinkAppConfiguration", "throws": null, "funcname": "boolean registerSinkAppConfiguration (String name,                 int dataType,                 BluetoothHealthCallback callback)", "descri": "  Register an application configuration that acts as a Health SINK. This is the configuration that will be used to communicate with health devices which will act as the SOURCE_ROLE. This is an asynchronous call and so the callback is used to notify success or failure if the function returns true. Requires BLUETOOTH permission.  ", "parameters": [{"scri": "String: The friendly name associated with the application or configuration.", "name": "name"}, {"scri": "int: The dataType of the Source role of Health Profile to which the sink wants to connect to.", "name": "dataType"}, {"scri": "BluetoothHealthCallback: A callback to indicate success or failure of the registration and all operations done on this application configuration.", "name": "callback"}]}, {"returns": [{"scri": "Success or failure.", "type": "boolean"}], "class": "android.bluetooth.BluetoothHidDeviceAppQosSettings\n", "type": "boolean", "name": "unregisterAppConfiguration", "throws": null, "funcname": "boolean unregisterAppConfiguration (BluetoothHealthAppConfiguration config)", "descri": "  Unregister an application configuration that has been registered using registerSinkAppConfiguration(String, int, BluetoothHealthCallback) Requires BLUETOOTH permission.  ", "parameters": [{"scri": "BluetoothHealthAppConfiguration: The health app configuration", "name": "config"}]}, {"returns": null, "class": "android.bluetooth.BluetoothHidDeviceAppSdpSettings\n", "type": "void", "name": "onHealthAppConfigurationStatusChange", "throws": null, "funcname": "void onHealthAppConfigurationStatusChange (BluetoothHealthAppConfiguration config,                 int status)", "descri": "  Callback to inform change in registration state of the health application. This callback is called on the binder thread (not on the UI thread) ", "parameters": [{"scri": "BluetoothHealthAppConfiguration: Bluetooth Health app configuration", "name": "config"}, {"scri": "int: Success or failure of the registration or unregistration calls. Can be one of APP_CONFIG_REGISTRATION_SUCCESS or APP_CONFIG_REGISTRATION_FAILURE or APP_CONFIG_UNREGISTRATION_SUCCESS or APP_CONFIG_UNREGISTRATION_FAILURE", "name": "status"}]}, {"returns": null, "class": "android.bluetooth.BluetoothHidDeviceAppSdpSettings\n", "type": "void", "name": "onHealthChannelStateChange", "throws": null, "funcname": "void onHealthChannelStateChange (BluetoothHealthAppConfiguration config,                 BluetoothDevice device,                 int prevState,                 int newState,                 ParcelFileDescriptor fd,                 int channelId)", "descri": "  Callback to inform change in channel state. Its the responsibility of the implementor of this callback to close the parcel file descriptor when done. This callback is called on the Binder thread (not the UI thread) ", "parameters": [{"scri": "BluetoothHealthAppConfiguration: The Health app configutation", "name": "config"}, {"scri": "BluetoothDevice: The Bluetooth Device", "name": "device"}, {"scri": "int: The previous state of the channel", "name": "prevState"}, {"scri": "int: The new state of the channel.", "name": "newState"}, {"scri": "ParcelFileDescriptor: The Parcel File Descriptor when the channel state is connected.", "name": "fd"}, {"scri": "int: The id associated with the channel. This id will be used in future calls like when disconnecting the channel.", "name": "channelId"}]}, {"returns": null, "class": "android.bluetooth.BluetoothHidDeviceAppSdpSettings\n", "type": "void", "name": "onHealthChannelStateChange", "throws": null, "funcname": "void onHealthChannelStateChange (BluetoothHealthAppConfiguration config,                 BluetoothDevice device,                 int prevState,                 int newState,                 ParcelFileDescriptor fd,                 int channelId)", "descri": "  Callback to inform change in channel state. Its the responsibility of the implementor of this callback to close the parcel file descriptor when done. This callback is called on the Binder thread (not the UI thread) ", "parameters": [{"scri": "BluetoothHealthAppConfiguration: The Health app configutation", "name": "config"}, {"scri": "BluetoothDevice: The Bluetooth Device", "name": "device"}, {"scri": "int: The previous state of the channel", "name": "prevState"}, {"scri": "int: The new state of the channel.", "name": "newState"}, {"scri": "ParcelFileDescriptor: The Parcel File Descriptor when the channel state is connected.", "name": "fd"}, {"scri": "int: The id associated with the channel. This id will be used in future calls like when disconnecting the channel.", "name": "channelId"}]}, {"returns": null, "class": "android.bluetooth.BluetoothHidDeviceCallback\n", "name": "BluetoothHidDeviceAppQosSettings", "throws": null, "funcname": "BluetoothHidDeviceAppQosSettings (int serviceType,                 int tokenRate,                 int tokenBucketSize,                 int peakBandwidth,                 int latency,                 int delayVariation)", "parameters": [{"scri": "int: L2CAP service type, default = SERVICE_BEST_EFFORT", "name": "serviceType"}, {"scri": "int: L2CAP token rate, default = 0", "name": "tokenRate"}, {"scri": "int: L2CAP token bucket size, default = 0", "name": "tokenBucketSize"}, {"scri": "int: L2CAP peak bandwidth, default = 0", "name": "peakBandwidth"}, {"scri": "int: L2CAP latency, default = MAX", "name": "latency"}, {"scri": "int: L2CAP delay variation, default = MAX", "name": "delayVariation"}], "descri": "  Create a BluetoothHidDeviceAppQosSettings object for the Bluetooth L2CAP channel. The QoS Settings is optional. Please refer to Bluetooth HID Specfication v1.1.1 Section 5.2 and Appendix D for parameters. "}, {"returns": null, "class": "android.bluetooth.BluetoothHidDeviceCallback\n", "name": "BluetoothHidDeviceAppQosSettings", "throws": null, "funcname": "BluetoothHidDeviceAppQosSettings (int serviceType,                 int tokenRate,                 int tokenBucketSize,                 int peakBandwidth,                 int latency,                 int delayVariation)", "parameters": [{"scri": "int: L2CAP service type, default = SERVICE_BEST_EFFORT", "name": "serviceType"}, {"scri": "int: L2CAP token rate, default = 0", "name": "tokenRate"}, {"scri": "int: L2CAP token bucket size, default = 0", "name": "tokenBucketSize"}, {"scri": "int: L2CAP peak bandwidth, default = 0", "name": "peakBandwidth"}, {"scri": "int: L2CAP latency, default = MAX", "name": "latency"}, {"scri": "int: L2CAP delay variation, default = MAX", "name": "delayVariation"}], "descri": "  Create a BluetoothHidDeviceAppQosSettings object for the Bluetooth L2CAP channel. The QoS Settings is optional. Please refer to Bluetooth HID Specfication v1.1.1 Section 5.2 and Appendix D for parameters. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.BluetoothSocket\n", "name": "BluetoothHidDeviceAppSdpSettings", "throws": null, "funcname": "BluetoothHidDeviceAppSdpSettings (String name,                 String description,                 String provider,                 byte subclass,                 byte[] descriptors)", "parameters": [{"scri": "String: Name of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "name"}, {"scri": "String: Description for this Bluetooth HID device. Maximum length is 50 bytes.", "name": "description"}, {"scri": "String: Provider of this Bluetooth HID device. Maximum length is 50 bytes.", "name": "provider"}, {"scri": "byte: Subclass of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Section 4.2", "name": "subclass"}, {"scri": "byte: Descriptors of this Bluetooth HID device. See      www.usb.org/developers/hidpage/HID1_11.pdf Chapter 6 Maximum length is 2048 bytes.", "name": "descriptors"}], "descri": "  Create a BluetoothHidDeviceAppSdpSettings object for the Bluetooth SDP record. "}, {"returns": null, "class": "android.bluetooth.le.AdvertiseData\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Immediately close this socket, and release all associated resources. Causes blocked calls on this socket in other threads to immediately throw an IOException. Closing the BluetoothServerSocket will not close any BluetoothSocket received from accept().  ", "parameters": null}, {"returns": null, "class": "android.bluetooth.le.AdvertiseSettings\n", "type": "void", "name": "connect", "throws": [{"scri": "on error, for example connection failure", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Attempt to connect to a remote device. This method will block until a connection is made or the connection fails. If this method returns without an exception then this socket is now connected. Creating new connections to remote Bluetooth devices should not be attempted while device discovery is in progress. Device discovery is a heavyweight procedure on the Bluetooth adapter and will significantly slow a device connection. Use cancelDiscovery() to cancel an ongoing discovery. Discovery is not managed by the Activity, but is run as a system service, so an application should always call cancelDiscovery() even if it did not directly request a discovery, just to be sure. close() can be used to abort this call from another thread.  ", "parameters": null}, {"returns": null, "class": "android.bluetooth.le.PeriodicAdvertisingParameters.Builder\n", "type": "void", "name": "startAdvertising", "throws": null, "funcname": "void startAdvertising (AdvertiseSettings settings,                 AdvertiseData advertiseData,                 AdvertiseCallback callback)", "descri": "  Start Bluetooth LE Advertising. On success, the advertiseData will be broadcasted. Returns immediately, the operation status is delivered through callback. Requires BLUETOOTH_ADMIN permission. ", "parameters": [{"scri": "AdvertiseSettings: Settings for Bluetooth LE advertising.", "name": "settings"}, {"scri": "AdvertiseData: Advertisement data to be broadcasted.", "name": "advertiseData"}, {"scri": "AdvertiseCallback: Callback for advertising status.", "name": "callback"}]}, {"returns": null, "class": "android.bluetooth.le.PeriodicAdvertisingParameters.Builder\n", "type": "void", "name": "startAdvertising", "throws": null, "funcname": "void startAdvertising (AdvertiseSettings settings,                 AdvertiseData advertiseData,                 AdvertiseData scanResponse,                 AdvertiseCallback callback)", "descri": "  Start Bluetooth LE Advertising. The advertiseData will be broadcasted if the operation succeeds. The scanResponse is returned when a scanning device sends an active scan request. This method returns immediately, the operation status is delivered through callback. Requires BLUETOOTH_ADMIN ", "parameters": [{"scri": "AdvertiseSettings: Settings for Bluetooth LE advertising.", "name": "settings"}, {"scri": "AdvertiseData: Advertisement data to be advertised in advertisement packet.", "name": "advertiseData"}, {"scri": "AdvertiseData: Scan response associated with the advertisement data.", "name": "scanResponse"}, {"scri": "AdvertiseCallback: Callback for advertising status.", "name": "callback"}]}, {"returns": null, "class": "android.bluetooth.le.PeriodicAdvertisingParameters.Builder\n", "type": "void", "name": "stopAdvertising", "throws": null, "funcname": "void stopAdvertising (AdvertiseCallback callback)", "descri": "  Stop Bluetooth LE advertising. The callback must be the same one use in startAdvertising(AdvertiseSettings, AdvertiseData, AdvertiseCallback). Requires BLUETOOTH_ADMIN permission. ", "parameters": [{"scri": "AdvertiseCallback: AdvertiseCallback identifies the advertising instance to stop.", "name": "callback"}]}, {"returns": null, "class": "android.bluetooth.le.ScanCallback\n", "type": "void", "name": "flushPendingScanResults", "throws": null, "funcname": "void flushPendingScanResults (ScanCallback callback)", "descri": "  Flush pending batch scan results stored in Bluetooth controller. This will return Bluetooth LE scan results batched on bluetooth controller. Returns immediately, batch scan results data will be delivered through the callback. ", "parameters": [{"scri": "ScanCallback: Callback of the Bluetooth LE Scan, it has to be the same instance as the one used to start scan.", "name": "callback"}]}, {"returns": [{"scri": "Returns 0 for success or an error code from ScanCallback if the scan request could not be sent.", "type": "int"}], "class": "android.bluetooth.le.ScanCallback\n", "type": "int", "name": "startScan", "throws": null, "funcname": "int startScan (List<ScanFilter> filters,                 ScanSettings settings,                 PendingIntent callbackIntent)", "descri": "  Start Bluetooth LE scan using a PendingIntent. The scan results will be delivered via the PendingIntent. Use this method of scanning if your process is not always running and it should be started when scan results are available. An app must hold ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permission in order to get results. When the PendingIntent is delivered, the Intent passed to the receiver or activity will contain one or more of the extras EXTRA_CALLBACK_TYPE, EXTRA_ERROR_CODE and EXTRA_LIST_SCAN_RESULT to indicate the result of the scan. Requires the BLUETOOTH_ADMIN permission.    See also: stopScan(PendingIntent)", "parameters": [{"scri": "List: Optional list of ScanFilters for finding exact BLE devices.This value may be null.", "name": "filters"}, {"scri": "ScanSettings: Optional settings for the scan.This value may be null.", "name": "settings"}, {"scri": "PendingIntent: The PendingIntent to deliver the result to.This value must never be null.", "name": "callbackIntent"}]}, {"returns": null, "class": "android.bluetooth.le.ScanCallback\n", "type": "int", "name": "startScan", "throws": [{"scri": "If callback is null.", "type": "IllegalArgumentException"}], "funcname": "void startScan (ScanCallback callback)", "descri": "  Start Bluetooth LE scan with default parameters and no filters. The scan results will be delivered through callback. For unfiltered scans, scanning is stopped on screen off to save power. Scanning is resumed when screen is turned on again. To avoid this, use startScan(List, ScanSettings, ScanCallback) with desired ScanFilter. An app must hold ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permission in order to get results. Requires the BLUETOOTH_ADMIN permission.   ", "parameters": [{"scri": "ScanCallback: Callback used to deliver scan results.", "name": "callback"}]}, {"returns": null, "class": "android.bluetooth.le.ScanCallback\n", "type": "int", "name": "startScan", "throws": [{"scri": "If settings or callback is null.", "type": "IllegalArgumentException"}], "funcname": "void startScan (List<ScanFilter> filters,                 ScanSettings settings,                 ScanCallback callback)", "descri": "  Start Bluetooth LE scan. The scan results will be delivered through callback. For unfiltered scans, scanning is stopped on screen off to save power. Scanning is resumed when screen is turned on again. To avoid this, do filetered scanning by using proper ScanFilter. An app must hold ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permission in order to get results. Requires the BLUETOOTH_ADMIN permission.   ", "parameters": [{"scri": "List: ScanFilters for finding exact BLE devices.", "name": "filters"}, {"scri": "ScanSettings: Settings for the scan.", "name": "settings"}, {"scri": "ScanCallback: Callback used to deliver scan results.", "name": "callback"}]}, {"returns": null, "class": "android.bluetooth.le.ScanCallback\n", "type": "void", "name": "stopScan", "throws": null, "funcname": "void stopScan (ScanCallback callback)", "descri": "  Stops an ongoing Bluetooth LE scan. Requires the BLUETOOTH_ADMIN permission.", "parameters": null}, {"returns": null, "class": "android.bluetooth.le.ScanCallback\n", "type": "void", "name": "stopScan", "throws": null, "funcname": "void stopScan (PendingIntent callbackIntent)", "descri": "  Stops an ongoing Bluetooth LE scan started using a PendingIntent. Requires the BLUETOOTH_ADMIN permission.   See also: startScan(List, ScanSettings, PendingIntent)", "parameters": [{"scri": "PendingIntent: The PendingIntent that was used to start the scan.", "name": "callbackIntent"}]}, {"returns": null, "class": "android.bluetooth.le.ScanResult\n", "type": "void", "name": "onScanResult", "throws": null, "funcname": "void onScanResult (int callbackType,                 ScanResult result)", "descri": "  Callback when a BLE advertisement has been found. ", "parameters": [{"scri": "int: Determines how this callback was triggered. Could be one of CALLBACK_TYPE_ALL_MATCHES, CALLBACK_TYPE_FIRST_MATCH or CALLBACK_TYPE_MATCH_LOST", "name": "callbackType"}, {"scri": "ScanResult: A Bluetooth LE scan result.", "name": "result"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.companion.AssociationRequest\n", "type": "boolean", "name": "isLegacy", "throws": null, "funcname": "boolean isLegacy ()", "descri": "  Returns true if this object represents legacy scan result. Legacy scan results do not contain advanced advertising information as specified in the Bluetooth Core Specification v5. ", "parameters": null}, {"returns": null, "class": "android.companion.AssociationRequest\n", "name": "ScanResult", "throws": null, "funcname": "ScanResult (BluetoothDevice device,                 ScanRecord scanRecord,                 int rssi,                 long timestampNanos)", "parameters": [{"scri": "BluetoothDevice: Remote Bluetooth device found.", "name": "device"}, {"scri": "ScanRecord: Scan record including both advertising data and scan response data.", "name": "scanRecord"}, {"scri": "int: Received signal strength.", "name": "rssi"}, {"scri": "long: Timestamp at which the scan result was observed.", "name": "timestampNanos"}], "descri": "   This constructor was deprecated      in API level 26.    use ScanResult(BluetoothDevice, int, int, int, int, int, int, int, ScanRecord, long)  Constructs a new ScanResult. "}, {"returns": null, "class": "android.companion.AssociationRequest\n", "name": "ScanResult", "throws": null, "funcname": "ScanResult (BluetoothDevice device,                 int eventType,                 int primaryPhy,                 int secondaryPhy,                 int advertisingSid,                 int txPower,                 int rssi,                 int periodicAdvertisingInterval,                 ScanRecord scanRecord,                 long timestampNanos)", "parameters": [{"scri": "BluetoothDevice: Remote Bluetooth device found.", "name": "device"}, {"scri": "int: Event type.", "name": "eventType"}, {"scri": "int: Primary advertising phy.", "name": "primaryPhy"}, {"scri": "int: Secondary advertising phy.", "name": "secondaryPhy"}, {"scri": "int: Advertising set ID.", "name": "advertisingSid"}, {"scri": "int: Transmit power.", "name": "txPower"}, {"scri": "int: Received signal strength.", "name": "rssi"}, {"scri": "int: Periodic advertising interval.", "name": "periodicAdvertisingInterval"}, {"scri": "ScanRecord: Scan record including both advertising data and scan response data.", "name": "scanRecord"}, {"scri": "long: Timestamp at which the scan result was observed.", "name": "timestampNanos"}], "descri": "  Constructs a new ScanResult. "}, {"returns": null, "class": "android.companion.AssociationRequest\n", "name": "ScanResult", "throws": null, "funcname": "ScanResult (BluetoothDevice device,                 ScanRecord scanRecord,                 int rssi,                 long timestampNanos)", "parameters": [{"scri": "BluetoothDevice: Remote Bluetooth device found.", "name": "device"}, {"scri": "ScanRecord: Scan record including both advertising data and scan response data.", "name": "scanRecord"}, {"scri": "int: Received signal strength.", "name": "rssi"}, {"scri": "long: Timestamp at which the scan result was observed.", "name": "timestampNanos"}], "descri": "   This constructor was deprecated      in API level 26.    use ScanResult(BluetoothDevice, int, int, int, int, int, int, int, ScanRecord, long)  Constructs a new ScanResult. "}, {"returns": null, "class": "android.companion.AssociationRequest\n", "name": "ScanResult", "throws": null, "funcname": "ScanResult (BluetoothDevice device,                 int eventType,                 int primaryPhy,                 int secondaryPhy,                 int advertisingSid,                 int txPower,                 int rssi,                 int periodicAdvertisingInterval,                 ScanRecord scanRecord,                 long timestampNanos)", "parameters": [{"scri": "BluetoothDevice: Remote Bluetooth device found.", "name": "device"}, {"scri": "int: Event type.", "name": "eventType"}, {"scri": "int: Primary advertising phy.", "name": "primaryPhy"}, {"scri": "int: Secondary advertising phy.", "name": "secondaryPhy"}, {"scri": "int: Advertising set ID.", "name": "advertisingSid"}, {"scri": "int: Transmit power.", "name": "txPower"}, {"scri": "int: Received signal strength.", "name": "rssi"}, {"scri": "int: Periodic advertising interval.", "name": "periodicAdvertisingInterval"}, {"scri": "ScanRecord: Scan record including both advertising data and scan response data.", "name": "scanRecord"}, {"scri": "long: Timestamp at which the scan result was observed.", "name": "timestampNanos"}], "descri": "  Constructs a new ScanResult. "}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.companion.AssociationRequest.Builder\n", "type": "boolean", "name": "getLegacy", "throws": null, "funcname": "boolean getLegacy ()", "descri": "  Returns whether only legacy advertisements will be returned. Legacy advertisements include advertisements as specified by the Bluetooth core specification 4.2 and below. ", "parameters": null}, {"returns": null, "class": "android.companion.WifiDeviceFilter\n", "type": "void", "name": "associate", "throws": null, "funcname": "void associate (AssociationRequest request,                 CompanionDeviceManager.Callback callback,                 Handler handler)", "descri": "  Associate this app with a companion device, selected by user Once at least one appropriate device is found, callback will be called with a PendingIntent that can be used to show the list of available devices for the user to select. It should be started for result (i.e. using startIntentSenderForResult(IntentSender, int, Intent, int, int, int)), as the resulting Intent will contain extra EXTRA_DEVICE, with the selected device. (e.g. BluetoothDevice)  If your app needs to be excluded from battery optimizations (run in the background) or to have unrestricted data access (use data in the background) you can declare that you use the REQUEST_COMPANION_RUN_IN_BACKGROUND and REQUEST_COMPANION_USE_DATA_IN_BACKGROUND respectively. Note that these special capabilities have a negative effect on the device's battery and user's data usage, therefore you should requested them when absolutely necessary.  You can call getAssociations() to get the list of currently associated devices, and disassociate(String) to remove an association. Consider doing so when the association is no longer relevant to avoid unnecessary battery and/or data drain resulting from special privileges that the association provides  Calling this API requires a uses-feature FEATURE_COMPANION_DEVICE_SETUP declaration in the manifest   See also: AssociationRequest", "parameters": [{"scri": "AssociationRequest: specific details about this requestThis value must never be null.", "name": "request"}, {"scri": "CompanionDeviceManager.Callback: will be called once there's at least one device found for user to choose fromThis value must never be null.", "name": "callback"}, {"scri": "Handler: A handler to control which thread the callback will be delivered on, or null,                to deliver it on main thread", "name": "handler"}]}, {"returns": null, "class": "android.content.AsyncQueryHandler\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "apply", "throws": null, "funcname": "void apply ()", "descri": "  Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.  This atomically performs the requested modifications, replacing whatever is currently in the SharedPreferences. Note that when two editors are modifying preferences at the same time, the last one to call apply wins. Unlike commit(), which writes its preferences out to persistent storage synchronously, apply() commits its changes to the in-memory SharedPreferences immediately but starts an asynchronous commit to disk and you won't be notified of any failures.  If another editor on this SharedPreferences does a regular commit() while a apply() is still outstanding, the commit() will block until all async commits are completed as well as the commit itself. As SharedPreferences instances are singletons within a process, it's safe to replace any instance of commit() with apply() if you were already ignoring the return value. You don't need to worry about Android component lifecycles and their interaction with apply() writing to disk.  The framework makes sure in-flight disk writes from apply() complete before switching states. The SharedPreferences.Editor interface isn't expected to be implemented directly.  However, if you previously did implement it and are now getting errors about missing apply(), you can simply call commit() from apply().", "parameters": null}, {"returns": [{"scri": "Returns true if the new values were successfully written to persistent storage.", "type": "boolean"}], "class": "android.content.AsyncQueryHandler\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "commit", "throws": null, "funcname": "boolean commit ()", "descri": "  Commit your preferences changes back from this Editor to the SharedPreferences object it is editing.  This atomically performs the requested modifications, replacing whatever is currently in the SharedPreferences. Note that when two editors are modifying preferences at the same time, the last one to call commit wins. If you don't care about the return value and you're using this from your application's main thread, consider using apply() instead. ", "parameters": null}, {"returns": null, "class": "android.content.ContentProviderOperation.Builder\n", "type": "ComponentName", "name": "ComponentName", "throws": null, "funcname": "ComponentName (Parcel in)", "descri": "  Instantiate a new ComponentName from the data in a Parcel that was previously written with writeToParcel(Parcel, int).  Note that you must not use this with data written by writeToParcel(ComponentName, Parcel) since it is not possible to handle a null ComponentObject here. ", "parameters": [{"scri": "Parcel: The Parcel containing the previously written ComponentName, positioned at the location in the buffer where it was written.", "name": "in"}]}, {"returns": null, "class": "android.content.ContentProviderOperation.Builder\n", "name": "ComponentName", "throws": null, "funcname": "ComponentName (Parcel in)", "parameters": [{"scri": "Parcel: The Parcel containing the previously written ComponentName, positioned at the location in the buffer where it was written.", "name": "in"}], "descri": "  Instantiate a new ComponentName from the data in a Parcel that was previously written with writeToParcel(Parcel, int).  Note that you must not use this with data written by writeToParcel(ComponentName, Parcel) since it is not possible to handle a null ComponentObject here. "}, {"returns": null, "class": "android.content.ContentProviderOperation.Builder\n", "name": "ComponentName", "throws": null, "funcname": "ComponentName (Parcel in)", "parameters": [{"scri": "Parcel: The Parcel containing the previously written ComponentName, positioned at the location in the buffer where it was written.", "name": "in"}], "descri": "  Instantiate a new ComponentName from the data in a Parcel that was previously written with writeToParcel(Parcel, int).  Note that you must not use this with data written by writeToParcel(ComponentName, Parcel) since it is not possible to handle a null ComponentObject here. "}, {"returns": [{"scri": "The number of rows affected.", "type": "int"}], "class": "android.content.ContentProviderResult\n", "type": "abstract\n        \n        \n        \n        \n        int", "name": "delete", "throws": [{"scri": "", "type": "SQLException"}], "funcname": "int delete (Uri uri,                 String selection,                 String[] selectionArgs)", "descri": "  Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call notifyChange() after deleting. This method can be called from multiple threads, as described in Processes and Threads. The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in content://contacts/people/22 and the implementation is responsible for parsing the record number (22) when creating a SQL statement.    ", "parameters": [{"scri": "Uri: The full URI to query, including a row ID (if a specific record is requested).This value must never be null.", "name": "uri"}, {"scri": "String: An optional restriction to apply to rows when deleting.This value may be null.", "name": "selection"}, {"scri": "String This value may be null.", "name": "selectionArgs"}]}, {"returns": [{"scri": "the number of newly created rows.", "type": "int"}], "class": "android.content.ContentValues\n", "type": "final\n        \n        int", "name": "bulkInsert", "throws": null, "funcname": "int bulkInsert (Uri url,                 ContentValues[] values)", "descri": "  Inserts multiple rows into a table at the given URL. This function make no guarantees about the atomicity of the insertions.  ", "parameters": [{"scri": "Uri: The URL of the table to insert into.This value must never be null.", "name": "url"}, {"scri": "ContentValues: The initial values for the newly inserted rows. The key is the column name for               the field. Passing null will create an empty row.", "name": "values"}]}, {"returns": [{"scri": "The number of rows deleted.", "type": "int"}], "class": "android.content.ContentValues\n", "type": "final\n        \n        int", "name": "delete", "throws": null, "funcname": "int delete (Uri url,                 String where,                 String[] selectionArgs)", "descri": "  Deletes row(s) specified by a content URI. If the content provider supports transactions, the deletion will be atomic.  ", "parameters": [{"scri": "Uri: The URL of the row to delete.This value must never be null.", "name": "url"}, {"scri": "String: A filter to apply to rows before deleting, formatted as an SQL WHERE clause                    (excluding the WHERE itself).This value may be null.", "name": "where"}, {"scri": "String This value may be null.", "name": "selectionArgs"}]}, {"returns": [{"scri": "the number of rows updated.", "type": "int"}], "class": "android.content.ContentValues\n", "type": "final\n        \n        int", "name": "update", "throws": [{"scri": "if uri or values are null", "type": "NullPointerException"}], "funcname": "int update (Uri uri,                 ContentValues values,                 String where,                 String[] selectionArgs)", "descri": "  Update row(s) in a content URI. If the content provider supports transactions the update will be atomic.    ", "parameters": [{"scri": "Uri: The URI to modify.This value must never be null.", "name": "uri"}, {"scri": "ContentValues: The new field values. The key is the column name for the field.                     A null value will remove an existing field value.", "name": "values"}, {"scri": "String: A filter to apply to rows before updating, formatted as an SQL WHERE clause                    (excluding the WHERE itself).This value may be null.", "name": "where"}, {"scri": "String This value may be null.", "name": "selectionArgs"}]}, {"returns": null, "class": "android.content.pm.PackageInfo\n", "type": "void", "name": "onShortcutsChanged", "throws": null, "funcname": "void onShortcutsChanged (String packageName,                 List<ShortcutInfo> shortcuts,                 UserHandle user)", "descri": "  Indicates that one or more shortcuts of any kind (dynamic, pinned, or manifest) have been added, updated or removed. Only the applications that are allowed to access the shortcut information, as defined in hasShortcutHostPermission(), will receive it.   See also: ShortcutManager", "parameters": [{"scri": "String: The name of the package that has the shortcuts.This value must never be null.", "name": "packageName"}, {"scri": "List: All shortcuts from the package (dynamic, manifest and/or pinned).    Only \"key\" information will be provided, as defined in    hasKeyFieldsOnly().This value must never be null.", "name": "shortcuts"}, {"scri": "UserHandle: The UserHandle of the profile that generated the change.This value must never be null.", "name": "user"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.content.pm.PackageItemInfo.DisplayNameComparator\n", "type": "int", "name": "getInstallLocation", "throws": null, "funcname": "int getInstallLocation ()", "descri": "  Get the value set in setInstallLocation(int). ", "parameters": null}, {"returns": [{"scri": "true if the call has succeeded. false if the call is rate-limited.", "type": "boolean"}], "class": "android.content.pm.PackageManager.NameNotFoundException\n", "type": "boolean", "name": "addDynamicShortcuts", "throws": [{"scri": "if getMaxShortcutCountPerActivity() is exceeded, or when trying to update immutable shortcuts.", "type": "IllegalArgumentException"}, {"scri": "when the user is locked.", "type": "IllegalStateException"}], "funcname": "boolean addDynamicShortcuts (List<ShortcutInfo> shortcutInfoList)", "descri": "  Publish the list of dynamic shortcuts.  If there are already dynamic or pinned shortcuts with the same IDs, each mutable shortcut is updated. This API will be rate-limited.    ", "parameters": [{"scri": "List This value must never be null.", "name": "shortcutInfoList"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.content.pm.PackageManager.NameNotFoundException\n", "type": "int", "name": "getMaxShortcutCountPerActivity", "throws": null, "funcname": "int getMaxShortcutCountPerActivity ()", "descri": "  Return the maximum number of static and dynamic shortcuts that each launcher icon can have at a time. ", "parameters": null}, {"returns": null, "class": "android.content.pm.PackageManager.NameNotFoundException\n", "type": "void", "name": "removeAllDynamicShortcuts", "throws": [{"scri": "when the user is locked.", "type": "IllegalStateException"}], "funcname": "void removeAllDynamicShortcuts ()", "descri": "  Delete all dynamic shortcuts from the caller app.  ", "parameters": null}, {"returns": null, "class": "android.content.pm.PackageManager.NameNotFoundException\n", "type": "void", "name": "removeDynamicShortcuts", "throws": [{"scri": "when the user is locked.", "type": "IllegalStateException"}], "funcname": "void removeDynamicShortcuts (List<String> shortcutIds)", "descri": "  Delete dynamic shortcuts by ID.   ", "parameters": [{"scri": "List This value must never be null.", "name": "shortcutIds"}]}, {"returns": [{"scri": "TRUE if the launcher supports this feature.  Note the API will return without    waiting for the user to respond, so getting TRUE from this API does *not* mean    the shortcut was pinned successfully.  FALSE if the launcher doesn't support this    feature.", "type": "boolean"}], "class": "android.content.pm.PackageManager.NameNotFoundException\n", "type": "boolean", "name": "requestPinShortcut", "throws": [{"scri": "if a shortcut with the same ID exists and is disabled.", "type": "IllegalArgumentException"}, {"scri": "The caller doesn't have a foreground activity or a foreground service, or the device is locked.", "type": "IllegalStateException"}], "funcname": "boolean requestPinShortcut (ShortcutInfo shortcut,                 IntentSender resultIntent)", "descri": "  Request to create a pinned shortcut.  The default launcher will receive this request and ask the user for approval.  If the user approves it, the shortcut will be created, and resultIntent will be sent. If a request is denied by the user, however, no response will be sent to the caller. Only apps with a foreground activity or a foreground service can call this method. Otherwise, it'll throw IllegalStateException. It's up to the launcher to decide how to handle previous pending requests when the same package calls this API multiple times in a row. One possible strategy is to ignore any previous requests. Note: See also the support library counterpart requestPinShortcut(Context, ShortcutInfoCompat, IntentSender), which supports Android versions lower than O using the legacy private intent com.android.launcher.action.INSTALL_SHORTCUT.     See also: isRequestPinShortcutSupported()IntentSendergetIntentSender()", "parameters": [{"scri": "ShortcutInfo: Shortcut to pin.  If an app wants to pin an existing (either static     or dynamic) shortcut, then it only needs to have an ID. Although other fields don't have     to be set, the target shortcut must be enabled.     If it's a new shortcut, all the mandatory fields, such as a short label, must be     set.This value must never be null.", "name": "shortcut"}, {"scri": "IntentSender: If not null, this intent will be sent when the shortcut is pinned.    Use getIntentSender() to create an IntentSender.    To avoid background execution limits, use an unexported, manifest-declared receiver.    For more details, see the overview documentation for the ShortcutManager class.", "name": "resultIntent"}]}, {"returns": [{"scri": "true if the call has succeeded. false if the call is rate-limited.", "type": "boolean"}], "class": "android.content.pm.PackageManager.NameNotFoundException\n", "type": "boolean", "name": "setDynamicShortcuts", "throws": [{"scri": "if getMaxShortcutCountPerActivity() is exceeded, or when trying to update immutable shortcuts.", "type": "IllegalArgumentException"}, {"scri": "when the user is locked.", "type": "IllegalStateException"}], "funcname": "boolean setDynamicShortcuts (List<ShortcutInfo> shortcutInfoList)", "descri": "  Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app will be replaced.  If there are already pinned shortcuts with the same IDs, the mutable pinned shortcuts are updated. This API will be rate-limited.    ", "parameters": [{"scri": "List This value must never be null.", "name": "shortcutInfoList"}]}, {"returns": [{"scri": "true if the call has succeeded. false if the call is rate-limited.", "type": "boolean"}], "class": "android.content.pm.PackageManager.NameNotFoundException\n", "type": "boolean", "name": "updateShortcuts", "throws": [{"scri": "If trying to update immutable shortcuts.", "type": "IllegalArgumentException"}, {"scri": "when the user is locked.", "type": "IllegalStateException"}], "funcname": "boolean updateShortcuts (List<ShortcutInfo> shortcutInfoList)", "descri": "  Update all existing shortcuts with the same IDs.  Target shortcuts may be pinned and/or dynamic, but they must not be immutable. This API will be rate-limited.    ", "parameters": [{"scri": "List This value must never be null.", "name": "shortcutInfoList"}]}, {"returns": null, "class": "android.content.pm.PackageStats\n", "type": "void", "name": "setInstallLocation", "throws": null, "funcname": "void setInstallLocation (int installLocation)", "descri": "  Provide value of installLocation, which may be used to determine where the app will be staged. Defaults to INSTALL_LOCATION_INTERNAL_ONLY. ", "parameters": [{"scri": "int", "name": "installLocation"}]}, {"returns": [{"scri": "Returns true if a new permission was created, false if an existing one was updated.", "type": "boolean"}], "class": "android.content.pm.PermissionInfo\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "addPermission", "throws": [{"scri": "if you are not allowed to add the given permission name.", "type": "SecurityException"}], "funcname": "boolean addPermission (PermissionInfo info)", "descri": "  Add a new dynamic permission to the system.  For this to work, your package must have defined a permission tree through the <permission-tree> tag in its manifest.  A package can only add permissions to trees that were defined by either its own package or another with the same user id; a permission is in a tree if it matches the name of the permission tree + \".\": for example, \"com.foo.bar\" is a member of the permission tree \"com.foo\". It is good to make your permission tree name descriptive, because you are taking possession of that entire set of permission names.  Thus, it must be under a domain you control, with a suffix that will not match any normal permissions that may be declared in any applications that are part of that domain. New permissions must be added before any .apks are installed that use those permissions.  Permissions you add through this method are remembered across reboots of the device. If the given permission already exists, the info you supply here will be used to update it.     See also: removePermission(String)", "parameters": [{"scri": "PermissionInfo: Description of the permission to be added.", "name": "info"}]}, {"returns": [{"scri": "Returns an int array of the assigned GIDs, or null if there are         none.", "type": "int[]"}], "class": "android.content.pm.PermissionInfo\n", "type": "abstract\n        \n        \n        \n        \n        int[]", "name": "getPackageGids", "throws": [{"scri": "if a package with the given name cannot be             found on the system.", "type": "PackageManager.NameNotFoundException"}], "funcname": "int[] getPackageGids (String packageName)", "descri": "  Return an array of all of the POSIX secondary group IDs that have been assigned to the given package. Note that the same package may have different GIDs under different UserHandle on the same device.    ", "parameters": [{"scri": "String: The full name (i.e. com.google.apps.contacts) of the            desired package.This value must never be null.", "name": "packageName"}]}, {"returns": [{"scri": "Returns an int array of the assigned gids, or null if there are         none.", "type": "int[]"}], "class": "android.content.pm.PermissionInfo\n", "type": "abstract\n        \n        \n        \n        \n        int[]", "name": "getPackageGids", "throws": [{"scri": "if a package with the given name cannot be             found on the system.", "type": "PackageManager.NameNotFoundException"}], "funcname": "int[] getPackageGids (String packageName,                 int flags)", "descri": "  Return an array of all of the POSIX secondary group IDs that have been assigned to the given package. Note that the same package may have different GIDs under different UserHandle on the same device.    ", "parameters": [{"scri": "String: The full name (i.e. com.google.apps.contacts) of the            desired package.", "name": "packageName"}, {"scri": "int Value is either 0 or combination of GET_ACTIVITIES, GET_CONFIGURATIONS, GET_GIDS, GET_INSTRUMENTATION, GET_INTENT_FILTERS, GET_META_DATA, GET_PERMISSIONS, GET_PROVIDERS, GET_RECEIVERS, GET_SERVICES, GET_SHARED_LIBRARY_FILES, GET_SIGNATURES, GET_SIGNING_CERTIFICATES, GET_URI_PERMISSION_PATTERNS, MATCH_UNINSTALLED_PACKAGES, MATCH_DISABLED_COMPONENTS, MATCH_DISABLED_UNTIL_USED_COMPONENTS or MATCH_SYSTEM_ONLY.", "name": "flags"}]}, {"returns": [{"scri": "Returns an integer UID who owns the given package name.", "type": "int"}], "class": "android.content.pm.PermissionInfo\n", "type": "abstract\n        \n        \n        \n        \n        int", "name": "getPackageUid", "throws": [{"scri": "if a package with the given name can not be             found on the system.", "type": "PackageManager.NameNotFoundException"}], "funcname": "int getPackageUid (String packageName,                 int flags)", "descri": "  Return the UID associated with the given package name. Note that the same package will have different UIDs under different UserHandle on the same device.    ", "parameters": [{"scri": "String: The full name (i.e. com.google.apps.contacts) of the            desired package.", "name": "packageName"}, {"scri": "int Value is either 0 or combination of GET_ACTIVITIES, GET_CONFIGURATIONS, GET_GIDS, GET_INSTRUMENTATION, GET_INTENT_FILTERS, GET_META_DATA, GET_PERMISSIONS, GET_PROVIDERS, GET_RECEIVERS, GET_SERVICES, GET_SHARED_LIBRARY_FILES, GET_SIGNATURES, GET_SIGNING_CERTIFICATES, GET_URI_PERMISSION_PATTERNS, MATCH_UNINSTALLED_PACKAGES, MATCH_DISABLED_COMPONENTS, MATCH_DISABLED_UNTIL_USED_COMPONENTS or MATCH_SYSTEM_ONLY.", "name": "flags"}]}, {"returns": [{"scri": "true if this package was or is signed by exactly the certificate certificate", "type": "boolean"}], "class": "android.content.pm.PermissionInfo\n", "type": "boolean", "name": "hasSigningCertificate", "throws": null, "funcname": "boolean hasSigningCertificate (int uid,                 byte[] certificate,                 int type)", "descri": "  Searches the set of signing certificates by which the package(s) for the given uid has proven to have been signed.  For multiple packages sharing the same uid, this will return the signing certificates found in the signing history of the \"newest\" package, where \"newest\" indicates the package with the newest signing certificate in the shared uid group.  This method should be used instead of getPackageInfo with GET_SIGNATURES since it takes into account the possibility of signing certificate rotation, except in the case of packages that are signed by multiple certificates, for which signing certificate rotation is not supported. This method is analogous to using getPackagesForUid followed by getPackageInfo with GET_SIGNING_CERTIFICATES, selecting the PackageInfo of the newest-signed bpackage , and finally searching through the resulting signingCertificateHistory field to see if the desired certificate is there.  ", "parameters": [{"scri": "int: uid whose signing certificates to check", "name": "uid"}, {"scri": "byte: signing certificate for which to search", "name": "certificate"}, {"scri": "int: representation of the certificateValue is CERT_INPUT_RAW_X509 or CERT_INPUT_SHA256.", "name": "type"}]}, {"returns": [{"scri": "The version.Value is -1 or greater.", "type": "long"}], "class": "android.content.pm.ShortcutManager\n", "type": "long", "name": "getLongVersion", "throws": null, "funcname": "long getLongVersion ()", "descri": "  Gets the version of the library. For static libraries this is the declared version and for dynamic and builtin it is VERSION_UNDEFINED as these are not versioned. ", "parameters": null}, {"returns": [{"scri": "The library type.Value is either 0 or combination of TYPE_BUILTIN, TYPE_DYNAMIC or TYPE_STATIC.", "type": "int"}], "class": "android.content.pm.ShortcutManager\n", "type": "int", "name": "getType", "throws": null, "funcname": "int getType ()", "descri": "  Gets the type of this library. ", "parameters": null}, {"returns": null, "class": "android.content.res.AssetManager\n", "name": "AssetFileDescriptor", "throws": null, "funcname": "AssetFileDescriptor (ParcelFileDescriptor fd,                 long startOffset,                 long length)", "parameters": [{"scri": "ParcelFileDescriptor: The underlying file descriptor.", "name": "fd"}, {"scri": "long: The location within the file that the asset starts.            This must be 0 if length is UNKNOWN_LENGTH.", "name": "startOffset"}, {"scri": "long: The number of bytes of the asset, or            UNKNOWN_LENGTH if it extends to the end of the file.", "name": "length"}], "descri": "  Create a new AssetFileDescriptor from the given values. "}, {"returns": null, "class": "android.content.res.AssetManager\n", "name": "AssetFileDescriptor", "throws": null, "funcname": "AssetFileDescriptor (ParcelFileDescriptor fd,                 long startOffset,                 long length,                 Bundle extras)", "parameters": [{"scri": "ParcelFileDescriptor: The underlying file descriptor.", "name": "fd"}, {"scri": "long: The location within the file that the asset starts.            This must be 0 if length is UNKNOWN_LENGTH.", "name": "startOffset"}, {"scri": "long: The number of bytes of the asset, or            UNKNOWN_LENGTH if it extends to the end of the file.", "name": "length"}, {"scri": "Bundle: additional details that can be used to interpret the            underlying file descriptor. May be null.", "name": "extras"}], "descri": "  Create a new AssetFileDescriptor from the given values. "}, {"returns": null, "class": "android.content.res.AssetManager\n", "name": "AssetFileDescriptor", "throws": null, "funcname": "AssetFileDescriptor (ParcelFileDescriptor fd,                 long startOffset,                 long length)", "parameters": [{"scri": "ParcelFileDescriptor: The underlying file descriptor.", "name": "fd"}, {"scri": "long: The location within the file that the asset starts.            This must be 0 if length is UNKNOWN_LENGTH.", "name": "startOffset"}, {"scri": "long: The number of bytes of the asset, or            UNKNOWN_LENGTH if it extends to the end of the file.", "name": "length"}], "descri": "  Create a new AssetFileDescriptor from the given values. "}, {"returns": null, "class": "android.content.res.AssetManager\n", "name": "AssetFileDescriptor", "throws": null, "funcname": "AssetFileDescriptor (ParcelFileDescriptor fd,                 long startOffset,                 long length,                 Bundle extras)", "parameters": [{"scri": "ParcelFileDescriptor: The underlying file descriptor.", "name": "fd"}, {"scri": "long: The location within the file that the asset starts.            This must be 0 if length is UNKNOWN_LENGTH.", "name": "startOffset"}, {"scri": "long: The number of bytes of the asset, or            UNKNOWN_LENGTH if it extends to the end of the file.", "name": "length"}, {"scri": "Bundle: additional details that can be used to interpret the            underlying file descriptor. May be null.", "name": "extras"}], "descri": "  Create a new AssetFileDescriptor from the given values. "}, {"returns": [{"scri": "true if the screen has a high dynamic range, false otherwise", "type": "boolean"}], "class": "android.content.res.Resources.Theme\n", "type": "boolean", "name": "isScreenHdr", "throws": null, "funcname": "boolean isScreenHdr ()", "descri": "  Return whether the screen has a high dynamic range. ", "parameters": null}, {"returns": null, "class": "android.database.DatabaseUtils.InsertHelper\n", "type": "static\n        \n        \n        CursorWindow", "name": "CursorWindow", "throws": null, "funcname": "CursorWindow (String name,                 long windowSizeBytes)", "descri": "  Creates a new empty cursor window and gives it a name. The cursor initially has no rows or columns.  Call setNumColumns(int) to set the number of columns before adding any rows to the cursor. ", "parameters": [{"scri": "String: The name of the cursor window, or null if none.", "name": "name"}, {"scri": "long: Size of cursor window in bytes. Note: Memory is dynamically allocated as data rows are added to the window. Depending on the amount of data stored, the actual amount of memory allocated can be lower than specified size, but cannot exceed it.Value is a non-negative number of bytes.", "name": "windowSizeBytes"}]}, {"returns": null, "class": "android.database.DatabaseUtils.InsertHelper\n", "name": "CursorWindow", "throws": null, "funcname": "CursorWindow (String name,                 long windowSizeBytes)", "parameters": [{"scri": "String: The name of the cursor window, or null if none.", "name": "name"}, {"scri": "long: Size of cursor window in bytes. Note: Memory is dynamically allocated as data rows are added to the window. Depending on the amount of data stored, the actual amount of memory allocated can be lower than specified size, but cannot exceed it.Value is a non-negative number of bytes.", "name": "windowSizeBytes"}], "descri": "  Creates a new empty cursor window and gives it a name. The cursor initially has no rows or columns.  Call setNumColumns(int) to set the number of columns before adding any rows to the cursor. "}, {"returns": null, "class": "android.database.DatabaseUtils.InsertHelper\n", "name": "CursorWindow", "throws": null, "funcname": "CursorWindow (String name,                 long windowSizeBytes)", "parameters": [{"scri": "String: The name of the cursor window, or null if none.", "name": "name"}, {"scri": "long: Size of cursor window in bytes. Note: Memory is dynamically allocated as data rows are added to the window. Depending on the amount of data stored, the actual amount of memory allocated can be lower than specified size, but cannot exceed it.Value is a non-negative number of bytes.", "name": "windowSizeBytes"}], "descri": "  Creates a new empty cursor window and gives it a name. The cursor initially has no rows or columns.  Call setNumColumns(int) to set the number of columns before adding any rows to the cursor. "}, {"returns": null, "class": "android.database.DataSetObserver\n", "type": "static\n        \n        \n        void", "name": "createDbFromSqlStatements", "throws": null, "funcname": "void createDbFromSqlStatements (Context context,                 String dbName,                 int dbVersion,                 String sqlStatements)", "descri": "  Creates a db and populates it with the sql statements in sqlStatements. ", "parameters": [{"scri": "Context: the context to use to create the db", "name": "context"}, {"scri": "String: the name of the db to create", "name": "dbName"}, {"scri": "int: the version to set on the db", "name": "dbVersion"}, {"scri": "String: the statements to use to populate the db. This should be a single string   of the form returned by sqlite3's .dump command (statements separated by   semicolons)", "name": "sqlStatements"}]}, {"returns": null, "class": "android.database.sqlite.SQLiteStatement\n", "type": "void", "name": "setLookasideConfig", "throws": null, "funcname": "void setLookasideConfig (int slotSize,                 int slotCount)", "descri": "  Configures lookaside memory allocator This method should be called from the constructor of the subclass, before opening the database, since lookaside memory configuration can only be changed when no connection is using it SQLite default settings will be used, if this method isn't called. Use setLookasideConfig(0,0) to disable lookaside Note: Provided slotSize/slotCount configuration is just a recommendation. The system may choose different values depending on a device, e.g. lookaside allocations can be disabled on low-RAM devices ", "parameters": [{"scri": "int: The size in bytes of each lookaside slot.", "name": "slotSize"}, {"scri": "int: The total number of lookaside memory slots per database connection.", "name": "slotCount"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.graphics.BitmapShader\n", "type": "int", "name": "getByteCount", "throws": null, "funcname": "int getByteCount ()", "descri": "  Returns the minimum number of bytes that can be used to store this bitmap's pixels. As of KITKAT, the result of this method can no longer be used to determine memory usage of a bitmap. See getAllocationByteCount(). ", "parameters": null}, {"returns": [{"scri": "The argb Color at the specified coordinate", "type": "int"}], "class": "android.graphics.BitmapShader\n", "type": "int", "name": "getPixel", "throws": [{"scri": "if x, y exceed the bitmap's bounds", "type": "IllegalArgumentException"}, {"scri": "if the bitmap's config is HARDWARE", "type": "IllegalStateException"}], "funcname": "int getPixel (int x,                 int y)", "descri": "  Returns the Color at the specified location. Throws an exception if x or y are out of bounds (negative or >= to the width or height respectively). The returned color is a non-premultiplied ARGB value in the sRGB color space.    ", "parameters": [{"scri": "int: The x coordinate (0...width-1) of the pixel to return", "name": "x"}, {"scri": "int: The y coordinate (0...height-1) of the pixel to return", "name": "y"}]}, {"returns": [{"scri": "number of bytes between rows of the native bitmap pixels.", "type": "int"}], "class": "android.graphics.BitmapShader\n", "type": "int", "name": "getRowBytes", "throws": null, "funcname": "int getRowBytes ()", "descri": "  Return the number of bytes between rows in the bitmap's pixels. Note that this refers to the pixels as stored natively by the bitmap. If you call getPixels() or setPixels(), then the pixels are uniformly treated as 32bit values, packed according to the Color class. As of KITKAT, this method should not be used to calculate the memory usage of the bitmap. Instead, see getAllocationByteCount(). ", "parameters": null}, {"returns": null, "class": "android.graphics.BitmapShader\n", "type": "void", "name": "reconfigure", "throws": null, "funcname": "void reconfigure (int width,                 int height,                 Bitmap.Config config)", "descri": "   Modifies the bitmap to have a specified width, height, and Bitmap.Config, without affecting the underlying allocation backing the bitmap. Bitmap pixel data is not re-initialized for the new configuration.  This method can be used to avoid allocating a new bitmap, instead reusing an existing bitmap's allocation for a new configuration of equal or lesser size. If the Bitmap's allocation isn't large enough to support the new configuration, an IllegalArgumentException will be thrown and the bitmap will not be modified.  The result of getByteCount() will reflect the new configuration, while getAllocationByteCount() will reflect that of the initial configuration.  Note: This may change this result of hasAlpha(). When converting to 565, the new bitmap will always be considered opaque. When converting from 565, the new bitmap will be considered non-opaque, and will respect the value set by setPremultiplied().  WARNING: This method should NOT be called on a bitmap currently in use by the view system, Canvas, or the AndroidBitmap NDK API. It does not make guarantees about how the underlying pixel buffer is remapped to the new config, just that the allocation is reused. Additionally, the view system does not account for bitmap properties being modifying during use, e.g. while attached to drawables.  In order to safely ensure that a Bitmap is no longer in use by the View system it is necessary to wait for a draw pass to occur after invalidate()'ing any view that had previously drawn the Bitmap in the last draw pass due to hardware acceleration's caching of draw commands. As an example, here is how this can be done for an ImageView: ImageView myImageView = ...;      final Bitmap myBitmap = ...;      myImageView.setImageDrawable(null);      myImageView.post(new Runnable() {          public void run() {              // myBitmap is now no longer in use by the ImageView              // and can be safely reconfigured.              myBitmap.reconfigure(...);          }      });   See also: setWidth(int)setHeight(int)setConfig(Config)", "parameters": [{"scri": "int", "name": "width"}, {"scri": "int", "name": "height"}, {"scri": "Bitmap.Config", "name": "config"}]}, {"returns": [{"scri": "", "type": "float"}], "class": "android.graphics.ColorFilter\n", "type": "float", "name": "getLocationX", "throws": null, "funcname": "float getLocationX ()", "descri": "  Gets the x location of the camera.   See also: setLocation(float, float, float)", "parameters": null}, {"returns": [{"scri": "", "type": "float"}], "class": "android.graphics.ColorFilter\n", "type": "float", "name": "getLocationY", "throws": null, "funcname": "float getLocationY ()", "descri": "  Gets the y location of the camera.   See also: setLocation(float, float, float)", "parameters": null}, {"returns": [{"scri": "", "type": "float"}], "class": "android.graphics.ColorFilter\n", "type": "float", "name": "getLocationZ", "throws": null, "funcname": "float getLocationZ ()", "descri": "  Gets the z location of the camera.   See also: setLocation(float, float, float)", "parameters": null}, {"returns": null, "class": "android.graphics.ColorFilter\n", "type": "void", "name": "save", "throws": null, "funcname": "void save ()", "descri": "  Saves the camera state. Each save should be balanced with a call to restore().  See also: save()", "parameters": null}, {"returns": null, "class": "android.graphics.ColorFilter\n", "type": "void", "name": "setLocation", "throws": null, "funcname": "void setLocation (float x,                 float y,                 float z)", "descri": "  Sets the location of the camera. The default location is set at 0, 0, -8. ", "parameters": [{"scri": "float: The x location of the camera", "name": "x"}, {"scri": "float: The y location of the camera", "name": "y"}, {"scri": "float: The z location of the camera", "name": "z"}]}, {"returns": null, "class": "android.graphics.ColorFilter\n", "type": "void", "name": "setLocation", "throws": null, "funcname": "void setLocation (float x,                 float y,                 float z)", "descri": "  Sets the location of the camera. The default location is set at 0, 0, -8. ", "parameters": [{"scri": "float: The x location of the camera", "name": "x"}, {"scri": "float: The y location of the camera", "name": "y"}, {"scri": "float: The z location of the camera", "name": "z"}]}, {"returns": null, "class": "android.graphics.ColorFilter\n", "type": "void", "name": "setLocation", "throws": null, "funcname": "void setLocation (float x,                 float y,                 float z)", "descri": "  Sets the location of the camera. The default location is set at 0, 0, -8. ", "parameters": [{"scri": "float: The x location of the camera", "name": "x"}, {"scri": "float: The y location of the camera", "name": "y"}, {"scri": "float: The z location of the camera", "name": "z"}]}, {"returns": null, "class": "android.graphics.ColorFilter\n", "name": "Camera", "throws": null, "funcname": "Camera ()", "parameters": null, "descri": "  Creates a new camera, with empty transformations."}, {"returns": null, "class": "android.graphics.ColorFilter\n", "name": "Camera", "throws": null, "funcname": "Camera ()", "parameters": null, "descri": "  Creates a new camera, with empty transformations."}, {"returns": null, "class": "android.graphics.drawable.ColorDrawable\n", "type": "void", "name": "setHotspot", "throws": null, "funcname": "void setHotspot (float x,                 float y)", "descri": "  Specifies the hotspot's location within the drawable. ", "parameters": [{"scri": "float: The X coordinate of the center of the hotspot", "name": "x"}, {"scri": "float: The Y coordinate of the center of the hotspot", "name": "y"}]}, {"returns": null, "class": "android.graphics.drawable.GradientDrawable\n", "type": "void", "name": "setHotspot", "throws": null, "funcname": "void setHotspot (float x,                 float y)", "descri": "  Specifies the hotspot's location within the drawable. ", "parameters": [{"scri": "float: The X coordinate of the center of the hotspot", "name": "x"}, {"scri": "float: The Y coordinate of the center of the hotspot", "name": "y"}]}, {"returns": null, "class": "android.graphics.drawable.PaintDrawable\n", "type": "void", "name": "setHotspot", "throws": null, "funcname": "void setHotspot (float x,                 float y)", "descri": "  Specifies the hotspot's location within the drawable. ", "parameters": [{"scri": "float: The X coordinate of the center of the hotspot", "name": "x"}, {"scri": "float: The Y coordinate of the center of the hotspot", "name": "y"}]}, {"returns": null, "class": "android.graphics.drawable.ShapeDrawable\n", "type": "void", "name": "setHotspot", "throws": null, "funcname": "void setHotspot (float x,                 float y)", "descri": "  Specifies the hotspot's location within the drawable. ", "parameters": [{"scri": "float: The X coordinate of the center of the hotspot", "name": "x"}, {"scri": "float: The Y coordinate of the center of the hotspot", "name": "y"}]}, {"returns": null, "class": "android.hardware.Camera\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onShutter", "throws": null, "funcname": "void onShutter ()", "descri": "  Called as near as possible to the moment when a photo is captured from the sensor.  This is a good opportunity to play a shutter sound or give other feedback of camera operation.  This may be some time after the photo was triggered, but some time before the actual data is available.", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Face\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onSensorChanged", "throws": null, "funcname": "void onSensorChanged (int sensor,                 float[] values)", "descri": "   Called when sensor values have changed. The length and contents of the values array vary depending on which sensor is being monitored. See SensorManager for details on possible sensor types. Definition of the coordinate system used below.  The X axis refers to the screen's horizontal axis (the small edge in portrait mode, the long edge in landscape mode) and points to the right. The Y axis refers to the screen's vertical axis and points towards the top of the screen (the origin is in the lower-left corner). The Z axis points toward the sky when the device is lying on its back on a table. IMPORTANT NOTE: The axis are swapped when the device's screen orientation changes. To access the unswapped values, use indices 3, 4 and 5 in values[]. SENSOR_ORIENTATION, SENSOR_ORIENTATION_RAW: All values are angles in degrees. values[0]: Azimuth, rotation around the Z axis (0<=azimuth<360). 0 = North, 90 = East, 180 = South, 270 = West values[1]: Pitch, rotation around X axis (-180<=pitch<=180), with positive values when the z-axis moves toward the y-axis. values[2]: Roll, rotation around Y axis (-90<=roll<=90), with positive values when the z-axis moves toward the x-axis. Note that this definition of yaw, pitch and roll is different from the traditional definition used in aviation where the X axis is along the long side of the plane (tail to nose). SENSOR_ACCELEROMETER: All values are in SI units (m/s^2) and measure contact forces. values[0]: force applied by the device on the x-axis values[1]: force applied by the device on the y-axis values[2]: force applied by the device on the z-axis Examples: When the device is pushed on its left side toward the right, the    x acceleration value is negative (the device applies a reaction force    to the push toward the left)  When the device lies flat on a table, the acceleration value is    -STANDARD_GRAVITY,    which correspond to the force the device applies on the table in reaction    to gravity.  SENSOR_MAGNETIC_FIELD: All values are in micro-Tesla (uT) and measure the ambient magnetic  field in the X, Y and -Z axis. Note: the magnetic field's Z axis is inverted. ", "parameters": [{"scri": "int: The ID of the sensor being monitored", "name": "sensor"}, {"scri": "float: The new values for the sensor.", "name": "values"}]}, {"returns": null, "class": "android.hardware.Camera.OnZoomChangeListener\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onAutoFocus", "throws": null, "funcname": "void onAutoFocus (boolean success,                 Camera camera)", "descri": "  Called when the camera auto focus completes.  If the camera does not support auto-focus and autoFocus is called, onAutoFocus will be called immediately with a fake value of success set to true. The auto-focus routine does not lock auto-exposure and auto-white balance after it completes.   See also: setAutoExposureLock(boolean)setAutoWhiteBalanceLock(boolean)", "parameters": [{"scri": "boolean: true if focus was successful, false if otherwise", "name": "success"}, {"scri": "Camera: the Camera service object", "name": "camera"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "autoFocus", "throws": [{"scri": "if starting autofocus fails; usually this would    be because of a hardware or other low-level error, or because    release() has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void autoFocus (Camera.AutoFocusCallback cb)", "descri": "  Starts camera auto-focus and registers a callback function to run when the camera is focused.  This method is only valid when preview is active (between startPreview() and before stopPreview()). Callers should check getFocusMode() to determine if this method should be called. If the camera does not support auto-focus, it is a no-op and onAutoFocus(boolean, Camera) callback will be called immediately. If your application should not be installed on devices without auto-focus, you must declare that your application uses auto-focus with the <uses-feature> manifest element.  If the current flash mode is not FLASH_MODE_OFF, flash may be fired during auto-focus, depending on the driver and camera hardware.  Auto-exposure lock getAutoExposureLock() and auto-white balance locks getAutoWhiteBalanceLock() do not change during and after autofocus. But auto-focus routine may stop auto-exposure and auto-white balance transiently during focusing. Stopping preview with stopPreview(), or triggering still image capture with takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback), will not change the the focus position. Applications must call cancelAutoFocus to reset the focus.  If autofocus is successful, consider using MediaActionSound to properly play back an autofocus success sound to the user.    See also: cancelAutoFocus()setAutoExposureLock(boolean)setAutoWhiteBalanceLock(boolean)MediaActionSound", "parameters": [{"scri": "Camera.AutoFocusCallback: the callback to run", "name": "cb"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "cancelAutoFocus", "throws": [{"scri": "if canceling autofocus fails; usually this would    be because of a hardware or other low-level error, or because    release() has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void cancelAutoFocus ()", "descri": "  Cancels any auto-focus function in progress. Whether or not auto-focus is currently in progress, this function will return the focus position to the default. If the camera does not support auto-focus, this is a no-op.   See also: autoFocus(Camera.AutoFocusCallback)", "parameters": null}, {"returns": [{"scri": "true if the shutter sound state was successfully         changed. false if the shutter sound state could not be         changed. true is also returned if shutter sound playback         is already set to the requested state.", "type": "boolean"}], "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        boolean", "name": "enableShutterSound", "throws": [{"scri": "if the call fails; usually this would be because    of a hardware or other low-level error, or because release() has been    called on this Camera instance.", "type": "RuntimeException"}], "funcname": "boolean enableShutterSound (boolean enabled)", "descri": "   Enable or disable the default shutter sound when taking a picture.  By default, the camera plays the system-defined camera shutter sound when takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback) is called. Using this method, the shutter sound can be disabled. It is strongly recommended that an alternative shutter sound is played in the Camera.ShutterCallback when the system shutter sound is disabled.  Note that devices may not always allow disabling the camera shutter sound. If the shutter sound state cannot be set to the desired value, this method will return false. canDisableShutterSound can be used to determine whether the device will allow the shutter sound to be disabled.     See also: takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback)canDisableShutterSoundCamera.ShutterCallback", "parameters": [{"scri": "boolean: whether the camera should play the system shutter sound                when takePicture is called.", "name": "enabled"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "static\n        \n        \n        void", "name": "getCameraInfo", "throws": [{"scri": "if an invalid ID is provided, or if there is an    error retrieving the information (generally due to a hardware or other    low-level failure).", "type": "RuntimeException"}], "funcname": "void getCameraInfo (int cameraId,                 Camera.CameraInfo cameraInfo)", "descri": "  Returns the information about a particular camera. If getNumberOfCameras() returns N, the valid id is 0 to N-1.   ", "parameters": [{"scri": "int", "name": "cameraId"}, {"scri": "Camera.CameraInfo", "name": "cameraInfo"}]}, {"returns": [{"scri": "total number of accessible camera devices, or 0 if there are no   cameras or an error was encountered enumerating them.", "type": "int"}], "class": "android.hardware.Camera.Parameters\n", "type": "static\n        \n        \n        int", "name": "getNumberOfCameras", "throws": null, "funcname": "int getNumberOfCameras ()", "descri": "  Returns the number of physical cameras available on this device. The return value of this method might change dynamically if the device supports external cameras and an external camera is connected or disconnected. ", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "lock", "throws": [{"scri": "if the camera cannot be re-locked (for     example, if the camera is still in use by another process).", "type": "RuntimeException"}], "funcname": "void lock ()", "descri": "  Re-locks the camera to prevent other processes from accessing it. Camera objects are locked by default unless unlock() is called.  Normally reconnect() is used instead. Since API level 14, camera is automatically locked for applications in start(). Applications can use the camera (ex: zoom) after recording starts. There is no need to call this after recording starts or stops. If you are not recording video, you probably do not need this method.  ", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "reconnect", "throws": [{"scri": "if a connection cannot be re-established (for     example, if the camera is still in use by another process).", "type": "IOException"}, {"scri": "if release() has been called on this Camera     instance.", "type": "RuntimeException"}], "funcname": "void reconnect ()", "descri": "  Reconnects to the camera service after another process used it. After unlock() is called, another process may use the camera; when the process is done, you must reconnect to the camera, which will re-acquire the lock and allow you to continue using the camera. Since API level 14, camera is automatically locked for applications in start(). Applications can use the camera (ex: zoom) after recording starts. There is no need to call this after recording starts or stops. If you are not recording video, you probably do not need this method.  ", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "release", "throws": null, "funcname": "void release ()", "descri": "  Disconnects and releases the Camera object resources. You must call this as soon as you're done with the Camera object.", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "void", "name": "setAutoFocusMoveCallback", "throws": [{"scri": "if enabling the focus move callback fails;    usually this would be because of a hardware or other low-level error,    or because release() has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void setAutoFocusMoveCallback (Camera.AutoFocusMoveCallback cb)", "descri": "  Sets camera auto-focus move callback.   ", "parameters": [{"scri": "Camera.AutoFocusMoveCallback: the callback to run", "name": "cb"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setDisplayOrientation", "throws": [{"scri": "if setting orientation fails; usually this would    be because of a hardware or other low-level error, or because    release() has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void setDisplayOrientation (int degrees)", "descri": "  Set the clockwise rotation of preview display in degrees. This affects the preview frames and the picture displayed after snapshot. This method is useful for portrait mode applications. Note that preview display of front-facing cameras is flipped horizontally before the rotation, that is, the image is reflected along the central vertical axis of the camera sensor. So the users can see themselves as looking into a mirror. This does not affect the order of byte array passed in onPreviewFrame(byte[], Camera), JPEG pictures, or recorded videos. This method is not allowed to be called during preview. If you want to make the camera image show in the same orientation as the display, you can use the following code. public static void setCameraDisplayOrientation(Activity activity,         int cameraId, android.hardware.Camera camera) {     android.hardware.Camera.CameraInfo info =             new android.hardware.Camera.CameraInfo();     android.hardware.Camera.getCameraInfo(cameraId, info);     int rotation = activity.getWindowManager().getDefaultDisplay()             .getRotation();     int degrees = 0;     switch (rotation) {         case Surface.ROTATION_0: degrees = 0; break;         case Surface.ROTATION_90: degrees = 90; break;         case Surface.ROTATION_180: degrees = 180; break;         case Surface.ROTATION_270: degrees = 270; break;     }     int result;     if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {         result = (info.orientation + degrees) % 360;         result = (360 - result) % 360;  // compensate the mirror     } else {  // back-facing         result = (info.orientation - degrees + 360) % 360;     }     camera.setDisplayOrientation(result); }  Starting from API level 14, this method can be called when preview is active. Note: Before API level 24, the default value for orientation is 0. Starting in API level 24, the default orientation will be such that applications in forced-landscape mode will have correct preview orientation, which may be either a default of 0 or 180. Applications that operate in portrait mode or allow for changing orientation must still call this method after each orientation change to ensure correct preview display in all cases.    See also: setPreviewDisplay(SurfaceHolder)", "parameters": [{"scri": "int: the angle that the picture will be rotated clockwise.                Valid values are 0, 90, 180, and 270.", "name": "degrees"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setErrorCallback", "throws": null, "funcname": "void setErrorCallback (Camera.ErrorCallback cb)", "descri": "  Registers a callback to be invoked when an error occurs. ", "parameters": [{"scri": "Camera.ErrorCallback: The callback to run", "name": "cb"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setFaceDetectionListener", "throws": null, "funcname": "void setFaceDetectionListener (Camera.FaceDetectionListener listener)", "descri": "  Registers a listener to be notified about the faces detected in the preview frame.   See also: startFaceDetection()", "parameters": [{"scri": "Camera.FaceDetectionListener: the listener to notify", "name": "listener"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setOneShotPreviewCallback", "throws": [{"scri": "if release() has been called on this Camera     instance.", "type": "RuntimeException"}], "funcname": "void setOneShotPreviewCallback (Camera.PreviewCallback cb)", "descri": "   Installs a callback to be invoked for the next preview frame in addition to displaying it on the screen.  After one invocation, the callback is cleared. This method can be called any time, even when preview is live.  Any other preview callbacks are overridden.  If you are using the preview data to create video or still images, strongly consider using MediaActionSound to properly indicate image capture or recording start/stop to the user.    See also: MediaActionSound", "parameters": [{"scri": "Camera.PreviewCallback: a callback object that receives a copy of the next preview frame,     or null to stop receiving callbacks.", "name": "cb"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "void", "name": "setParameters", "throws": [{"scri": "if any parameter is invalid or not supported.", "type": "RuntimeException"}], "funcname": "void setParameters (Camera.Parameters params)", "descri": "  Changes the settings for this Camera service.    See also: getParameters()", "parameters": [{"scri": "Camera.Parameters: the Parameters to use for this Camera service", "name": "params"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setPreviewCallback", "throws": [{"scri": "if release() has been called on this Camera     instance.", "type": "RuntimeException"}], "funcname": "void setPreviewCallback (Camera.PreviewCallback cb)", "descri": "   Installs a callback to be invoked for every preview frame in addition to displaying them on the screen.  The callback will be repeatedly called for as long as preview is active.  This method can be called at any time, even while preview is live.  Any other preview callbacks are overridden.  If you are using the preview data to create video or still images, strongly consider using MediaActionSound to properly indicate image capture or recording start/stop to the user.    See also: MediaActionSound", "parameters": [{"scri": "Camera.PreviewCallback: a callback object that receives a copy of each preview frame,     or null to stop receiving callbacks.", "name": "cb"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setPreviewCallbackWithBuffer", "throws": [{"scri": "if release() has been called on this Camera     instance.", "type": "RuntimeException"}], "funcname": "void setPreviewCallbackWithBuffer (Camera.PreviewCallback cb)", "descri": "   Installs a callback to be invoked for every preview frame, using buffers supplied with addCallbackBuffer(byte[]), in addition to displaying them on the screen.  The callback will be repeatedly called for as long as preview is active and buffers are available.  Any other preview callbacks are overridden.  The purpose of this method is to improve preview efficiency and frame rate by allowing preview frame memory reuse.  You must call addCallbackBuffer(byte[]) at some point -- before or after calling this method -- or no callbacks will received.  The buffer queue will be cleared if this method is called with a null callback, setPreviewCallback(Camera.PreviewCallback) is called, or setOneShotPreviewCallback(Camera.PreviewCallback) is called.  If you are using the preview data to create video or still images, strongly consider using MediaActionSound to properly indicate image capture or recording start/stop to the user.    See also: addCallbackBuffer(byte[])MediaActionSound", "parameters": [{"scri": "Camera.PreviewCallback: a callback object that receives a copy of the preview frame,     or null to stop receiving callbacks and clear the buffer queue.", "name": "cb"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setPreviewDisplay", "throws": [{"scri": "if the method fails (for example, if the surface     is unavailable or unsuitable).", "type": "IOException"}, {"scri": "if release() has been called on this Camera    instance.", "type": "RuntimeException"}], "funcname": "void setPreviewDisplay (SurfaceHolder holder)", "descri": "  Sets the Surface to be used for live preview. Either a surface or surface texture is necessary for preview, and preview is necessary to take pictures.  The same surface can be re-set without harm.  Setting a preview surface will un-set any preview surface texture that was set via setPreviewTexture(SurfaceTexture). The SurfaceHolder must already contain a surface when this method is called.  If you are using SurfaceView, you will need to register a SurfaceHolder.Callback with addCallback(SurfaceHolder.Callback) and wait for surfaceCreated(SurfaceHolder) before calling setPreviewDisplay() or starting preview. This method must be called before startPreview().  The one exception is that if the preview surface is not set (or set to null) before startPreview() is called, then this method may be called once with a non-null parameter to set the preview surface.  (This allows camera setup and surface creation to happen in parallel, saving time.) The preview surface may not otherwise change while preview is running.   ", "parameters": [{"scri": "SurfaceHolder: containing the Surface on which to place the preview,     or null to remove the preview surface", "name": "holder"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setPreviewTexture", "throws": [{"scri": "if the method fails (for example, if the surface     texture is unavailable or unsuitable).", "type": "IOException"}, {"scri": "if release() has been called on this Camera    instance.", "type": "RuntimeException"}], "funcname": "void setPreviewTexture (SurfaceTexture surfaceTexture)", "descri": "  Sets the SurfaceTexture to be used for live preview. Either a surface or surface texture is necessary for preview, and preview is necessary to take pictures.  The same surface texture can be re-set without harm.  Setting a preview surface texture will un-set any preview surface that was set via setPreviewDisplay(SurfaceHolder). This method must be called before startPreview().  The one exception is that if the preview surface texture is not set (or set to null) before startPreview() is called, then this method may be called once with a non-null parameter to set the preview surface.  (This allows camera setup and surface creation to happen in parallel, saving time.) The preview surface texture may not otherwise change while preview is running. The timestamps provided by getTimestamp() for a SurfaceTexture set as the preview texture have an unspecified zero point, and cannot be directly compared between different cameras or different instances of the same camera, or across multiple runs of the same program. If you are using the preview data to create video or still images, strongly consider using MediaActionSound to properly indicate image capture or recording start/stop to the user.    See also: MediaActionSoundSurfaceTextureTextureView", "parameters": [{"scri": "SurfaceTexture: the SurfaceTexture to which the preview     images are to be sent or null to remove the current preview surface     texture", "name": "surfaceTexture"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "setZoomChangeListener", "throws": null, "funcname": "void setZoomChangeListener (Camera.OnZoomChangeListener listener)", "descri": "  Registers a listener to be notified when the zoom value is updated by the camera driver during smooth zoom.   See also: startSmoothZoom(int)", "parameters": [{"scri": "Camera.OnZoomChangeListener: the listener to notify", "name": "listener"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "startFaceDetection", "throws": [{"scri": "if the face detection is unsupported.", "type": "IllegalArgumentException"}, {"scri": "if the method fails or the face detection is         already running.", "type": "RuntimeException"}], "funcname": "void startFaceDetection ()", "descri": "  Starts the face detection. This should be called after preview is started. The camera will notify Camera.FaceDetectionListener of the detected faces in the preview frame. The detected faces may be the same as the previous ones. Applications should call stopFaceDetection() to stop the face detection. This method is supported if getMaxNumDetectedFaces() returns a number larger than 0. If the face detection has started, apps should not call this again. When the face detection is running, setWhiteBalance(String), setFocusAreas(List), and setMeteringAreas(List) have no effect. The camera uses the detected faces to do auto-white balance, auto exposure, and autofocus. If the apps call autoFocus(AutoFocusCallback), the camera will stop sending face callbacks. The last face callback indicates the areas used to do autofocus. After focus completes, face detection will resume sending face callbacks. If the apps call cancelAutoFocus(), the face callbacks will also resume.  After calling takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback) or stopPreview(), and then resuming preview with startPreview(), the apps should call this method again to resume face detection.   See also: Camera.FaceDetectionListenerstopFaceDetection()getMaxNumDetectedFaces()", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "startPreview", "throws": [{"scri": "if starting preview fails; usually this would be    because of a hardware or other low-level error, or because release()    has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void startPreview ()", "descri": "  Starts capturing and drawing preview frames to the screen. Preview will not actually start until a surface is supplied with setPreviewDisplay(SurfaceHolder) or setPreviewTexture(SurfaceTexture). If setPreviewCallback(Camera.PreviewCallback), setOneShotPreviewCallback(Camera.PreviewCallback), or setPreviewCallbackWithBuffer(Camera.PreviewCallback) were called, onPreviewFrame(byte[], Camera) will be called when preview data becomes available.  ", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "startSmoothZoom", "throws": [{"scri": "if the zoom value is invalid.", "type": "IllegalArgumentException"}, {"scri": "if the method fails.", "type": "RuntimeException"}], "funcname": "void startSmoothZoom (int value)", "descri": "  Zooms to the requested value smoothly. The driver will notify Camera.OnZoomChangeListener of the zoom value and whether zoom is stopped at the time. For example, suppose the current zoom is 0 and startSmoothZoom is called with value 3. The onZoomChange(int, boolean, Camera) method will be called three times with zoom values 1, 2, and 3. Applications can call stopSmoothZoom() to stop the zoom earlier. Applications should not call startSmoothZoom again or change the zoom value before zoom stops. If the supplied zoom value equals to the current zoom value, no zoom callback will be generated. This method is supported if isSmoothZoomSupported() returns true.    See also: setZoomChangeListener(OnZoomChangeListener)", "parameters": [{"scri": "int: zoom value. The valid range is 0 to getMaxZoom().", "name": "value"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "stopPreview", "throws": [{"scri": "if stopping preview fails; usually this would be    because of a hardware or other low-level error, or because release()    has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void stopPreview ()", "descri": "  Stops capturing and drawing preview frames to the surface, and resets the camera for a future call to startPreview().  ", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "stopSmoothZoom", "throws": [{"scri": "if the method fails.", "type": "RuntimeException"}], "funcname": "void stopSmoothZoom ()", "descri": "  Stops the smooth zoom. Applications should wait for the Camera.OnZoomChangeListener to know when the zoom is actually stopped. This method is supported if isSmoothZoomSupported() is true.  ", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "takePicture", "throws": [{"scri": "if starting picture capture fails; usually this    would be because of a hardware or other low-level error, or because    release() has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void takePicture (Camera.ShutterCallback shutter,                 Camera.PictureCallback raw,                 Camera.PictureCallback postview,                 Camera.PictureCallback jpeg)", "descri": "  Triggers an asynchronous image capture. The camera service will initiate a series of callbacks to the application as the image capture progresses. The shutter callback occurs after the image is captured. This can be used to trigger a sound to let the user know that image has been captured. The raw callback occurs when the raw image data is available (NOTE: the data will be null if there is no raw image callback buffer available or the raw image callback buffer is not large enough to hold the raw image). The postview callback occurs when a scaled, fully processed postview image is available (NOTE: not all hardware supports this). The jpeg callback occurs when the compressed image is available. If the application does not need a particular callback, a null can be passed instead of a callback method. This method is only valid when preview is active (after startPreview()).  Preview will be stopped after the image is taken; callers must call startPreview() again if they want to re-start preview or take more pictures. This should not be called between start() and stop(). After calling this method, you must not call startPreview() or take another picture until the JPEG callback has returned.   ", "parameters": [{"scri": "Camera.ShutterCallback: the callback for image capture moment, or null", "name": "shutter"}, {"scri": "Camera.PictureCallback: the callback for raw (uncompressed) image data, or null", "name": "raw"}, {"scri": "Camera.PictureCallback: callback with postview image data, may be null", "name": "postview"}, {"scri": "Camera.PictureCallback: the callback for JPEG image data, or null", "name": "jpeg"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "takePicture", "throws": [{"scri": "if starting picture capture fails; usually this    would be because of a hardware or other low-level error, or because    release() has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void takePicture (Camera.ShutterCallback shutter,                 Camera.PictureCallback raw,                 Camera.PictureCallback postview,                 Camera.PictureCallback jpeg)", "descri": "  Triggers an asynchronous image capture. The camera service will initiate a series of callbacks to the application as the image capture progresses. The shutter callback occurs after the image is captured. This can be used to trigger a sound to let the user know that image has been captured. The raw callback occurs when the raw image data is available (NOTE: the data will be null if there is no raw image callback buffer available or the raw image callback buffer is not large enough to hold the raw image). The postview callback occurs when a scaled, fully processed postview image is available (NOTE: not all hardware supports this). The jpeg callback occurs when the compressed image is available. If the application does not need a particular callback, a null can be passed instead of a callback method. This method is only valid when preview is active (after startPreview()).  Preview will be stopped after the image is taken; callers must call startPreview() again if they want to re-start preview or take more pictures. This should not be called between start() and stop(). After calling this method, you must not call startPreview() or take another picture until the JPEG callback has returned.   ", "parameters": [{"scri": "Camera.ShutterCallback: the callback for image capture moment, or null", "name": "shutter"}, {"scri": "Camera.PictureCallback: the callback for raw (uncompressed) image data, or null", "name": "raw"}, {"scri": "Camera.PictureCallback: callback with postview image data, may be null", "name": "postview"}, {"scri": "Camera.PictureCallback: the callback for JPEG image data, or null", "name": "jpeg"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "takePicture", "throws": [{"scri": "if starting picture capture fails; usually this    would be because of a hardware or other low-level error, or because    release() has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void takePicture (Camera.ShutterCallback shutter,                 Camera.PictureCallback raw,                 Camera.PictureCallback postview,                 Camera.PictureCallback jpeg)", "descri": "  Triggers an asynchronous image capture. The camera service will initiate a series of callbacks to the application as the image capture progresses. The shutter callback occurs after the image is captured. This can be used to trigger a sound to let the user know that image has been captured. The raw callback occurs when the raw image data is available (NOTE: the data will be null if there is no raw image callback buffer available or the raw image callback buffer is not large enough to hold the raw image). The postview callback occurs when a scaled, fully processed postview image is available (NOTE: not all hardware supports this). The jpeg callback occurs when the compressed image is available. If the application does not need a particular callback, a null can be passed instead of a callback method. This method is only valid when preview is active (after startPreview()).  Preview will be stopped after the image is taken; callers must call startPreview() again if they want to re-start preview or take more pictures. This should not be called between start() and stop(). After calling this method, you must not call startPreview() or take another picture until the JPEG callback has returned.   ", "parameters": [{"scri": "Camera.ShutterCallback: the callback for image capture moment, or null", "name": "shutter"}, {"scri": "Camera.PictureCallback: the callback for raw (uncompressed) image data, or null", "name": "raw"}, {"scri": "Camera.PictureCallback: callback with postview image data, may be null", "name": "postview"}, {"scri": "Camera.PictureCallback: the callback for JPEG image data, or null", "name": "jpeg"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "takePicture", "throws": [{"scri": "if starting picture capture fails; usually this    would be because of a hardware or other low-level error, or because    release() has been called on this Camera instance.", "type": "RuntimeException"}], "funcname": "void takePicture (Camera.ShutterCallback shutter,                 Camera.PictureCallback raw,                 Camera.PictureCallback postview,                 Camera.PictureCallback jpeg)", "descri": "  Triggers an asynchronous image capture. The camera service will initiate a series of callbacks to the application as the image capture progresses. The shutter callback occurs after the image is captured. This can be used to trigger a sound to let the user know that image has been captured. The raw callback occurs when the raw image data is available (NOTE: the data will be null if there is no raw image callback buffer available or the raw image callback buffer is not large enough to hold the raw image). The postview callback occurs when a scaled, fully processed postview image is available (NOTE: not all hardware supports this). The jpeg callback occurs when the compressed image is available. If the application does not need a particular callback, a null can be passed instead of a callback method. This method is only valid when preview is active (after startPreview()).  Preview will be stopped after the image is taken; callers must call startPreview() again if they want to re-start preview or take more pictures. This should not be called between start() and stop(). After calling this method, you must not call startPreview() or take another picture until the JPEG callback has returned.   ", "parameters": [{"scri": "Camera.ShutterCallback: the callback for image capture moment, or null", "name": "shutter"}, {"scri": "Camera.PictureCallback: the callback for raw (uncompressed) image data, or null", "name": "raw"}, {"scri": "Camera.PictureCallback: callback with postview image data, may be null", "name": "postview"}, {"scri": "Camera.PictureCallback: the callback for JPEG image data, or null", "name": "jpeg"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "takePicture", "throws": null, "funcname": "void takePicture (Camera.ShutterCallback shutter,                 Camera.PictureCallback raw,                 Camera.PictureCallback jpeg)", "descri": "  Equivalent to takePicture(Shutter, raw, null, jpeg) .  See also: takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)", "parameters": [{"scri": "Camera.ShutterCallback", "name": "shutter"}, {"scri": "Camera.PictureCallback", "name": "raw"}, {"scri": "Camera.PictureCallback", "name": "jpeg"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "takePicture", "throws": null, "funcname": "void takePicture (Camera.ShutterCallback shutter,                 Camera.PictureCallback raw,                 Camera.PictureCallback jpeg)", "descri": "  Equivalent to takePicture(Shutter, raw, null, jpeg) .  See also: takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)", "parameters": [{"scri": "Camera.ShutterCallback", "name": "shutter"}, {"scri": "Camera.PictureCallback", "name": "raw"}, {"scri": "Camera.PictureCallback", "name": "jpeg"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "takePicture", "throws": null, "funcname": "void takePicture (Camera.ShutterCallback shutter,                 Camera.PictureCallback raw,                 Camera.PictureCallback jpeg)", "descri": "  Equivalent to takePicture(Shutter, raw, null, jpeg) .  See also: takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)", "parameters": [{"scri": "Camera.ShutterCallback", "name": "shutter"}, {"scri": "Camera.PictureCallback", "name": "raw"}, {"scri": "Camera.PictureCallback", "name": "jpeg"}]}, {"returns": null, "class": "android.hardware.Camera.Parameters\n", "type": "final\n        \n        void", "name": "unlock", "throws": [{"scri": "if the camera cannot be unlocked.", "type": "RuntimeException"}], "funcname": "void unlock ()", "descri": "  Unlocks the camera to allow another process to access it. Normally, the camera is locked to the process with an active Camera object until release() is called.  To allow rapid handoff between processes, you can call this method to release the camera temporarily for another process to use; once the other process is done you can call reconnect() to reclaim the camera. This must be done before calling setCamera(Camera). This cannot be called after recording starts. If you are not recording video, you probably do not need this method.  ", "parameters": null}, {"returns": null, "class": "android.hardware.Camera.PreviewCallback\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onError", "throws": null, "funcname": "void onError (int error,                 Camera camera)", "descri": "  Callback for camera errors. ", "parameters": [{"scri": "int: error code:  CAMERA_ERROR_UNKNOWN CAMERA_ERROR_SERVER_DIED", "name": "error"}, {"scri": "Camera: the Camera service object", "name": "camera"}]}, {"returns": null, "class": "android.hardware.camera2.CameraCaptureSession\n", "type": "void", "name": "onDynamicSensorConnected", "throws": null, "funcname": "void onDynamicSensorConnected (Sensor sensor)", "descri": "  Called when there is a dynamic sensor being connected to the system. ", "parameters": [{"scri": "Sensor: the newly connected sensor. See Sensor.", "name": "sensor"}]}, {"returns": null, "class": "android.hardware.camera2.CameraCaptureSession\n", "type": "void", "name": "onDynamicSensorDisconnected", "throws": null, "funcname": "void onDynamicSensorDisconnected (Sensor sensor)", "descri": "  Called when there is a dynamic sensor being disconnected from the system. ", "parameters": [{"scri": "Sensor: the disconnected sensor. See Sensor.", "name": "sensor"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "abortCaptures", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}], "funcname": "void abortCaptures ()", "descri": "  Discard all captures currently pending and in-progress as fast as possible. The camera device will discard all of its current work as fast as possible. Some in-flight captures may complete successfully and call onCaptureCompleted(CameraCaptureSession, CaptureRequest, TotalCaptureResult), while others will trigger their onCaptureFailed(CameraCaptureSession, CaptureRequest, CaptureFailure) callbacks. If a repeating request or a repeating burst is set, it will be cleared.  This method is the fastest way to switch the camera device to a new session with createCaptureSession(SessionConfiguration) or createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler), at the cost of discarding in-progress work. It must be called before the new session is created. Once all pending requests are either completed or thrown away, the onReady(CameraCaptureSession) callback will be called, if the session has not been closed. Otherwise, the onClosed(CameraCaptureSession) callback will be fired when a new session is created by the camera device.  Cancelling will introduce at least a brief pause in the stream of data from the camera device, since once the camera device is emptied, the first new request has to make it through the entire camera pipeline before new output buffers are produced.  This means that using abortCaptures() to simply remove pending requests is not recommended; it's best used for quickly switching output configurations, or for cancelling long in-progress requests (such as a multi-second capture).   See also: setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)createCaptureSession(SessionConfiguration)createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler)", "parameters": null}, {"returns": [{"scri": "int A unique capture sequence ID used by             onCaptureSequenceCompleted(CameraCaptureSession, int, long).", "type": "int"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        int", "name": "capture", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "if the request targets no Surfaces or Surfaces that are not                                  configured as outputs for this session; or the request                                  targets a set of Surfaces that cannot be submitted                                  simultaneously in a reprocessable capture session; or a                                  reprocess capture request is submitted in a                                  non-reprocessable capture session; or the reprocess capture                                  request was created with a TotalCaptureResult from                                  a different session; or the capture targets a Surface in                                  the middle of being prepared; or the                                  handler is null, the listener is not null, and the calling                                  thread has no looper.", "type": "IllegalArgumentException"}], "funcname": "int capture (CaptureRequest request,                 CameraCaptureSession.CaptureCallback listener,                 Handler handler)", "descri": "   Submit a request for an image to be captured by the camera device.  The request defines all the parameters for capturing the single image, including sensor, lens, flash, and post-processing settings.  Each request will produce one CaptureResult and produce new frames for one or more target Surfaces, set with the CaptureRequest builder's addTarget(Surface) method. The target surfaces (set with addTarget(Surface)) must be a subset of the surfaces provided when this capture session was created.  Multiple regular and reprocess requests can be in progress at once. If there are only regular requests or reprocess requests in progress, they are processed in first-in, first-out order. If there are both regular and reprocess requests in progress, regular requests are processed in first-in, first-out order and reprocess requests are processed in first-in, first-out order, respectively. However, the processing order of a regular request and a reprocess request in progress is not specified. In other words, a regular request will always be processed before regular requets that are submitted later. A reprocess request will always be processed before reprocess requests that are submitted later. However, a regular request may not be processed before reprocess requests that are submitted later.  Requests submitted through this method have higher priority than those submitted through setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) or setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler), and will be processed as soon as the current repeat/repeatBurst processing completes.  All capture sessions can be used for capturing images from the camera but only capture sessions created by createReprocessableCaptureSession can submit reprocess capture requests. Submitting a reprocess request to a regular capture session will result in an IllegalArgumentException.     See also: captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)abortCaptures()createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler)", "parameters": [{"scri": "CaptureRequest: the settings for this captureThis value must never be null.", "name": "request"}, {"scri": "CameraCaptureSession.CaptureCallback: The callback object to notify once this request has been processed. If null, no metadata will be produced for this capture, although image data will still be produced.", "name": "listener"}, {"scri": "Handler: the handler on which the listener should be invoked, or null to use the current thread's looper.", "name": "handler"}]}, {"returns": [{"scri": "int A unique capture sequence ID used by             onCaptureSequenceCompleted(CameraCaptureSession, int, long).", "type": "int"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        int", "name": "captureBurst", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "If the requests target no Surfaces, or the requests target                                  Surfaces not currently configured as outputs; or one of the                                  requests targets a set of Surfaces that cannot be submitted                                  simultaneously in a reprocessable capture session; or a                                  reprocess capture request is submitted in a                                  non-reprocessable capture session; or one of the reprocess                                  capture requests was created with a                                  TotalCaptureResult from a different session; or one                                  of the captures targets a Surface in the middle of being                                  prepared; or if the handler is null, the                                  listener is not null, and the calling thread has no looper.", "type": "IllegalArgumentException"}], "funcname": "int captureBurst (List<CaptureRequest> requests,                 CameraCaptureSession.CaptureCallback listener,                 Handler handler)", "descri": "  Submit a list of requests to be captured in sequence as a burst. The burst will be captured in the minimum amount of time possible, and will not be interleaved with requests submitted by other capture or repeat calls. Regular and reprocess requests can be mixed together in a single burst. Regular requests will be captured in order and reprocess requests will be processed in order, respectively. However, the processing order between a regular request and a reprocess request is not specified. Each capture produces one CaptureResult and image buffers for one or more target surfaces. The target surfaces (set with addTarget(Surface)) must be a subset of the surfaces provided when this capture session was created.  The main difference between this method and simply calling capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) repeatedly is that this method guarantees that no other requests will be interspersed with the burst.  All capture sessions can be used for capturing images from the camera but only capture sessions created by createReprocessableCaptureSession can submit reprocess capture requests. Submitting a reprocess request to a regular capture session will result in an IllegalArgumentException.     See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)abortCaptures()", "parameters": [{"scri": "List: the list of settings for this burst captureThis value must never be null.", "name": "requests"}, {"scri": "CameraCaptureSession.CaptureCallback: The callback object to notify each time one of the requests in the burst has been processed. If null, no metadata will be produced for any requests in this burst, although image data will still be produced.", "name": "listener"}, {"scri": "Handler: the handler on which the listener should be invoked, or null to use the current thread's looper.", "name": "handler"}]}, {"returns": [{"scri": "int A unique capture sequence ID used by             onCaptureSequenceCompleted(CameraCaptureSession, int, long).", "type": "int"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "int", "name": "captureBurstRequests", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "If the requests target no Surfaces, or the requests target                                  Surfaces not currently configured as outputs; or one of the                                  requests targets a set of Surfaces that cannot be submitted                                  simultaneously in a reprocessable capture session; or a                                  reprocess capture request is submitted in a                                  non-reprocessable capture session; or one of the reprocess                                  capture requests was created with a                                  TotalCaptureResult from a different session; or one                                  of the captures targets a Surface in the middle of being                                  prepared; or if the executor is null; or if                                  the listener is null.", "type": "IllegalArgumentException"}], "funcname": "int captureBurstRequests (List<CaptureRequest> requests,                 Executor executor,                 CameraCaptureSession.CaptureCallback listener)", "descri": "  Submit a list of requests to be captured in sequence as a burst. The burst will be captured in the minimum amount of time possible, and will not be interleaved with requests submitted by other capture or repeat calls. The behavior of this method matches that of captureBurst(List, CaptureCallback, Handler), except that it uses Executor as an argument instead of Handler.     See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)abortCaptures()", "parameters": [{"scri": "List: the list of settings for this burst captureThis value must never be null.", "name": "requests"}, {"scri": "Executor: the executor which will be used for invoking the listener.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraCaptureSession.CaptureCallback: The callback object to notify each time one of the requests in the burst has been processed.This value must never be null.", "name": "listener"}]}, {"returns": [{"scri": "int A unique capture sequence ID used by             onCaptureSequenceCompleted(CameraCaptureSession, int, long).", "type": "int"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "int", "name": "captureSingleRequest", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "if the request targets no Surfaces or Surfaces that are not                                  configured as outputs for this session; or the request                                  targets a set of Surfaces that cannot be submitted                                  simultaneously in a reprocessable capture session; or a                                  reprocess capture request is submitted in a                                  non-reprocessable capture session; or the reprocess capture                                  request was created with a TotalCaptureResult from                                  a different session; or the capture targets a Surface in                                  the middle of being prepared; or the                                  executor is null, or the listener is not null.", "type": "IllegalArgumentException"}], "funcname": "int captureSingleRequest (CaptureRequest request,                 Executor executor,                 CameraCaptureSession.CaptureCallback listener)", "descri": "   Submit a request for an image to be captured by the camera device.  The behavior of this method matches that of capture(CaptureRequest, CaptureCallback, Handler), except that it uses Executor as an argument instead of Handler.     See also: captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)abortCaptures()createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler)", "parameters": [{"scri": "CaptureRequest: the settings for this captureThis value must never be null.", "name": "request"}, {"scri": "Executor: the executor which will be used for invoking the listener.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraCaptureSession.CaptureCallback: The callback object to notify once this request has been processed.This value must never be null.", "name": "listener"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "close", "throws": null, "funcname": "void close ()", "descri": "  Close this capture session asynchronously. Closing a session frees up the target output Surfaces of the session for reuse with either a new session, or to other APIs that can draw to Surfaces.  Note that creating a new capture session with createCaptureSession(SessionConfiguration) will close any existing capture session automatically, and call the older session listener's onClosed(CameraCaptureSession) callback. Using createCaptureSession(SessionConfiguration) directly without closing is the recommended approach for quickly switching to a new session, since unchanged target outputs can be reused more efficiently.  Once a session is closed, all methods on it will throw an IllegalStateException, and any repeating requests or bursts are stopped (as if stopRepeating() was called). However, any in-progress capture requests submitted to the session will be completed as normal; once all captures have completed and the session has been torn down, onClosed(CameraCaptureSession) will be called.  Closing a session is idempotent; closing more than once has no effect.", "parameters": null}, {"returns": null, "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "finalizeOutputConfigurations", "throws": [{"scri": "if the camera device is no longer connected or has encountered             a fatal error.", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session             was explicitly closed, a new session has been created, or the camera device has             been closed.", "type": "IllegalStateException"}, {"scri": "for invalid output configurations, including ones where the             source of the Surface is no longer valid or the Surface is from a unsupported             source. Or if one of the output configuration was already finished with an             included surface in a prior call.", "type": "IllegalArgumentException"}], "funcname": "void finalizeOutputConfigurations (List<OutputConfiguration> outputConfigs)", "descri": "   Finalize the output configurations that now have their deferred and/or extra Surfaces included.  For camera use cases where a preview and other output configurations need to be configured, it can take some time for the preview Surface to be ready. For example, if the preview Surface is obtained from SurfaceView, the SurfaceView will only be ready after the UI layout is done, potentially delaying camera startup.  To speed up camera startup time, the application can configure the CameraCaptureSession with the eventual preview size (via a deferred OutputConfiguration), and defer the preview output configuration until the Surface is ready. After the CameraCaptureSession is created successfully with this deferred output and other normal outputs, the application can start submitting requests as long as they do not include deferred output Surfaces. Once a deferred Surface is ready, the application can add the Surface to the deferred output configuration with the addSurface(Surface) method, and then update the deferred output configuration via this method, before it can submit capture requests with this output target.  This function can also be called in case where multiple surfaces share the same OutputConfiguration, and one of the surfaces becomes available after the CameraCaptureSession is created. In that case, the application must first create the OutputConfiguration with the available Surface, then enable further surface sharing via enableSurfaceSharing(), before creating the CameraCaptureSession. After the CameraCaptureSession is created, and once the extra Surface becomes available, the application must then call addSurface(Surface) before finalizing the configuration with this method.  If the provided OutputConfigurations are unchanged from session creation, this function call has no effect. This function must only be called once for a particular output configuration.  The output Surfaces included by this list of OutputConfigurations can be used as CaptureRequest targets as soon as this call returns.  This method is not supported by LEGACY-level devices.   ", "parameters": [{"scri": "List: a list of OutputConfigurations that            have had addSurface invoked with a valid            output Surface after createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler).", "name": "outputConfigs"}]}, {"returns": [{"scri": "true if the application can submit reprocess capture requests with this         camera capture session. false otherwise.", "type": "boolean"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "isReprocessable", "throws": null, "funcname": "boolean isReprocessable ()", "descri": "  Return if the application can submit reprocess capture requests with this camera capture session.   See also: createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler)", "parameters": null}, {"returns": null, "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "prepare", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "if the Surface is invalid, not part of this Session, or has                                  already been used as a target of a CaptureRequest in this                                  session or immediately prior sessions.", "type": "IllegalArgumentException"}], "funcname": "void prepare (Surface surface)", "descri": "   Pre-allocate all buffers for an output Surface.  Normally, the image buffers for a given output Surface are allocated on-demand, to minimize startup latency and memory overhead.  However, in some cases, it may be desirable for the buffers to be allocated before any requests targeting the Surface are actually submitted to the device. Large buffers may take some time to allocate, which can result in delays in submitting requests until sufficient buffers are allocated to reach steady-state behavior. Such delays can cause bursts to take longer than desired, or cause skips or stutters in preview output.  The prepare() method can be used to perform this preallocation. It may only be called for a given output Surface before that Surface is used as a target for a request. The number of buffers allocated is the sum of the count needed by the consumer providing the output Surface, and the maximum number needed by the camera device to fill its pipeline. Since this may be a larger number than what is actually required for steady-state operation, using prepare may result in higher memory consumption than the normal on-demand behavior results in. Prepare() will also delay the time to first output to a given Surface, in exchange for smoother frame rate once the allocation is complete.  For example, an application that creates an ImageReader with a maxImages argument of 10, but only uses 3 simultaneous Images at once would normally only cause those 3 images to be allocated (plus what is needed by the camera device for smooth operation).  But using prepare() on the ImageReader Surface will result in all 10 Images being allocated. So applications using this method should take care to request only the number of buffers actually necessary for their application.  If the same output Surface is used in consecutive sessions (without closing the first session explicitly), then its already-allocated buffers are carried over, and if it was used as a target of a capture request in the first session, prepare cannot be called on it in the second session.  Once allocation is complete, onSurfacePrepared(CameraCaptureSession, Surface) will be invoked with the Surface provided to this method. Between the prepare call and the onSurfacePrepared call, the Surface provided to prepare must not be used as a target of a CaptureRequest submitted to this session.  Note that if 2 surfaces share the same stream via enableSurfaceSharing() and addSurface(Surface), prepare() only needs to be called on one surface, and {link StateCallback#onSurfacePrepared} will be triggered for both surfaces.  LEGACY devices cannot pre-allocate output buffers; for those devices, onSurfacePrepared(CameraCaptureSession, Surface) will be immediately called, and no preallocation is done.    See also: onSurfacePrepared(CameraCaptureSession, Surface)", "parameters": [{"scri": "Surface: the output Surface for which buffers should be pre-allocated. Must be one of the output Surfaces used to create this session.This value must never be null.", "name": "surface"}]}, {"returns": [{"scri": "int A unique capture sequence ID used by             onCaptureSequenceCompleted(CameraCaptureSession, int, long).", "type": "int"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        int", "name": "setRepeatingBurst", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "If the requests reference no Surfaces or reference Surfaces                                  not currently configured as outputs; or one of the requests                                  is a reprocess capture request; or one of the captures                                  targets a Surface in the middle of being                                  prepared; or the handler is null, the                                  listener is not null, and the calling thread has no looper;                                  or no requests were passed in.", "type": "IllegalArgumentException"}], "funcname": "int setRepeatingBurst (List<CaptureRequest> requests,                 CameraCaptureSession.CaptureCallback listener,                 Handler handler)", "descri": "   Request endlessly repeating capture of a sequence of images by this capture session.  With this method, the camera device will continually capture images, cycling through the settings in the provided list of CaptureRequests, at the maximum rate possible.  If a request is submitted through capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) or captureBurst(List, CameraCaptureSession.CaptureCallback, Handler), the current repetition of the request list will be completed before the higher-priority request is handled. This guarantees that the application always receives a complete repeat burst captured in minimal time, instead of bursts interleaved with higher-priority captures, or incomplete captures.  Repeating burst requests are a simple way for an application to maintain a preview or other continuous stream of frames where each request is different in a predicatable way, without having to continually submit requests through captureBurst(List, CameraCaptureSession.CaptureCallback, Handler).  To stop the repeating capture, call stopRepeating(). Any ongoing burst will still be completed, however. Calling abortCaptures() will also clear the request.  Calling this method will replace a previously-set repeating request or burst set up by this method or setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler), although any in-progress burst will be completed before the new repeat burst will be used.  This method does not support reprocess capture requests because each reprocess CaptureRequest must be created from the TotalCaptureResult that matches the input image to be reprocessed. This is either the TotalCaptureResult of capture that is sent for reprocessing, or one of the TotalCaptureResults of a set of captures, when data from the whole set is combined by the application into a single reprocess input image. The request must be capturing images from the camera. If a reprocess capture request is submitted, this method will throw IllegalArgumentException.     See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)stopRepeating()abortCaptures()", "parameters": [{"scri": "List: the list of requests to cycle through indefinitelyThis value must never be null.", "name": "requests"}, {"scri": "CameraCaptureSession.CaptureCallback: The callback object to notify each time one of the requests in the repeating bursts has finished processing. If null, no metadata will be produced for this stream of requests, although image data will still be produced.", "name": "listener"}, {"scri": "Handler: the handler on which the listener should be invoked, or null to use the current thread's looper.", "name": "handler"}]}, {"returns": [{"scri": "int A unique capture sequence ID used by             onCaptureSequenceCompleted(CameraCaptureSession, int, long).", "type": "int"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "int", "name": "setRepeatingBurstRequests", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "If the requests reference no Surfaces or reference Surfaces                                  not currently configured as outputs; or one of the requests                                  is a reprocess capture request; or one of the captures                                  targets a Surface in the middle of being                                  prepared; or the executor is null; or the                                  listener is null.", "type": "IllegalArgumentException"}], "funcname": "int setRepeatingBurstRequests (List<CaptureRequest> requests,                 Executor executor,                 CameraCaptureSession.CaptureCallback listener)", "descri": "   Request endlessly repeating capture of a sequence of images by this capture session.  The behavior of this method matches that of setRepeatingBurst(List, CaptureCallback, Handler), except that it uses Executor as an argument instead of Handler.     See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)stopRepeating()abortCaptures()", "parameters": [{"scri": "List: the list of requests to cycle through indefinitelyThis value must never be null.", "name": "requests"}, {"scri": "Executor: the executor which will be used for invoking the listener.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraCaptureSession.CaptureCallback: The callback object to notify each time one of the requests in the repeating bursts has finished processing.This value must never be null.", "name": "listener"}]}, {"returns": [{"scri": "int A unique capture sequence ID used by             onCaptureSequenceCompleted(CameraCaptureSession, int, long).", "type": "int"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        int", "name": "setRepeatingRequest", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "If the request references no Surfaces or references Surfaces                                  that are not currently configured as outputs; or the request                                  is a reprocess capture request; or the capture targets a                                  Surface in the middle of being prepared; or                                  the handler is null, the listener is not null, and the                                  calling thread has no looper; or no requests were passed in.", "type": "IllegalArgumentException"}], "funcname": "int setRepeatingRequest (CaptureRequest request,                 CameraCaptureSession.CaptureCallback listener,                 Handler handler)", "descri": "  Request endlessly repeating capture of images by this capture session. With this method, the camera device will continually capture images using the settings in the provided CaptureRequest, at the maximum rate possible.  Repeating requests are a simple way for an application to maintain a preview or other continuous stream of frames, without having to continually submit identical requests through capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler).  Repeat requests have lower priority than those submitted through capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) or captureBurst(List, CameraCaptureSession.CaptureCallback, Handler), so if capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) is called when a repeating request is active, the capture request will be processed before any further repeating requests are processed.  To stop the repeating capture, call stopRepeating(). Calling abortCaptures() will also clear the request.  Calling this method will replace any earlier repeating request or burst set up by this method or setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler), although any in-progress burst will be completed before the new repeat request will be used.  This method does not support reprocess capture requests because each reprocess CaptureRequest must be created from the TotalCaptureResult that matches the input image to be reprocessed. This is either the TotalCaptureResult of capture that is sent for reprocessing, or one of the TotalCaptureResults of a set of captures, when data from the whole set is combined by the application into a single reprocess input image. The request must be capturing images from the camera. If a reprocess capture request is submitted, this method will throw IllegalArgumentException.     See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)stopRepeating()abortCaptures()", "parameters": [{"scri": "CaptureRequest: the request to repeat indefinitelyThis value must never be null.", "name": "request"}, {"scri": "CameraCaptureSession.CaptureCallback: The callback object to notify every time the request finishes processing. If null, no metadata will be produced for this stream of requests, although image data will still be produced.", "name": "listener"}, {"scri": "Handler: the handler on which the listener should be invoked, or null to use the current thread's looper.", "name": "handler"}]}, {"returns": [{"scri": "int A unique capture sequence ID used by             onCaptureSequenceCompleted(CameraCaptureSession, int, long).", "type": "int"}], "class": "android.hardware.camera2.CameraDevice\n", "type": "int", "name": "setSingleRepeatingRequest", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}, {"scri": "If the request references no Surfaces or references Surfaces                                  that are not currently configured as outputs; or the request                                  is a reprocess capture request; or the capture targets a                                  Surface in the middle of being prepared; or                                  the executor is null; or the listener is null.", "type": "IllegalArgumentException"}], "funcname": "int setSingleRepeatingRequest (CaptureRequest request,                 Executor executor,                 CameraCaptureSession.CaptureCallback listener)", "descri": "  Request endlessly repeating capture of images by this capture session. The behavior of this method matches that of setRepeatingRequest(CaptureRequest, CaptureCallback, Handler), except that it uses Executor as an argument instead of Handler.     See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)stopRepeating()abortCaptures()", "parameters": [{"scri": "CaptureRequest: the request to repeat indefinitelyThis value must never be null.", "name": "request"}, {"scri": "Executor: the executor which will be used for invoking the listener.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraCaptureSession.CaptureCallback: The callback object to notify every time the request finishes processing.This value must never be null.", "name": "listener"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "stopRepeating", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error", "type": "CameraAccessException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}], "funcname": "void stopRepeating ()", "descri": "   Cancel any ongoing repeating capture set by either setRepeatingRequest or setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler). Has no effect on requests submitted through capture or captureBurst.  Any currently in-flight captures will still complete, as will any burst that is mid-capture. To ensure that the device has finished processing all of its capture requests and is in ready state, wait for the onReady(CameraCaptureSession) callback after calling this method.   See also: setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)ERROR(/StateCallback#onIdle)", "parameters": null}, {"returns": null, "class": "android.hardware.camera2.CameraDevice\n", "type": "void", "name": "updateOutputConfiguration", "throws": [{"scri": "if the camera device is no longer connected or has                               encountered a fatal error.", "type": "CameraAccessException"}, {"scri": "if an attempt was made to add a Surface already                               in use by another buffer-producing API, such as MediaCodec or                               a different camera device or OutputConfiguration; or                               new surfaces are not compatible (see                               enableSurfaceSharing()); or a                               Surface that was removed from the modified                               OutputConfiguration still has pending requests.", "type": "IllegalArgumentException"}, {"scri": "if this session is no longer active, either because the session                               was explicitly closed, a new session has been created                               or the camera device has been closed.", "type": "IllegalStateException"}], "funcname": "void updateOutputConfiguration (OutputConfiguration config)", "descri": "  Update OutputConfiguration after configuration finalization see finalizeOutputConfigurations(List). Any OutputConfiguration that has been modified via calls to addSurface(Surface) or removeSurface(Surface) must be updated. After the update call returns without throwing exceptions any newly added surfaces can be referenced in subsequent capture requests.  Surfaces that get removed must not be part of any active repeating or single/burst request or have any pending results. Consider updating any repeating requests first via setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) or setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler) and then wait for the last frame number when the sequence completes onCaptureSequenceCompleted(CameraCaptureSession, int, long) before calling updateOutputConfiguration to remove a previously active Surface.  Surfaces that get added must not be part of any other registered OutputConfiguration.   ", "parameters": [{"scri": "OutputConfiguration: Modified output configuration.", "name": "config"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureBufferLost", "throws": null, "funcname": "void onCaptureBufferLost (CameraCaptureSession session,                 CaptureRequest request,                 Surface target,                 long frameNumber)", "descri": "   This method is called if a single buffer for a capture could not be sent to its destination surface.  If the whole capture failed, then onCaptureFailed(CameraCaptureSession, CaptureRequest, CaptureFailure) will be called instead. If some but not all buffers were captured but the result metadata will not be available, then onCaptureFailed will be invoked with wasImageCaptured() returning true, along with one or more calls to onCaptureBufferLost(CameraCaptureSession, CaptureRequest, Surface, long) for the failed outputs. ", "parameters": [{"scri": "CameraCaptureSession: The session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "Surface: The target Surface that the buffer will not be produced forThis value must never be null.", "name": "target"}, {"scri": "long: The frame number for the request", "name": "frameNumber"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureBufferLost", "throws": null, "funcname": "void onCaptureBufferLost (CameraCaptureSession session,                 CaptureRequest request,                 Surface target,                 long frameNumber)", "descri": "   This method is called if a single buffer for a capture could not be sent to its destination surface.  If the whole capture failed, then onCaptureFailed(CameraCaptureSession, CaptureRequest, CaptureFailure) will be called instead. If some but not all buffers were captured but the result metadata will not be available, then onCaptureFailed will be invoked with wasImageCaptured() returning true, along with one or more calls to onCaptureBufferLost(CameraCaptureSession, CaptureRequest, Surface, long) for the failed outputs. ", "parameters": [{"scri": "CameraCaptureSession: The session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "Surface: The target Surface that the buffer will not be produced forThis value must never be null.", "name": "target"}, {"scri": "long: The frame number for the request", "name": "frameNumber"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureCompleted", "throws": null, "funcname": "void onCaptureCompleted (CameraCaptureSession session,                 CaptureRequest request,                 TotalCaptureResult result)", "descri": "  This method is called when an image capture has fully completed and all the result metadata is available. This callback will always fire after the last onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult); in other words, no more partial results will be delivered once the completed result is available.  For performance-intensive use-cases where latency is a factor, consider using onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult) instead.  The default implementation of this method does nothing.   See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)", "parameters": [{"scri": "CameraCaptureSession: the session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "TotalCaptureResult: The total output metadata from the capture, including the final capture parameters and the state of the camera system during capture.This value must never be null.", "name": "result"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureCompleted", "throws": null, "funcname": "void onCaptureCompleted (CameraCaptureSession session,                 CaptureRequest request,                 TotalCaptureResult result)", "descri": "  This method is called when an image capture has fully completed and all the result metadata is available. This callback will always fire after the last onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult); in other words, no more partial results will be delivered once the completed result is available.  For performance-intensive use-cases where latency is a factor, consider using onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult) instead.  The default implementation of this method does nothing.   See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)", "parameters": [{"scri": "CameraCaptureSession: the session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "TotalCaptureResult: The total output metadata from the capture, including the final capture parameters and the state of the camera system during capture.This value must never be null.", "name": "result"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureCompleted", "throws": null, "funcname": "void onCaptureCompleted (CameraCaptureSession session,                 CaptureRequest request,                 TotalCaptureResult result)", "descri": "  This method is called when an image capture has fully completed and all the result metadata is available. This callback will always fire after the last onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult); in other words, no more partial results will be delivered once the completed result is available.  For performance-intensive use-cases where latency is a factor, consider using onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult) instead.  The default implementation of this method does nothing.   See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)", "parameters": [{"scri": "CameraCaptureSession: the session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "TotalCaptureResult: The total output metadata from the capture, including the final capture parameters and the state of the camera system during capture.This value must never be null.", "name": "result"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureFailed", "throws": null, "funcname": "void onCaptureFailed (CameraCaptureSession session,                 CaptureRequest request,                 CaptureFailure failure)", "descri": "  This method is called instead of onCaptureCompleted(CameraCaptureSession, CaptureRequest, TotalCaptureResult) when the camera device failed to produce a CaptureResult for the request. Other requests are unaffected, and some or all image buffers from the capture may have been pushed to their respective output streams.  The default implementation of this method does nothing.   See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)", "parameters": [{"scri": "CameraCaptureSession: The session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "CaptureFailure: The output failure from the capture, including the failure reason            and the frame number.This value must never be null.", "name": "failure"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureFailed", "throws": null, "funcname": "void onCaptureFailed (CameraCaptureSession session,                 CaptureRequest request,                 CaptureFailure failure)", "descri": "  This method is called instead of onCaptureCompleted(CameraCaptureSession, CaptureRequest, TotalCaptureResult) when the camera device failed to produce a CaptureResult for the request. Other requests are unaffected, and some or all image buffers from the capture may have been pushed to their respective output streams.  The default implementation of this method does nothing.   See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)", "parameters": [{"scri": "CameraCaptureSession: The session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "CaptureFailure: The output failure from the capture, including the failure reason            and the frame number.This value must never be null.", "name": "failure"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureProgressed", "throws": null, "funcname": "void onCaptureProgressed (CameraCaptureSession session,                 CaptureRequest request,                 CaptureResult partialResult)", "descri": "  This method is called when an image capture makes partial forward progress; some (but not all) results from an image capture are available. The result provided here will contain some subset of the fields of a full result. Multiple onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult) calls may happen per capture; a given result field will only be present in one partial capture at most. The final onCaptureCompleted(CameraCaptureSession, CaptureRequest, TotalCaptureResult) call will always contain all the fields (in particular, the union of all the fields of all the partial results composing the total result).  For each request, some result data might be available earlier than others. The typical delay between each partial result (per request) is a single frame interval. For performance-oriented use-cases, applications should query the metadata they need to make forward progress from the partial results and avoid waiting for the completed result.  For a particular request, onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult) may happen before or after onCaptureStarted(CameraCaptureSession, CaptureRequest, long, long).  Each request will generate at least 1 partial results, and at most REQUEST_PARTIAL_RESULT_COUNT partial results.  Depending on the request settings, the number of partial results per request will vary, although typically the partial count could be the same as long as the camera device subsystems enabled stay the same.  The default implementation of this method does nothing.   See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)", "parameters": [{"scri": "CameraCaptureSession: the session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "CaptureResult: The partial output metadata from the capture, which includes a subset of the TotalCaptureResult fields.This value must never be null.", "name": "partialResult"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureProgressed", "throws": null, "funcname": "void onCaptureProgressed (CameraCaptureSession session,                 CaptureRequest request,                 CaptureResult partialResult)", "descri": "  This method is called when an image capture makes partial forward progress; some (but not all) results from an image capture are available. The result provided here will contain some subset of the fields of a full result. Multiple onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult) calls may happen per capture; a given result field will only be present in one partial capture at most. The final onCaptureCompleted(CameraCaptureSession, CaptureRequest, TotalCaptureResult) call will always contain all the fields (in particular, the union of all the fields of all the partial results composing the total result).  For each request, some result data might be available earlier than others. The typical delay between each partial result (per request) is a single frame interval. For performance-oriented use-cases, applications should query the metadata they need to make forward progress from the partial results and avoid waiting for the completed result.  For a particular request, onCaptureProgressed(CameraCaptureSession, CaptureRequest, CaptureResult) may happen before or after onCaptureStarted(CameraCaptureSession, CaptureRequest, long, long).  Each request will generate at least 1 partial results, and at most REQUEST_PARTIAL_RESULT_COUNT partial results.  Depending on the request settings, the number of partial results per request will vary, although typically the partial count could be the same as long as the camera device subsystems enabled stay the same.  The default implementation of this method does nothing.   See also: capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)captureBurst(List, CameraCaptureSession.CaptureCallback, Handler)setRepeatingRequest(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler)setRepeatingBurst(List, CameraCaptureSession.CaptureCallback, Handler)", "parameters": [{"scri": "CameraCaptureSession: the session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: The request that was given to the CameraDeviceThis value must never be null.", "name": "request"}, {"scri": "CaptureResult: The partial output metadata from the capture, which includes a subset of the TotalCaptureResult fields.This value must never be null.", "name": "partialResult"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureSequenceAborted", "throws": null, "funcname": "void onCaptureSequenceAborted (CameraCaptureSession session,                 int sequenceId)", "descri": "  This method is called independently of the others in CaptureCallback, when a capture sequence aborts before any CaptureResult or CaptureFailure for it have been returned via this listener. Due to the asynchronous nature of the camera device, not all submitted captures are immediately processed. It is possible to clear out the pending requests by a variety of operations such as stopRepeating() or abortCaptures(). When such an event happens, onCaptureSequenceCompleted(CameraCaptureSession, int, long) will not be called.  The default implementation does nothing.   See also: getFrameNumber()getFrameNumber()getSequenceId()getSequenceId()onCaptureSequenceCompleted(CameraCaptureSession, int, long)", "parameters": [{"scri": "CameraCaptureSession: The session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "int: A sequence ID returned by the capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) family of functions.", "name": "sequenceId"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureSequenceAborted", "throws": null, "funcname": "void onCaptureSequenceAborted (CameraCaptureSession session,                 int sequenceId)", "descri": "  This method is called independently of the others in CaptureCallback, when a capture sequence aborts before any CaptureResult or CaptureFailure for it have been returned via this listener. Due to the asynchronous nature of the camera device, not all submitted captures are immediately processed. It is possible to clear out the pending requests by a variety of operations such as stopRepeating() or abortCaptures(). When such an event happens, onCaptureSequenceCompleted(CameraCaptureSession, int, long) will not be called.  The default implementation does nothing.   See also: getFrameNumber()getFrameNumber()getSequenceId()getSequenceId()onCaptureSequenceCompleted(CameraCaptureSession, int, long)", "parameters": [{"scri": "CameraCaptureSession: The session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "int: A sequence ID returned by the capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) family of functions.", "name": "sequenceId"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureSequenceCompleted", "throws": null, "funcname": "void onCaptureSequenceCompleted (CameraCaptureSession session,                 int sequenceId,                 long frameNumber)", "descri": "  This method is called independently of the others in CaptureCallback, when a capture sequence finishes and all CaptureResult or CaptureFailure for it have been returned via this listener. In total, there will be at least one result/failure returned by this listener before this callback is invoked. If the capture sequence is aborted before any requests have been processed, onCaptureSequenceAborted(CameraCaptureSession, int) is invoked instead.  The default implementation does nothing.   See also: getFrameNumber()getFrameNumber()getSequenceId()getSequenceId()onCaptureSequenceAborted(CameraCaptureSession, int)", "parameters": [{"scri": "CameraCaptureSession: The session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "int: A sequence ID returned by the capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) family of functions.", "name": "sequenceId"}, {"scri": "long: The last frame number (returned by getFrameNumber()            or getFrameNumber()) in the capture sequence.", "name": "frameNumber"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureSequenceCompleted", "throws": null, "funcname": "void onCaptureSequenceCompleted (CameraCaptureSession session,                 int sequenceId,                 long frameNumber)", "descri": "  This method is called independently of the others in CaptureCallback, when a capture sequence finishes and all CaptureResult or CaptureFailure for it have been returned via this listener. In total, there will be at least one result/failure returned by this listener before this callback is invoked. If the capture sequence is aborted before any requests have been processed, onCaptureSequenceAborted(CameraCaptureSession, int) is invoked instead.  The default implementation does nothing.   See also: getFrameNumber()getFrameNumber()getSequenceId()getSequenceId()onCaptureSequenceAborted(CameraCaptureSession, int)", "parameters": [{"scri": "CameraCaptureSession: The session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "int: A sequence ID returned by the capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) family of functions.", "name": "sequenceId"}, {"scri": "long: The last frame number (returned by getFrameNumber()            or getFrameNumber()) in the capture sequence.", "name": "frameNumber"}]}, {"returns": null, "class": "android.hardware.camera2.CameraDevice.StateCallback\n", "type": "void", "name": "onCaptureStarted", "throws": null, "funcname": "void onCaptureStarted (CameraCaptureSession session,                 CaptureRequest request,                 long timestamp,                 long frameNumber)", "descri": "  This method is called when the camera device has started capturing the output image for the request, at the beginning of image exposure, or when the camera device has started processing an input image for a reprocess request. For a regular capture request, this callback is invoked right as the capture of a frame begins, so it is the most appropriate time for playing a shutter sound, or triggering UI indicators of capture.  The request that is being used for this capture is provided, along with the actual timestamp for the start of exposure. For a reprocess request, this timestamp will be the input image's start of exposure which matches the result timestamp field of the TotalCaptureResult that was used to create the reprocess request. This timestamp matches the timestamps that will be included in the result timestamp field, and in the buffers sent to each output Surface. These buffer timestamps are accessible through, for example, Image.getTimestamp() or getTimestamp(). The frame number included is equal to the frame number that will be included in getFrameNumber().  For the simplest way to play a shutter sound camera shutter or a video recording start/stop sound, see the MediaActionSound class.  The default implementation of this method does nothing.   See also: MediaActionSound", "parameters": [{"scri": "CameraCaptureSession: the session returned by createCaptureSession(SessionConfiguration)This value must never be null.", "name": "session"}, {"scri": "CaptureRequest: the request for the capture that just begunThis value must never be null.", "name": "request"}, {"scri": "long: the timestamp at start of capture for a regular request, or                  the timestamp at the input image's start of capture for a                  reprocess request, in nanoseconds.", "name": "timestamp"}, {"scri": "long: the frame number for this capture", "name": "frameNumber"}]}, {"returns": null, "class": "android.hardware.camera2.CameraManager.TorchCallback\n", "type": "void", "name": "onClosed", "throws": null, "funcname": "void onClosed (CameraDevice camera)", "descri": "  The method called when a camera device has been closed with close(). Any attempt to call methods on this CameraDevice in the future will throw a IllegalStateException.  The default implementation of this method does nothing. ", "parameters": [{"scri": "CameraDevice: the camera device that has become closedThis value must never be null.", "name": "camera"}]}, {"returns": null, "class": "android.hardware.camera2.CameraManager.TorchCallback\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onDisconnected", "throws": null, "funcname": "void onDisconnected (CameraDevice camera)", "descri": "  The method called when a camera device is no longer available for use. This callback may be called instead of onOpened(CameraDevice) if opening the camera fails.  Any attempt to call methods on this CameraDevice will throw a CameraAccessException. The disconnection could be due to a change in security policy or permissions; the physical disconnection of a removable camera device; or the camera being needed for a higher-priority camera API client.  There may still be capture callbacks that are invoked after this method is called, or new image buffers that are delivered to active outputs.  The default implementation logs a notice to the system log about the disconnection.  You should clean up the camera with close() after this happens, as it is not recoverable until the camera can be opened again. For most use cases, this will be when the camera again becomes available. ", "parameters": [{"scri": "CameraDevice: the device that has been disconnectedThis value must never be null.", "name": "camera"}]}, {"returns": null, "class": "android.hardware.camera2.CameraManager.TorchCallback\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onError", "throws": null, "funcname": "void onError (CameraDevice camera,                 int error)", "descri": "  The method called when a camera device has encountered a serious error. This callback may be called instead of onOpened(CameraDevice) if opening the camera fails.  This indicates a failure of the camera device or camera service in some way. Any attempt to call methods on this CameraDevice in the future will throw a CameraAccessException with the CAMERA_ERROR reason.  There may still be capture completion or camera stream callbacks that will be called after this error is received.  You should clean up the camera with close() after this happens. Further attempts at recovery are error-code specific.   See also: ERROR_CAMERA_IN_USEERROR_MAX_CAMERAS_IN_USEERROR_CAMERA_DISABLEDERROR_CAMERA_DEVICEERROR_CAMERA_SERVICE", "parameters": [{"scri": "CameraDevice: The device reporting the errorThis value must never be null.", "name": "camera"}, {"scri": "int: The error code.Value is ERROR_CAMERA_IN_USE, ERROR_MAX_CAMERAS_IN_USE, ERROR_CAMERA_DISABLED, ERROR_CAMERA_DEVICE or ERROR_CAMERA_SERVICE.", "name": "error"}]}, {"returns": null, "class": "android.hardware.camera2.CameraManager.TorchCallback\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onOpened", "throws": null, "funcname": "void onOpened (CameraDevice camera)", "descri": "  The method called when a camera device has finished opening. At this point, the camera device is ready to use, and createCaptureSession(SessionConfiguration) can be called to set up the first capture session. ", "parameters": [{"scri": "CameraDevice: the camera device that has become openedThis value must never be null.", "name": "camera"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "openCamera", "throws": [{"scri": "if the camera is disabled by device policy, has been disconnected, or is being used by a higher-priority camera API client.", "type": "CameraAccessException"}, {"scri": "if cameraId or the callback was null, or the cameraId does not match any currently or previously available camera device.", "type": "IllegalArgumentException"}, {"scri": "if the application does not have permission to access the camera", "type": "SecurityException"}], "funcname": "void openCamera (String cameraId,                 CameraDevice.StateCallback callback,                 Handler handler)", "descri": "  Open a connection to a camera with the given ID. Use getCameraIdList() to get the list of available camera devices. Note that even if an id is listed, open may fail if the device is disconnected between the calls to getCameraIdList() and openCamera(String, CameraDevice.StateCallback, Handler), or if a higher-priority camera API client begins using the camera device.  As of API level 23, devices for which the onCameraUnavailable(String) callback has been called due to the device being in use by a lower-priority, background camera API client can still potentially be opened by calling this method when the calling camera API client has a higher priority than the current camera API client using this device.  In general, if the top, foreground activity is running within your application process, your process will be given the highest priority when accessing the camera, and this method will succeed even if the camera device is in use by another camera API client. Any lower-priority application that loses control of the camera in this way will receive an onDisconnected(CameraDevice) callback.  Once the camera is successfully opened, onOpened(CameraDevice) will be invoked with the newly opened CameraDevice. The camera device can then be set up for operation by calling createCaptureSession(SessionConfiguration) and createCaptureRequest(int)  Since the camera device will be opened asynchronously, any asynchronous operations done on the returned CameraDevice instance will be queued up until the device startup has completed and the callback's onOpened method is called. The pending operations are then processed in order.  If the camera becomes disconnected during initialization after this function call returns, onDisconnected(CameraDevice) with a CameraDevice in the disconnected state (and onOpened(CameraDevice) will be skipped).  If opening the camera device fails, then the device callback's onError method will be called, and subsequent calls on the camera device will throw a CameraAccessException. Requires the CAMERA permission.    See also: getCameraIdList()setCameraDisabled(ComponentName, boolean)", "parameters": [{"scri": "String: The unique identifier of the camera device to openThis value must never be null.", "name": "cameraId"}, {"scri": "CameraDevice.StateCallback: The callback which is invoked once the camera is openedThis value must never be null.", "name": "callback"}, {"scri": "Handler: The handler on which the callback should be invoked, or             null to use the current thread's looper.", "name": "handler"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "openCamera", "throws": [{"scri": "if the camera is disabled by device policy, has been disconnected, or is being used by a higher-priority camera API client.", "type": "CameraAccessException"}, {"scri": "if cameraId or the callback was null, or the cameraId does not match any currently or previously available camera device.", "type": "IllegalArgumentException"}, {"scri": "if the application does not have permission to access the camera", "type": "SecurityException"}], "funcname": "void openCamera (String cameraId,                 CameraDevice.StateCallback callback,                 Handler handler)", "descri": "  Open a connection to a camera with the given ID. Use getCameraIdList() to get the list of available camera devices. Note that even if an id is listed, open may fail if the device is disconnected between the calls to getCameraIdList() and openCamera(String, CameraDevice.StateCallback, Handler), or if a higher-priority camera API client begins using the camera device.  As of API level 23, devices for which the onCameraUnavailable(String) callback has been called due to the device being in use by a lower-priority, background camera API client can still potentially be opened by calling this method when the calling camera API client has a higher priority than the current camera API client using this device.  In general, if the top, foreground activity is running within your application process, your process will be given the highest priority when accessing the camera, and this method will succeed even if the camera device is in use by another camera API client. Any lower-priority application that loses control of the camera in this way will receive an onDisconnected(CameraDevice) callback.  Once the camera is successfully opened, onOpened(CameraDevice) will be invoked with the newly opened CameraDevice. The camera device can then be set up for operation by calling createCaptureSession(SessionConfiguration) and createCaptureRequest(int)  Since the camera device will be opened asynchronously, any asynchronous operations done on the returned CameraDevice instance will be queued up until the device startup has completed and the callback's onOpened method is called. The pending operations are then processed in order.  If the camera becomes disconnected during initialization after this function call returns, onDisconnected(CameraDevice) with a CameraDevice in the disconnected state (and onOpened(CameraDevice) will be skipped).  If opening the camera device fails, then the device callback's onError method will be called, and subsequent calls on the camera device will throw a CameraAccessException. Requires the CAMERA permission.    See also: getCameraIdList()setCameraDisabled(ComponentName, boolean)", "parameters": [{"scri": "String: The unique identifier of the camera device to openThis value must never be null.", "name": "cameraId"}, {"scri": "CameraDevice.StateCallback: The callback which is invoked once the camera is openedThis value must never be null.", "name": "callback"}, {"scri": "Handler: The handler on which the callback should be invoked, or             null to use the current thread's looper.", "name": "handler"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "openCamera", "throws": [{"scri": "if the camera is disabled by device policy, has been disconnected, or is being used by a higher-priority camera API client.", "type": "CameraAccessException"}, {"scri": "if cameraId, the callback or the executor was null, or the cameraId does not match any currently or previously available camera device.", "type": "IllegalArgumentException"}, {"scri": "if the application does not have permission to access the camera", "type": "SecurityException"}], "funcname": "void openCamera (String cameraId,                 Executor executor,                 CameraDevice.StateCallback callback)", "descri": "  Open a connection to a camera with the given ID. The behavior of this method matches that of openCamera(String, StateCallback, Handler), except that it uses Executor as an argument instead of Handler. Requires the CAMERA permission.    See also: getCameraIdList()setCameraDisabled(ComponentName, boolean)", "parameters": [{"scri": "String: The unique identifier of the camera device to openThis value must never be null.", "name": "cameraId"}, {"scri": "Executor: The executor which will be used when invoking the callback.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraDevice.StateCallback: The callback which is invoked once the camera is openedThis value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "openCamera", "throws": [{"scri": "if the camera is disabled by device policy, has been disconnected, or is being used by a higher-priority camera API client.", "type": "CameraAccessException"}, {"scri": "if cameraId, the callback or the executor was null, or the cameraId does not match any currently or previously available camera device.", "type": "IllegalArgumentException"}, {"scri": "if the application does not have permission to access the camera", "type": "SecurityException"}], "funcname": "void openCamera (String cameraId,                 Executor executor,                 CameraDevice.StateCallback callback)", "descri": "  Open a connection to a camera with the given ID. The behavior of this method matches that of openCamera(String, StateCallback, Handler), except that it uses Executor as an argument instead of Handler. Requires the CAMERA permission.    See also: getCameraIdList()setCameraDisabled(ComponentName, boolean)", "parameters": [{"scri": "String: The unique identifier of the camera device to openThis value must never be null.", "name": "cameraId"}, {"scri": "Executor: The executor which will be used when invoking the callback.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraDevice.StateCallback: The callback which is invoked once the camera is openedThis value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "registerAvailabilityCallback", "throws": [{"scri": "if the executor is null.", "type": "IllegalArgumentException"}], "funcname": "void registerAvailabilityCallback (Executor executor,                 CameraManager.AvailabilityCallback callback)", "descri": "  Register a callback to be notified about camera device availability. The behavior of this method matches that of registerAvailabilityCallback(AvailabilityCallback, Handler), except that it uses Executor as an argument instead of Handler.   ", "parameters": [{"scri": "Executor: The executor which will be used to invoke the callback.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraManager.AvailabilityCallback: the new callback to send camera availability notices toThis value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "registerAvailabilityCallback", "throws": [{"scri": "if the handler is null but the current thread has             no looper.", "type": "IllegalArgumentException"}], "funcname": "void registerAvailabilityCallback (CameraManager.AvailabilityCallback callback,                 Handler handler)", "descri": "  Register a callback to be notified about camera device availability. Registering the same callback again will replace the handler with the new one provided.  The first time a callback is registered, it is immediately called with the availability status of all currently known camera devices.  onCameraUnavailable(String) will be called whenever a camera device is opened by any camera API client. As of API level 23, other camera API clients may still be able to open such a camera device, evicting the existing client if they have higher priority than the existing client of a camera device. See open() for more details.  Since this callback will be registered with the camera service, remember to unregister it once it is no longer needed; otherwise the callback will continue to receive events indefinitely and it may prevent other resources from being released. Specifically, the callbacks will be invoked independently of the general activity lifecycle and independently of the state of individual CameraManager instances.   ", "parameters": [{"scri": "CameraManager.AvailabilityCallback: the new callback to send camera availability notices toThis value must never be null.", "name": "callback"}, {"scri": "Handler: The handler on which the callback should be invoked, or null to use             the current thread's looper.", "name": "handler"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "registerTorchCallback", "throws": [{"scri": "if the handler is null but the current thread has             no looper.", "type": "IllegalArgumentException"}], "funcname": "void registerTorchCallback (CameraManager.TorchCallback callback,                 Handler handler)", "descri": "  Register a callback to be notified about torch mode status. Registering the same callback again will replace the handler with the new one provided.  The first time a callback is registered, it is immediately called with the torch mode status of all currently known camera devices with a flash unit.  Since this callback will be registered with the camera service, remember to unregister it once it is no longer needed; otherwise the callback will continue to receive events indefinitely and it may prevent other resources from being released. Specifically, the callbacks will be invoked independently of the general activity lifecycle and independently of the state of individual CameraManager instances.   ", "parameters": [{"scri": "CameraManager.TorchCallback: The new callback to send torch mode status toThis value must never be null.", "name": "callback"}, {"scri": "Handler: The handler on which the callback should be invoked, or null to use             the current thread's looper.", "name": "handler"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "registerTorchCallback", "throws": [{"scri": "if the executor is null.", "type": "IllegalArgumentException"}], "funcname": "void registerTorchCallback (Executor executor,                 CameraManager.TorchCallback callback)", "descri": "  Register a callback to be notified about torch mode status. The behavior of this method matches that of registerTorchCallback(TorchCallback, Handler), except that it uses Executor as an argument instead of Handler.   ", "parameters": [{"scri": "Executor: The executor which will be used to invoke the callbackThis value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraManager.TorchCallback: The new callback to send torch mode status toThis value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "setTorchMode", "throws": [{"scri": "if it failed to access the flash unit.             CAMERA_IN_USE will be thrown if the camera device             is in use. MAX_CAMERAS_IN_USE will be thrown if             other camera resources needed to turn on the torch mode are in use.             CAMERA_DISCONNECTED will be thrown if camera             service is not available.", "type": "CameraAccessException"}, {"scri": "if cameraId was null, cameraId doesn't match any currently             or previously available camera device, or the camera device doesn't have a             flash unit.", "type": "IllegalArgumentException"}], "funcname": "void setTorchMode (String cameraId,                 boolean enabled)", "descri": "  Set the flash unit's torch mode of the camera of the given ID without opening the camera device. Use getCameraIdList() to get the list of available camera devices and use getCameraCharacteristics(String) to check whether the camera device has a flash unit. Note that even if a camera device has a flash unit, turning on the torch mode may fail if the camera device or other camera resources needed to turn on the torch mode are in use.  If setTorchMode(String, boolean) is called to turn on or off the torch mode successfully, onTorchModeChanged(String, boolean) will be invoked. However, even if turning on the torch mode is successful, the application does not have the exclusive ownership of the flash unit or the camera device. The torch mode will be turned off and becomes unavailable when the camera device that the flash unit belongs to becomes unavailable or when other camera resources to keep the torch on become unavailable ( onTorchModeUnavailable(String) will be invoked). Also, other applications are free to call setTorchMode(String, boolean) to turn off the torch mode ( onTorchModeChanged(String, boolean) will be invoked). If the latest application that turned on the torch mode exits, the torch mode will be turned off.   ", "parameters": [{"scri": "String: The unique identifier of the camera device that the flash unit belongs to.This value must never be null.", "name": "cameraId"}, {"scri": "boolean: The desired state of the torch mode for the target camera device. Set to             true to turn on the torch mode. Set to false to turn off the             torch mode.", "name": "enabled"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "setTorchMode", "throws": [{"scri": "if it failed to access the flash unit.             CAMERA_IN_USE will be thrown if the camera device             is in use. MAX_CAMERAS_IN_USE will be thrown if             other camera resources needed to turn on the torch mode are in use.             CAMERA_DISCONNECTED will be thrown if camera             service is not available.", "type": "CameraAccessException"}, {"scri": "if cameraId was null, cameraId doesn't match any currently             or previously available camera device, or the camera device doesn't have a             flash unit.", "type": "IllegalArgumentException"}], "funcname": "void setTorchMode (String cameraId,                 boolean enabled)", "descri": "  Set the flash unit's torch mode of the camera of the given ID without opening the camera device. Use getCameraIdList() to get the list of available camera devices and use getCameraCharacteristics(String) to check whether the camera device has a flash unit. Note that even if a camera device has a flash unit, turning on the torch mode may fail if the camera device or other camera resources needed to turn on the torch mode are in use.  If setTorchMode(String, boolean) is called to turn on or off the torch mode successfully, onTorchModeChanged(String, boolean) will be invoked. However, even if turning on the torch mode is successful, the application does not have the exclusive ownership of the flash unit or the camera device. The torch mode will be turned off and becomes unavailable when the camera device that the flash unit belongs to becomes unavailable or when other camera resources to keep the torch on become unavailable ( onTorchModeUnavailable(String) will be invoked). Also, other applications are free to call setTorchMode(String, boolean) to turn off the torch mode ( onTorchModeChanged(String, boolean) will be invoked). If the latest application that turned on the torch mode exits, the torch mode will be turned off.   ", "parameters": [{"scri": "String: The unique identifier of the camera device that the flash unit belongs to.This value must never be null.", "name": "cameraId"}, {"scri": "boolean: The desired state of the torch mode for the target camera device. Set to             true to turn on the torch mode. Set to false to turn off the             torch mode.", "name": "enabled"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "unregisterAvailabilityCallback", "throws": null, "funcname": "void unregisterAvailabilityCallback (CameraManager.AvailabilityCallback callback)", "descri": "  Remove a previously-added callback; the callback will no longer receive connection and disconnection callbacks. Removing a callback that isn't registered has no effect. ", "parameters": [{"scri": "CameraManager.AvailabilityCallback: The callback to remove from the notification listThis value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.hardware.camera2.CameraMetadata\n", "type": "void", "name": "unregisterTorchCallback", "throws": null, "funcname": "void unregisterTorchCallback (CameraManager.TorchCallback callback)", "descri": "  Remove a previously-added callback; the callback will no longer receive torch mode status callbacks. Removing a callback that isn't registered has no effect. ", "parameters": [{"scri": "CameraManager.TorchCallback: The callback to remove from the notification listThis value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.hardware.camera2.CaptureRequest\n", "type": "void", "name": "onCameraAvailable", "throws": null, "funcname": "void onCameraAvailable (String cameraId)", "descri": "  A new camera has become available to use. The default implementation of this method does nothing. ", "parameters": [{"scri": "String: The unique identifier of the new camera.This value must never be null.", "name": "cameraId"}]}, {"returns": null, "class": "android.hardware.camera2.CaptureRequest\n", "type": "void", "name": "onCameraUnavailable", "throws": null, "funcname": "void onCameraUnavailable (String cameraId)", "descri": "  A previously-available camera has become unavailable for use. If an application had an active CameraDevice instance for the now-disconnected camera, that application will receive a disconnection error.  The default implementation of this method does nothing. ", "parameters": [{"scri": "String: The unique identifier of the disconnected camera.This value must never be null.", "name": "cameraId"}]}, {"returns": null, "class": "android.hardware.camera2.CaptureRequest.Builder\n", "type": "void", "name": "onTorchModeChanged", "throws": null, "funcname": "void onTorchModeChanged (String cameraId,                 boolean enabled)", "descri": "  A camera's torch mode has become enabled or disabled and can be changed via setTorchMode(String, boolean). The default implementation of this method does nothing. ", "parameters": [{"scri": "String: The unique identifier of the camera whose torch mode has been changed.This value must never be null.", "name": "cameraId"}, {"scri": "boolean: The state that the torch mode of the camera has been changed to.                true when the torch mode has become on and available to be turned                off. false when the torch mode has becomes off and available to                be turned on.", "name": "enabled"}]}, {"returns": null, "class": "android.hardware.camera2.CaptureRequest.Builder\n", "type": "void", "name": "onTorchModeChanged", "throws": null, "funcname": "void onTorchModeChanged (String cameraId,                 boolean enabled)", "descri": "  A camera's torch mode has become enabled or disabled and can be changed via setTorchMode(String, boolean). The default implementation of this method does nothing. ", "parameters": [{"scri": "String: The unique identifier of the camera whose torch mode has been changed.This value must never be null.", "name": "cameraId"}, {"scri": "boolean: The state that the torch mode of the camera has been changed to.                true when the torch mode has become on and available to be turned                off. false when the torch mode has becomes off and available to                be turned on.", "name": "enabled"}]}, {"returns": null, "class": "android.hardware.camera2.CaptureRequest.Builder\n", "type": "void", "name": "onTorchModeUnavailable", "throws": null, "funcname": "void onTorchModeUnavailable (String cameraId)", "descri": "  A camera's torch mode has become unavailable to set via setTorchMode(String, boolean). If torch mode was previously turned on by calling setTorchMode(String, boolean), it will be turned off before onTorchModeUnavailable(String) is invoked. setTorchMode(String, boolean) will fail until the torch mode has entered a disabled or enabled state again.  The default implementation of this method does nothing. ", "parameters": [{"scri": "String: The unique identifier of the camera whose torch mode has become                 unavailable.This value must never be null.", "name": "cameraId"}]}, {"returns": [{"scri": "long frame number", "type": "long"}], "class": "android.hardware.camera2.CaptureResult\n", "type": "long", "name": "getFrameNumber", "throws": null, "funcname": "long getFrameNumber ()", "descri": "  Get the frame number associated with this failed capture. Whenever a request has been processed, regardless of failed capture or success, it gets a unique frame number assigned to its future result/failed capture.  This value monotonically increments, starting with 0, for every new result or failure; and the scope is the lifetime of the CameraDevice. ", "parameters": null}, {"returns": [{"scri": "int The ID for the sequence of requests that this capture failure is the result of", "type": "int"}], "class": "android.hardware.camera2.CaptureResult\n", "type": "int", "name": "getSequenceId", "throws": null, "funcname": "int getSequenceId ()", "descri": "  The sequence ID for this failed capture that was returned by the capture(CaptureRequest, CameraCaptureSession.CaptureCallback, Handler) family of functions. The sequence ID is a unique monotonically increasing value starting from 0, incremented every time a new group of requests is submitted to the CameraDevice.   See also: ERROR(/CameraDevice.CaptureCallback#onCaptureSequenceCompleted)", "parameters": null}, {"returns": [{"scri": "boolean True if the image was captured, false otherwise.", "type": "boolean"}], "class": "android.hardware.camera2.CaptureResult\n", "type": "boolean", "name": "wasImageCaptured", "throws": null, "funcname": "boolean wasImageCaptured ()", "descri": "  Determine if the image was captured from the camera. If the image was not captured, no image buffers will be available. If the image was captured, then image buffers may be available. ", "parameters": null}, {"returns": null, "class": "android.hardware.camera2.CaptureResult.Key\n", "type": "void", "name": "addTarget", "throws": null, "funcname": "void addTarget (Surface outputTarget)", "descri": "   Add a surface to the list of targets for this request  The Surface added must be one of the surfaces included in the most recent call to createCaptureSession(SessionConfiguration), when the request is given to the camera device.  Adding a target more than once has no effect. ", "parameters": [{"scri": "Surface: Surface to use as an output target for this requestThis value must never be null.", "name": "outputTarget"}]}, {"returns": [{"scri": "The value of that key, or null if the field is not set.", "type": "T"}], "class": "android.hardware.camera2.CaptureResult.Key\n", "type": "<T>\n        T", "name": "getPhysicalCameraKey", "throws": [{"scri": "if the key or physical camera id were not valid", "type": "IllegalArgumentException"}], "funcname": "T getPhysicalCameraKey (Key<T> key,                 String physicalCameraId)", "descri": "  Get a capture request field value for a specific physical camera Id. The field definitions can be found in CaptureRequest. This method can be called for logical camera devices, which are devices that have REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA capability and calls to getPhysicalCameraIds() return a non-empty list of physical devices that are backing the logical camera. The camera Id included in the 'physicalCameraId' argument selects an individual physical device and returns its specific capture request field.    ", "parameters": [{"scri": "Key: The metadata field to read.", "name": "key"}, {"scri": "String: A valid physical camera Id. The valid camera Ids can be obtained                         via calls to getPhysicalCameraIds().This value must never be null.", "name": "physicalCameraId"}]}, {"returns": null, "class": "android.hardware.camera2.CaptureResult.Key\n", "type": "<T>\n        void", "name": "set", "throws": null, "funcname": "void set (Key<T> key,                 T value)", "descri": "  Set a capture request field to a value. The field definitions can be found in CaptureRequest. Setting a field to null will remove that field from the capture request. Unless the field is optional, removing it will likely produce an error from the camera device when the request is submitted. ", "parameters": [{"scri": "Key: The metadata field to write.This value must never be null.", "name": "key"}, {"scri": "T: The value to set the field to, which must be of a matching type to the key.", "name": "value"}]}, {"returns": null, "class": "android.hardware.camera2.CaptureResult.Key\n", "type": "void", "name": "setTag", "throws": null, "funcname": "void setTag (Object tag)", "descri": "  Set a tag for this request. This tag is not used for anything by the camera device, but can be used by an application to easily identify a CaptureRequest when it is returned by CaptureCallback.onCaptureCompleted   See also: getTag()", "parameters": [{"scri": "Object: an arbitrary Object to store with this requestThis value may be null.", "name": "tag"}]}, {"returns": null, "class": "android.hardware.camera2.params.ColorSpaceTransform\n", "type": "DngCreator", "name": "DngCreator", "throws": null, "funcname": "DngCreator (CameraCharacteristics characteristics,                 CaptureResult metadata)", "descri": "  Create a new DNG object. It is not necessary to call any set methods to write a well-formatted DNG file.  DNG metadata tags will be generated from the corresponding parameters in the CaptureResult object.  For best quality DNG files, it is strongly recommended that lens shading map output is enabled if supported. See STATISTICS_LENS_SHADING_MAP_MODE. ", "parameters": [{"scri": "CameraCharacteristics: an object containing the static          CameraCharacteristics.This value must never be null.", "name": "characteristics"}, {"scri": "CaptureResult: a metadata object to generate tags from.This value must never be null.", "name": "metadata"}]}, {"returns": null, "class": "android.hardware.camera2.params.ColorSpaceTransform\n", "name": "DngCreator", "throws": null, "funcname": "DngCreator (CameraCharacteristics characteristics,                 CaptureResult metadata)", "parameters": [{"scri": "CameraCharacteristics: an object containing the static          CameraCharacteristics.This value must never be null.", "name": "characteristics"}, {"scri": "CaptureResult: a metadata object to generate tags from.This value must never be null.", "name": "metadata"}], "descri": "  Create a new DNG object. It is not necessary to call any set methods to write a well-formatted DNG file.  DNG metadata tags will be generated from the corresponding parameters in the CaptureResult object.  For best quality DNG files, it is strongly recommended that lens shading map output is enabled if supported. See STATISTICS_LENS_SHADING_MAP_MODE. "}, {"returns": null, "class": "android.hardware.camera2.params.ColorSpaceTransform\n", "name": "DngCreator", "throws": null, "funcname": "DngCreator (CameraCharacteristics characteristics,                 CaptureResult metadata)", "parameters": [{"scri": "CameraCharacteristics: an object containing the static          CameraCharacteristics.This value must never be null.", "name": "characteristics"}, {"scri": "CaptureResult: a metadata object to generate tags from.This value must never be null.", "name": "metadata"}], "descri": "  Create a new DNG object. It is not necessary to call any set methods to write a well-formatted DNG file.  DNG metadata tags will be generated from the corresponding parameters in the CaptureResult object.  For best quality DNG files, it is strongly recommended that lens shading map output is enabled if supported. See STATISTICS_LENS_SHADING_MAP_MODE. "}, {"returns": [{"scri": "", "type": "int"}], "class": "android.hardware.camera2.params.MeteringRectangle\n", "type": "int", "name": "getScore", "throws": null, "funcname": "int getScore ()", "descri": "  The confidence level for the detection of the face. The range is .SCORE_MIN to .SCORE_MAX. .SCORE_MAX is the highest confidence.  Depending on the device, even very low-confidence faces may be listed, so applications should filter out faces with low confidence, depending on the use case. For a typical point-and-shoot camera application that wishes to display rectangles around detected faces, filtering out faces with confidence less than half of .SCORE_MAX is recommended.   See also: SCORE_MAXSCORE_MIN", "parameters": null}, {"returns": null, "class": "android.hardware.camera2.params.TonemapCurve\n", "type": "void", "name": "addSurface", "throws": [{"scri": "if the Surface is invalid, the Surface's         dataspace/format doesn't match, or adding the Surface would exceed number of         shared surfaces supported.", "type": "IllegalArgumentException"}, {"scri": "if the Surface was already added to this OutputConfiguration,         or if the OutputConfiguration is not shared and it already has a surface associated         with it.", "type": "IllegalStateException"}], "funcname": "void addSurface (Surface surface)", "descri": "  Add a surface to this OutputConfiguration. This function can be called before or after createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler). If it's called after, the application must finalize the capture session with finalizeOutputConfigurations(List). It is possible to call this method after the output configurations have been finalized only in cases of enabled surface sharing see enableSurfaceSharing(). The modified output configuration must be updated with updateOutputConfiguration(OutputConfiguration).  If the OutputConfiguration was constructed with a deferred surface by OutputConfiguration(Size, Class), the added surface must be obtained from SurfaceView by calling getSurface(), or from SurfaceTexture via Surface(android.graphics.SurfaceTexture)).  If the OutputConfiguration was constructed by other constructors, the added surface must be compatible with the existing surface. See enableSurfaceSharing() for details of compatible surfaces.  If the OutputConfiguration already contains a Surface, enableSurfaceSharing() must be called before calling this function to add a new Surface.   ", "parameters": [{"scri": "Surface: The surface to be added.This value must never be null.", "name": "surface"}]}, {"returns": null, "class": "android.hardware.camera2.params.TonemapCurve\n", "type": "void", "name": "enableSurfaceSharing", "throws": null, "funcname": "void enableSurfaceSharing ()", "descri": "  Enable multiple surfaces sharing the same OutputConfiguration For advanced use cases, a camera application may require more streams than the combination guaranteed by createCaptureSession(SessionConfiguration). In this case, more than one compatible surface can be attached to an OutputConfiguration so that they map to one camera stream, and the outputs share memory buffers when possible. Due to buffer sharing clients should be careful when adding surface outputs that modify their input data. If such case exists, camera clients should have an additional mechanism to synchronize read and write access between individual consumers.  Two surfaces are compatible in the below cases:  Surfaces with the same size, format, dataSpace, and Surface source class. In this case, createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler) is guaranteed to succeed. Surfaces with the same size, format, and dataSpace, but different Surface source classes that are generally not compatible. However, on some devices, the underlying camera device is able to use the same buffer layout for both surfaces. The only way to discover if this is the case is to create a capture session with that output configuration. For example, if the camera device uses the same private buffer format between a SurfaceView/SurfaceTexture and a MediaRecorder/MediaCodec, createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler) will succeed. Otherwise, it fails with onConfigureFailed(CameraCaptureSession).  To enable surface sharing, this function must be called before createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler) or createReprocessableCaptureSessionByConfigurations(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler). Calling this function after createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler) has no effect. Up to getMaxSharedSurfaceCount() surfaces can be shared for an OutputConfiguration. The supported surfaces for sharing must be of type SurfaceTexture, SurfaceView, MediaRecorder, MediaCodec, or implementation defined ImageReader.", "parameters": null}, {"returns": null, "class": "android.hardware.camera2.params.TonemapCurve\n", "type": "void", "name": "setPhysicalCameraId", "throws": null, "funcname": "void setPhysicalCameraId (String physicalCameraId)", "descri": "  Set the id of the physical camera for this OutputConfiguration In the case one logical camera is made up of multiple physical cameras, it could be desirable for the camera application to request streams from individual physical cameras. This call achieves it by mapping the OutputConfiguration to the physical camera id.  The valid physical camera ids can be queried by getPhysicalCameraIds().  Passing in a null physicalCameraId means that the OutputConfiguration is for a logical stream.  This function must be called before createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler) or createReprocessableCaptureSessionByConfigurations(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler). Calling this function after createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler) or createReprocessableCaptureSessionByConfigurations(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler) has no effect.  The surface belonging to a physical camera OutputConfiguration must not be used as input or output of a reprocessing request. ", "parameters": [{"scri": "String This value may be null.", "name": "physicalCameraId"}]}, {"returns": null, "class": "android.hardware.camera2.params.TonemapCurve\n", "name": "OutputConfiguration", "throws": null, "funcname": "OutputConfiguration (Surface surface)", "parameters": [{"scri": "Surface: A Surface for camera to output to. This constructor creates a default configuration, with a surface group ID of .SURFACE_GROUP_ID_NONE.This value must never be null.", "name": "surface"}], "descri": "  Create a new OutputConfiguration instance with a Surface. "}, {"returns": null, "class": "android.hardware.camera2.params.TonemapCurve\n", "name": "OutputConfiguration", "throws": null, "funcname": "OutputConfiguration (int surfaceGroupId,                 Surface surface)", "parameters": [{"scri": "int: A group ID for this output, used for sharing memory between multiple outputs.", "name": "surfaceGroupId"}, {"scri": "Surface: A Surface for camera to output to.This value must never be null.", "name": "surface"}], "descri": "  Create a new OutputConfiguration instance with a Surface, with a surface group ID. A surface group ID is used to identify which surface group this output surface belongs to. A surface group is a group of output surfaces that are not intended to receive camera output buffer streams simultaneously. The CameraDevice may be able to share the buffers used by all the surfaces from the same surface group, therefore may reduce the overall memory footprint. The application should only set the same set ID for the streams that are not simultaneously streaming. A negative ID indicates that this surface doesn't belong to any surface group. The default value is .SURFACE_GROUP_ID_NONE.  For example, a video chat application that has an adaptive output resolution feature would need two (or more) output resolutions, to switch resolutions without any output glitches. However, at any given time, only one output is active to minimize outgoing network bandwidth and encoding overhead.  To save memory, the application should set the video outputs to have the same non-negative group ID, so that the camera device can share the same memory region for the alternating outputs.  It is not an error to include output streams with the same group ID in the same capture request, but the resulting memory consumption may be higher than if the two streams were not in the same surface group to begin with, especially if the outputs have substantially different dimensions. "}, {"returns": null, "class": "android.hardware.camera2.params.TonemapCurve\n", "name": "OutputConfiguration", "throws": null, "funcname": "OutputConfiguration (Surface surface)", "parameters": [{"scri": "Surface: A Surface for camera to output to. This constructor creates a default configuration, with a surface group ID of .SURFACE_GROUP_ID_NONE.This value must never be null.", "name": "surface"}], "descri": "  Create a new OutputConfiguration instance with a Surface. "}, {"returns": null, "class": "android.hardware.camera2.params.TonemapCurve\n", "name": "OutputConfiguration", "throws": null, "funcname": "OutputConfiguration (int surfaceGroupId,                 Surface surface)", "parameters": [{"scri": "int: A group ID for this output, used for sharing memory between multiple outputs.", "name": "surfaceGroupId"}, {"scri": "Surface: A Surface for camera to output to.This value must never be null.", "name": "surface"}], "descri": "  Create a new OutputConfiguration instance with a Surface, with a surface group ID. A surface group ID is used to identify which surface group this output surface belongs to. A surface group is a group of output surfaces that are not intended to receive camera output buffer streams simultaneously. The CameraDevice may be able to share the buffers used by all the surfaces from the same surface group, therefore may reduce the overall memory footprint. The application should only set the same set ID for the streams that are not simultaneously streaming. A negative ID indicates that this surface doesn't belong to any surface group. The default value is .SURFACE_GROUP_ID_NONE.  For example, a video chat application that has an adaptive output resolution feature would need two (or more) output resolutions, to switch resolutions without any output glitches. However, at any given time, only one output is active to minimize outgoing network bandwidth and encoding overhead.  To save memory, the application should set the video outputs to have the same non-negative group ID, so that the camera device can share the same memory region for the alternating outputs.  It is not an error to include output streams with the same group ID in the same capture request, but the resulting memory consumption may be higher than if the two streams were not in the same surface group to begin with, especially if the outputs have substantially different dimensions. "}, {"returns": null, "class": "android.hardware.display.DisplayManager\n", "type": "void", "name": "setSessionParameters", "throws": null, "funcname": "void setSessionParameters (CaptureRequest params)", "descri": "  Sets the session wide camera parameters (see CaptureRequest). This argument can be set for every supported session type and will be passed to the camera device as part of the capture session initialization. Session parameters are a subset of the available capture request parameters (see getAvailableSessionKeys()) and their application can introduce internal camera delays. To improve camera performance it is suggested to change them sparingly within the lifetime of the capture session and to pass their initial values as part of this method. ", "parameters": [{"scri": "CaptureRequest: A capture request that includes the initial values for any available               session wide capture keys.", "name": "params"}]}, {"returns": null, "class": "android.hardware.display.DisplayManager\n", "name": "SessionConfiguration", "throws": null, "funcname": "SessionConfiguration (int sessionType,                 List<OutputConfiguration> outputs,                 Executor executor,                 CameraCaptureSession.StateCallback cb)", "parameters": [{"scri": "int: The session type.Value is SESSION_REGULAR or SESSION_HIGH_SPEED.", "name": "sessionType"}, {"scri": "List: A list of output configurations for the capture session.This value must never be null.", "name": "outputs"}, {"scri": "Executor: The executor which should be used to invoke the callback. In general it is                 recommended that camera operations are not done on the main (UI) thread.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraCaptureSession.StateCallback: A state callback interface implementation.This value must never be null.", "name": "cb"}], "descri": "  Create a new SessionConfiguration.   See also: SESSION_REGULARSESSION_HIGH_SPEEDcreateCaptureSession(List, CameraCaptureSession.StateCallback, Handler)createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler)createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler)createConstrainedHighSpeedCaptureSession(List, CameraCaptureSession.StateCallback, Handler)"}, {"returns": null, "class": "android.hardware.display.DisplayManager\n", "name": "SessionConfiguration", "throws": null, "funcname": "SessionConfiguration (int sessionType,                 List<OutputConfiguration> outputs,                 Executor executor,                 CameraCaptureSession.StateCallback cb)", "parameters": [{"scri": "int: The session type.Value is SESSION_REGULAR or SESSION_HIGH_SPEED.", "name": "sessionType"}, {"scri": "List: A list of output configurations for the capture session.This value must never be null.", "name": "outputs"}, {"scri": "Executor: The executor which should be used to invoke the callback. In general it is                 recommended that camera operations are not done on the main (UI) thread.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraCaptureSession.StateCallback: A state callback interface implementation.This value must never be null.", "name": "cb"}], "descri": "  Create a new SessionConfiguration.   See also: SESSION_REGULARSESSION_HIGH_SPEEDcreateCaptureSession(List, CameraCaptureSession.StateCallback, Handler)createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler)createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler)createConstrainedHighSpeedCaptureSession(List, CameraCaptureSession.StateCallback, Handler)"}, {"returns": null, "class": "android.hardware.display.DisplayManager\n", "name": "SessionConfiguration", "throws": null, "funcname": "SessionConfiguration (int sessionType,                 List<OutputConfiguration> outputs,                 Executor executor,                 CameraCaptureSession.StateCallback cb)", "parameters": [{"scri": "int: The session type.Value is SESSION_REGULAR or SESSION_HIGH_SPEED.", "name": "sessionType"}, {"scri": "List: A list of output configurations for the capture session.This value must never be null.", "name": "outputs"}, {"scri": "Executor: The executor which should be used to invoke the callback. In general it is                 recommended that camera operations are not done on the main (UI) thread.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraCaptureSession.StateCallback: A state callback interface implementation.This value must never be null.", "name": "cb"}], "descri": "  Create a new SessionConfiguration.   See also: SESSION_REGULARSESSION_HIGH_SPEEDcreateCaptureSession(List, CameraCaptureSession.StateCallback, Handler)createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler)createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler)createConstrainedHighSpeedCaptureSession(List, CameraCaptureSession.StateCallback, Handler)"}, {"returns": null, "class": "android.hardware.display.DisplayManager\n", "name": "SessionConfiguration", "throws": null, "funcname": "SessionConfiguration (int sessionType,                 List<OutputConfiguration> outputs,                 Executor executor,                 CameraCaptureSession.StateCallback cb)", "parameters": [{"scri": "int: The session type.Value is SESSION_REGULAR or SESSION_HIGH_SPEED.", "name": "sessionType"}, {"scri": "List: A list of output configurations for the capture session.This value must never be null.", "name": "outputs"}, {"scri": "Executor: The executor which should be used to invoke the callback. In general it is                 recommended that camera operations are not done on the main (UI) thread.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "CameraCaptureSession.StateCallback: A state callback interface implementation.This value must never be null.", "name": "cb"}], "descri": "  Create a new SessionConfiguration.   See also: SESSION_REGULARSESSION_HIGH_SPEEDcreateCaptureSession(List, CameraCaptureSession.StateCallback, Handler)createCaptureSessionByOutputConfigurations(List, CameraCaptureSession.StateCallback, Handler)createReprocessableCaptureSession(InputConfiguration, List, CameraCaptureSession.StateCallback, Handler)createConstrainedHighSpeedCaptureSession(List, CameraCaptureSession.StateCallback, Handler)"}, {"returns": [{"scri": "a stall duration >= 0 in nanoseconds", "type": "long"}], "class": "android.hardware.display.VirtualDisplay\n", "type": "long", "name": "getOutputStallDuration", "throws": [{"scri": "if format or size was not supported", "type": "IllegalArgumentException"}, {"scri": "if size was null", "type": "NullPointerException"}], "funcname": "long getOutputStallDuration (int format,                 Size size)", "descri": "  Get the stall duration for the format/size combination (in nanoseconds). format should be one of the ones returned by getOutputFormats().  size should be one of the ones returned by getOutputSizes(int).  A stall duration is how much extra time would get added to the normal minimum frame duration for a repeating request that has streams with non-zero stall. For example, consider JPEG captures which have the following characteristics: JPEG streams act like processed YUV streams in requests for which they are not included; in requests in which they are directly referenced, they act as JPEG streams. This is because supporting a JPEG stream requires the underlying YUV data to always be ready for use by a JPEG encoder, but the encoder will only be used (and impact frame duration) on requests that actually reference a JPEG stream. The JPEG processor can run concurrently to the rest of the camera pipeline, but cannot process more than 1 capture at a time.  In other words, using a repeating YUV request would result in a steady frame rate (let's say it's 30 FPS). If a single JPEG request is submitted periodically, the frame rate will stay at 30 FPS (as long as we wait for the previous JPEG to return each time). If we try to submit a repeating YUV + JPEG request, then the frame rate will drop from 30 FPS.  In general, submitting a new request with a non-0 stall time stream will not cause a frame rate drop unless there are still outstanding buffers for that stream from previous requests.  Submitting a repeating request with streams (call this S) is the same as setting the minimum frame duration from the normal minimum frame duration corresponding to S, added with the maximum stall duration for S.  If interleaving requests with and without a stall duration, a request will stall by the maximum of the remaining times for each can-stall stream with outstanding buffers.  This means that a stalling request will not have an exposure start until the stall has completed.  This should correspond to the stall duration when only that stream is active, with all processing (typically in android.*.mode) set to FAST or OFF. Setting any of the processing modes to HIGH_QUALITY effectively results in an indeterminate stall duration for all streams in a request (the regular stall calculation rules are ignored).  The following formats may always have a stall duration: JPEG RAW16 RAW_PRIVATE  The following formats will never have a stall duration: YUV_420_888 Implementation-Defined  All other formats may or may not have an allowed stall duration on a per-capability basis; refer to android.request.availableCapabilities for more details.  See android.sensor.frameDuration for more information about calculating the max frame rate (absent stalls).     See also: SENSOR_FRAME_DURATIONImageFormatPixelFormat", "parameters": [{"scri": "int: an image format from ImageFormat or PixelFormat", "name": "format"}, {"scri": "Size: an output-compatible size", "name": "size"}]}, {"returns": [{"scri": "true if this is supported, false otherwise", "type": "boolean"}], "class": "android.hardware.display.VirtualDisplay\n", "type": "boolean", "name": "isOutputSupportedFor", "throws": [{"scri": "if surface was null", "type": "NullPointerException"}, {"scri": "if the Surface endpoint is no longer valid", "type": "IllegalArgumentException"}], "funcname": "boolean isOutputSupportedFor (Surface surface)", "descri": "  Determine whether or not the surface in its current state is suitable to be included in a capture session as an output. Not all surfaces are usable with the CameraDevice, and not all configurations of that surface are compatible. Some classes that provide the surface are compatible with the CameraDevice in general (see isOutputSupportedFor(Class), but it is the caller's responsibility to put the surface into a state that will be compatible with the CameraDevice.  Reasons for a surface being specifically incompatible might be: Using a format that's not listed by getOutputFormats() Using a format/size combination that's not listed by getOutputSizes(int) The surface itself is not in a state where it can service a new producer.  Surfaces from flexible sources will return true even if the exact size of the Surface does not match a camera-supported size, as long as the format (or class) is supported and the camera device supports a size that is equal to or less than 1080p in that format. If such as Surface is used to create a capture session, it will have its size rounded to the nearest supported size, below or equal to 1080p. Flexible sources include SurfaceView, SurfaceTexture, and ImageReader.  This is not an exhaustive list; see the particular class's documentation for further possible reasons of incompatibility.     See also: createCaptureSession(SessionConfiguration)isOutputSupportedFor(Class)", "parameters": [{"scri": "Surface: a non-null Surface object reference", "name": "surface"}]}, {"returns": [{"scri": "true iff using a surface with this format will be          supported with createCaptureSession(SessionConfiguration)", "type": "boolean"}], "class": "android.hardware.display.VirtualDisplay\n", "type": "boolean", "name": "isOutputSupportedFor", "throws": [{"scri": "if the image format was not a defined named constant          from either ImageFormat or PixelFormat", "type": "IllegalArgumentException"}], "funcname": "boolean isOutputSupportedFor (int format)", "descri": "  Determine whether or not output surfaces with a particular user-defined format can be passed createCaptureSession. This method determines that the output format is supported by the camera device; each output surface target may or may not itself support that format. Refer to the class which provides the surface for additional documentation.  Formats for which this returns true are guaranteed to exist in the result returned by getOutputSizes(int).     See also: ImageFormatPixelFormatcreateCaptureSession(SessionConfiguration)", "parameters": [{"scri": "int: an image format from either ImageFormat or PixelFormat", "name": "format"}]}, {"returns": [{"scri": "true if this class is supported as an output, false otherwise", "type": "boolean"}], "class": "android.hardware.display.VirtualDisplay\n", "type": "boolean", "name": "isOutputSupportedFor", "throws": [{"scri": "if klass was null", "type": "NullPointerException"}], "funcname": "boolean isOutputSupportedFor (Class<T> klass)", "descri": "  Determine whether or not output streams can be configured with a particular class as a consumer. The following list is generally usable for outputs: ImageReader - Recommended for image processing or streaming to external resources (such as a file or network) MediaRecorder - Recommended for recording video (simple to use) MediaCodec - Recommended for recording video (more complicated to use, with more flexibility) Allocation - Recommended for image processing with RenderScript SurfaceHolder - Recommended for low-power camera preview with SurfaceView SurfaceTexture - Recommended for OpenGL-accelerated preview processing or compositing with TextureView  Generally speaking this means that creating a Surface from that class may provide a producer endpoint that is suitable to be used with createCaptureSession(SessionConfiguration).  Since not all of the above classes support output of all format and size combinations, the particular combination should be queried with isOutputSupportedFor(Surface).     See also: createCaptureSession(SessionConfiguration)isOutputSupportedFor(Surface)", "parameters": [{"scri": "Class: a non-null Class object reference", "name": "klass"}]}, {"returns": [{"scri": "the focal length. Returns -1.0 when the device         doesn't report focal length information.", "type": "float"}], "class": "android.hardware.GeomagneticField\n", "type": "float", "name": "getFocalLength", "throws": null, "funcname": "float getFocalLength ()", "descri": "  Gets the focal length (in millimeter) of the camera. ", "parameters": null}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "getFocusDistances", "throws": null, "funcname": "void getFocusDistances (float[] output)", "descri": "   Gets the distances from the camera to where an object appears to be in focus. The object is sharpest at the optimal focus distance. The depth of field is the far focus distance minus near focus distance.  Focus distances may change after calling autoFocus(AutoFocusCallback), cancelAutoFocus(), or startPreview(). Applications can call getParameters() and this method anytime to get the latest focus distances. If the focus mode is FOCUS_MODE_CONTINUOUS_VIDEO, focus distances may change from time to time.  This method is intended to estimate the distance between the camera and the subject. After autofocus, the subject distance may be within near and far focus distance. However, the precision depends on the camera hardware, autofocus algorithm, the focus area, and the scene. The error can be large and it should be only used as a reference.  Far focus distance >= optimal focus distance >= near focus distance. If the focus distance is infinity, the value will be Float.POSITIVE_INFINITY.   See also: FOCUS_DISTANCE_NEAR_INDEXFOCUS_DISTANCE_OPTIMAL_INDEXFOCUS_DISTANCE_FAR_INDEX", "parameters": [{"scri": "float: focus distances in meters. output must be a float        array with three elements. Near focus distance, optimal focus        distance, and far focus distance will be filled in the array.", "name": "output"}]}, {"returns": [{"scri": "the maximum number of detected face supported by the camera.", "type": "int"}], "class": "android.hardware.GeomagneticField\n", "type": "int", "name": "getMaxNumDetectedFaces", "throws": null, "funcname": "int getMaxNumDetectedFaces ()", "descri": "  Gets the maximum number of detected faces supported. This is the maximum length of the list returned from Camera.FaceDetectionListener. If the return value is 0, face detection of the specified type is not supported.   See also: startFaceDetection()", "parameters": null}, {"returns": [{"scri": "the maximum number of focus areas supported by the camera.", "type": "int"}], "class": "android.hardware.GeomagneticField\n", "type": "int", "name": "getMaxNumFocusAreas", "throws": null, "funcname": "int getMaxNumFocusAreas ()", "descri": "  Gets the maximum number of focus areas supported. This is the maximum length of the list in setFocusAreas(List) and getFocusAreas().   See also: getFocusAreas()", "parameters": null}, {"returns": [{"scri": "the maximum number of metering areas supported by the camera.", "type": "int"}], "class": "android.hardware.GeomagneticField\n", "type": "int", "name": "getMaxNumMeteringAreas", "throws": null, "funcname": "int getMaxNumMeteringAreas ()", "descri": "  Gets the maximum number of metering areas supported. This is the maximum length of the list in setMeteringAreas(List) and getMeteringAreas().   See also: getMeteringAreas()", "parameters": null}, {"returns": [{"scri": "the maximum zoom value supported by the camera.", "type": "int"}], "class": "android.hardware.GeomagneticField\n", "type": "int", "name": "getMaxZoom", "throws": null, "funcname": "int getMaxZoom ()", "descri": "  Gets the maximum zoom value allowed for snapshot. This is the maximum value that applications can set to setZoom(int). Applications should call isZoomSupported() before using this method. This value may change in different preview size. Applications should call this again after setting preview size. ", "parameters": null}, {"returns": [{"scri": "the preview format.", "type": "int"}], "class": "android.hardware.GeomagneticField\n", "type": "int", "name": "getPreviewFormat", "throws": null, "funcname": "int getPreviewFormat ()", "descri": "  Returns the image format for preview frames got from Camera.PreviewCallback.   See also: ImageFormatsetPreviewFormat(int)", "parameters": null}, {"returns": [{"scri": "the current zoom value. The range is 0 to getMaxZoom(). 0 means the camera is not zoomed.", "type": "int"}], "class": "android.hardware.GeomagneticField\n", "type": "int", "name": "getZoom", "throws": null, "funcname": "int getZoom ()", "descri": "  Gets current zoom value. This also works when smooth zoom is in progress. Applications should check isZoomSupported() before using this method. ", "parameters": null}, {"returns": [{"scri": "true if video snapshot is supported.", "type": "boolean"}], "class": "android.hardware.GeomagneticField\n", "type": "boolean", "name": "isVideoSnapshotSupported", "throws": null, "funcname": "boolean isVideoSnapshotSupported ()", "descri": "   Returns true if video snapshot is supported. That is, applications can call takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback) during recording. Applications do not need to call startPreview() after taking a picture. The preview will be still active. Other than that, taking a picture during recording is identical to taking a picture normally. All settings and methods related to takePicture work identically. Ex: getPictureSize(), getSupportedPictureSizes(), setJpegQuality(int), setRotation(int), and etc. The picture will have an EXIF header. FLASH_MODE_AUTO and FLASH_MODE_ON also still work, but the video will record the flash.  Applications can set shutter callback as null to avoid the shutter sound. It is also recommended to set raw picture and post view callbacks to null to avoid the interrupt of preview display.  Field-of-view of the recorded video may be different from that of the captured pictures. The maximum size of a video snapshot may be smaller than that for regular still captures. If the current picture size is set higher than can be supported by video snapshot, the picture will be captured at the maximum supported size instead. ", "parameters": null}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "removeGpsData", "throws": null, "funcname": "void removeGpsData ()", "descri": "  Removes GPS latitude, longitude, altitude, and timestamp from the parameters.", "parameters": null}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setAutoExposureLock", "throws": null, "funcname": "void setAutoExposureLock (boolean toggle)", "descri": "   Sets the auto-exposure lock state. Applications should check isAutoExposureLockSupported() before using this method.  If set to true, the camera auto-exposure routine will immediately pause until the lock is set to false. Exposure compensation settings changes will still take effect while auto-exposure is locked.  If auto-exposure is already locked, setting this to true again has no effect (the driver will not recalculate exposure values).  Stopping preview with stopPreview(), or triggering still image capture with takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback), will not change the lock.  Exposure compensation, auto-exposure lock, and auto-white balance lock can be used to capture an exposure-bracketed burst of images, for example.  Auto-exposure state, including the lock state, will not be maintained after camera release() is called.  Locking auto-exposure after open() but before the first call to startPreview() will not allow the auto-exposure routine to run at all, and may result in severely over- or under-exposed images.   See also: getAutoExposureLock()", "parameters": [{"scri": "boolean: new state of the auto-exposure lock. True means that        auto-exposure is locked, false means that the auto-exposure        routine is free to run normally.", "name": "toggle"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setAutoWhiteBalanceLock", "throws": null, "funcname": "void setAutoWhiteBalanceLock (boolean toggle)", "descri": "   Sets the auto-white balance lock state. Applications should check isAutoWhiteBalanceLockSupported() before using this method.  If set to true, the camera auto-white balance routine will immediately pause until the lock is set to false.  If auto-white balance is already locked, setting this to true again has no effect (the driver will not recalculate white balance values).  Stopping preview with stopPreview(), or triggering still image capture with takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback), will not change the the lock.  Changing the white balance mode with setWhiteBalance(String) will release the auto-white balance lock if it is set.  Exposure compensation, AE lock, and AWB lock can be used to capture an exposure-bracketed burst of images, for example. Auto-white balance state, including the lock state, will not be maintained after camera release() is called.  Locking auto-white balance after open() but before the first call to startPreview() will not allow the auto-white balance routine to run at all, and may result in severely incorrect color in captured images.   See also: getAutoWhiteBalanceLock()setWhiteBalance(String)", "parameters": [{"scri": "boolean: new state of the auto-white balance lock. True means        that auto-white balance is locked, false means that the        auto-white balance routine is free to run normally.", "name": "toggle"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setGpsAltitude", "throws": null, "funcname": "void setGpsAltitude (double altitude)", "descri": "  Sets GPS altitude. This will be stored in JPEG EXIF header. ", "parameters": [{"scri": "double: GPS altitude in meters.", "name": "altitude"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setGpsLatitude", "throws": null, "funcname": "void setGpsLatitude (double latitude)", "descri": "  Sets GPS latitude coordinate. This will be stored in JPEG EXIF header. ", "parameters": [{"scri": "double: GPS latitude coordinate.", "name": "latitude"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setGpsLongitude", "throws": null, "funcname": "void setGpsLongitude (double longitude)", "descri": "  Sets GPS longitude coordinate. This will be stored in JPEG EXIF header. ", "parameters": [{"scri": "double: GPS longitude coordinate.", "name": "longitude"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setGpsProcessingMethod", "throws": null, "funcname": "void setGpsProcessingMethod (String processing_method)", "descri": "  Sets GPS processing method. The method will be stored in a UTF-8 string up to 31 bytes long, in the JPEG EXIF header. ", "parameters": [{"scri": "String: The processing method to get this location.", "name": "processing_method"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setGpsTimestamp", "throws": null, "funcname": "void setGpsTimestamp (long timestamp)", "descri": "  Sets GPS timestamp. This will be stored in JPEG EXIF header. ", "parameters": [{"scri": "long: GPS timestamp (UTC in seconds since January 1,                  1970).", "name": "timestamp"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setPreviewFormat", "throws": null, "funcname": "void setPreviewFormat (int pixel_format)", "descri": "  Sets the image format for preview pictures. If this is never called, the default format will be NV21, which uses the NV21 encoding format.  Use getSupportedPreviewFormats() to get a list of the available preview formats. It is strongly recommended that either NV21 or YV12 is used, since they are supported by all camera devices.  For YV12, the image buffer that is received is not necessarily tightly packed, as there may be padding at the end of each row of pixel data, as described in YV12. For camera callback data, it can be assumed that the stride of the Y and UV data is the smallest possible that meets the alignment requirements. That is, if the preview size is width x height, then the following equations describe the buffer index for the beginning of row y for the Y plane and row c for the U and V planes: yStride   = (int) ceil(width / 16.0) * 16; uvStride  = (int) ceil( (yStride / 2) / 16.0) * 16; ySize     = yStride * height; uvSize    = uvStride * height / 2; yRowIndex = yStride * y; uRowIndex = ySize + uvSize + uvStride * c; vRowIndex = ySize + uvStride * c; size      = ySize + uvSize * 2;   See also: ImageFormatgetSupportedPreviewFormats()", "parameters": [{"scri": "int: the desired preview picture format, defined by   one of the ImageFormat constants.  (E.g.,   ImageFormat.NV21 (default), or   ImageFormat.YV12)", "name": "pixel_format"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setPreviewFpsRange", "throws": [{"scri": "if fps range is invalid.", "type": "RuntimeException"}], "funcname": "void setPreviewFpsRange (int min,                 int max)", "descri": "  Sets the minimum and maximum preview fps. This controls the rate of preview frames received in Camera.PreviewCallback. The minimum and maximum preview fps must be one of the elements from getSupportedPreviewFpsRange().    See also: setPreviewCallbackWithBuffer(Camera.PreviewCallback)getSupportedPreviewFpsRange()", "parameters": [{"scri": "int: the minimum preview fps (scaled by 1000).", "name": "min"}, {"scri": "int: the maximum preview fps (scaled by 1000).", "name": "max"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setPreviewSize", "throws": null, "funcname": "void setPreviewSize (int width,                 int height)", "descri": "  Sets the dimensions for preview pictures. If the preview has already started, applications should stop the preview first before changing preview size. The sides of width and height are based on camera orientation. That is, the preview size is the size before it is rotated by display orientation. So applications need to consider the display orientation while setting preview size. For example, suppose the camera supports both 480x320 and 320x480 preview sizes. The application wants a 3:2 preview ratio. If the display orientation is set to 0 or 180, preview size should be set to 480x320. If the display orientation is set to 90 or 270, preview size should be set to 320x480. The display orientation should also be considered while setting picture size and thumbnail size.   See also: setDisplayOrientation(int)getCameraInfo(int, CameraInfo)setPictureSize(int, int)setJpegThumbnailSize(int, int)", "parameters": [{"scri": "int: the width of the pictures, in pixels", "name": "width"}, {"scri": "int: the height of the pictures, in pixels", "name": "height"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setRecordingHint", "throws": null, "funcname": "void setRecordingHint (boolean hint)", "descri": "  Sets recording mode hint. This tells the camera that the intent of the application is to record videos start(), not to take still pictures takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback). Using this hint can allow MediaRecorder.start() to start faster or with fewer glitches on output. This should be called before starting preview for the best result, but can be changed while the preview is active. The default value is false. The app can still call takePicture() when the hint is true or call MediaRecorder.start() when the hint is false. But the performance may be worse. ", "parameters": [{"scri": "boolean: true if the apps intend to record videos using             MediaRecorder.", "name": "hint"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setRotation", "throws": [{"scri": "if rotation value is invalid.", "type": "IllegalArgumentException"}], "funcname": "void setRotation (int rotation)", "descri": "  Sets the clockwise rotation angle in degrees relative to the orientation of the camera. This affects the pictures returned from JPEG Camera.PictureCallback. The camera driver may set orientation in the EXIF header without rotating the picture. Or the driver may rotate the picture and the EXIF thumbnail. If the Jpeg picture is rotated, the orientation in the EXIF header will be missing or 1 (row #0 is top and column #0 is left side). If applications want to rotate the picture to match the orientation of what users see, apps should use OrientationEventListener and Camera.CameraInfo. The value from OrientationEventListener is relative to the natural orientation of the device. CameraInfo.orientation is the angle between camera orientation and natural device orientation. The sum of the two is the rotation angle for back-facing camera. The difference of the two is the rotation angle for front-facing camera. Note that the JPEG pictures of front-facing cameras are not mirrored as in preview display. For example, suppose the natural orientation of the device is portrait. The device is rotated 270 degrees clockwise, so the device orientation is 270. Suppose a back-facing camera sensor is mounted in landscape and the top side of the camera sensor is aligned with the right edge of the display in natural orientation. So the camera orientation is 90. The rotation should be set to 0 (270 + 90). The reference code is as follows. public void onOrientationChanged(int orientation) {     if (orientation == ORIENTATION_UNKNOWN) return;     android.hardware.Camera.CameraInfo info =            new android.hardware.Camera.CameraInfo();     android.hardware.Camera.getCameraInfo(cameraId, info);     orientation = (orientation + 45) / 90 * 90;     int rotation = 0;     if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {         rotation = (info.orientation - orientation + 360) % 360;     } else {  // back-facing camera         rotation = (info.orientation + orientation) % 360;     }     mParameters.setRotation(rotation); }    See also: OrientationEventListenergetCameraInfo(int, CameraInfo)", "parameters": [{"scri": "int: The rotation angle in degrees relative to the                 orientation of the camera. Rotation can only be 0,                 90, 180 or 270.", "name": "rotation"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setVideoStabilization", "throws": null, "funcname": "void setVideoStabilization (boolean toggle)", "descri": "   Enables and disables video stabilization. Use isVideoStabilizationSupported() to determine if calling this method is valid.  Video stabilization reduces the shaking due to the motion of the camera in both the preview stream and in recorded videos, including data received from the preview callback. It does not reduce motion blur in images captured with takePicture.  Video stabilization can be enabled and disabled while preview or recording is active, but toggling it may cause a jump in the video stream that may be undesirable in a recorded video.   See also: isVideoStabilizationSupported()getVideoStabilization()", "parameters": [{"scri": "boolean: Set to true to enable video stabilization, and false to disable video stabilization.", "name": "toggle"}]}, {"returns": null, "class": "android.hardware.GeomagneticField\n", "type": "void", "name": "setZoom", "throws": null, "funcname": "void setZoom (int value)", "descri": "  Sets current zoom value. If the camera is zoomed (value > 0), the actual picture size may be smaller than picture size setting. Applications can check the actual picture size after picture is returned from Camera.PictureCallback. The preview size remains the same in zoom. Applications should check isZoomSupported() before using this method. ", "parameters": [{"scri": "int: zoom value. The valid range is 0 to getMaxZoom().", "name": "value"}]}, {"returns": null, "class": "android.hardware.input.InputManager\n", "type": "void", "name": "authenticate", "throws": [{"scri": "if the crypto operation is not supported or is not backed         by Android Keystore         facility.", "type": "IllegalArgumentException"}, {"scri": "if the crypto primitive is not initialized.", "type": "IllegalStateException"}], "funcname": "void authenticate (FingerprintManager.CryptoObject crypto,                 CancellationSignal cancel,                 int flags,                 FingerprintManager.AuthenticationCallback callback,                 Handler handler)", "descri": "   This method was deprecated      in API level P.    See authenticate(CancellationSignal, Executor, BiometricPrompt.AuthenticationCallback) and authenticate(BiometricPrompt.CryptoObject, CancellationSignal, Executor, BiometricPrompt.AuthenticationCallback)  Request authentication of a crypto object. This call warms up the fingerprint hardware and starts scanning for a fingerprint. It terminates when onAuthenticationError(int, CharSequence) or onAuthenticationSucceeded(AuthenticationResult) is called, at which point the object is no longer valid. The operation can be canceled by using the provided cancel object. Requires the USE_BIOMETRIC or USE_FINGERPRINT permissions.   ", "parameters": [{"scri": "FingerprintManager.CryptoObject: object associated with the call or null if none required.", "name": "crypto"}, {"scri": "CancellationSignal: an object that can be used to cancel authenticationThis value may be null.", "name": "cancel"}, {"scri": "int: optional flags; should be 0", "name": "flags"}, {"scri": "FingerprintManager.AuthenticationCallback: an object to receive authentication eventsThis value must never be null.", "name": "callback"}, {"scri": "Handler: an optional handler to handle callback eventsThis value may be null.", "name": "handler"}]}, {"returns": null, "class": "android.hardware.input.InputManager\n", "type": "void", "name": "authenticate", "throws": [{"scri": "if the crypto operation is not supported or is not backed         by Android Keystore         facility.", "type": "IllegalArgumentException"}, {"scri": "if the crypto primitive is not initialized.", "type": "IllegalStateException"}], "funcname": "void authenticate (FingerprintManager.CryptoObject crypto,                 CancellationSignal cancel,                 int flags,                 FingerprintManager.AuthenticationCallback callback,                 Handler handler)", "descri": "   This method was deprecated      in API level P.    See authenticate(CancellationSignal, Executor, BiometricPrompt.AuthenticationCallback) and authenticate(BiometricPrompt.CryptoObject, CancellationSignal, Executor, BiometricPrompt.AuthenticationCallback)  Request authentication of a crypto object. This call warms up the fingerprint hardware and starts scanning for a fingerprint. It terminates when onAuthenticationError(int, CharSequence) or onAuthenticationSucceeded(AuthenticationResult) is called, at which point the object is no longer valid. The operation can be canceled by using the provided cancel object. Requires the USE_BIOMETRIC or USE_FINGERPRINT permissions.   ", "parameters": [{"scri": "FingerprintManager.CryptoObject: object associated with the call or null if none required.", "name": "crypto"}, {"scri": "CancellationSignal: an object that can be used to cancel authenticationThis value may be null.", "name": "cancel"}, {"scri": "int: optional flags; should be 0", "name": "flags"}, {"scri": "FingerprintManager.AuthenticationCallback: an object to receive authentication eventsThis value must never be null.", "name": "callback"}, {"scri": "Handler: an optional handler to handle callback eventsThis value may be null.", "name": "handler"}]}, {"returns": [{"scri": "true if at least one fingerprint is enrolled, false otherwise", "type": "boolean"}], "class": "android.hardware.input.InputManager\n", "type": "boolean", "name": "hasEnrolledFingerprints", "throws": null, "funcname": "boolean hasEnrolledFingerprints ()", "descri": "   This method was deprecated      in API level P.    See BiometricPrompt and FINGERPRINT_ERROR_NO_FINGERPRINTS  Determine if there is at least one fingerprint enrolled. Requires the USE_FINGERPRINT permission. ", "parameters": null}, {"returns": [{"scri": "true if hardware is present and functional, false otherwise.", "type": "boolean"}], "class": "android.hardware.input.InputManager\n", "type": "boolean", "name": "isHardwareDetected", "throws": null, "funcname": "boolean isHardwareDetected ()", "descri": "   This method was deprecated      in API level P.    See BiometricPrompt and FINGERPRINT_ERROR_HW_UNAVAILABLE  Determine if fingerprint hardware is present and functional. Requires the USE_FINGERPRINT permission. ", "parameters": null}, {"returns": null, "class": "android.hardware.Sensor\n", "type": "void", "name": "transmit", "throws": null, "funcname": "void transmit (int carrierFrequency,                 int[] pattern)", "descri": "  Transmit an infrared pattern This method is synchronous; when it returns the pattern has been transmitted. Only patterns shorter than 2 seconds will be transmitted. ", "parameters": [{"scri": "int: The IR carrier frequency in Hertz.", "name": "carrierFrequency"}, {"scri": "int: The alternating on/off pattern in microseconds to transmit.", "name": "pattern"}]}, {"returns": null, "class": "android.hardware.SensorEventListener\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onZoomChange", "throws": null, "funcname": "void onZoomChange (int zoomValue,                 boolean stopped,                 Camera camera)", "descri": "  Called when the zoom value has changed during a smooth zoom. ", "parameters": [{"scri": "int: the current zoom value. In smooth zoom mode, camera                  calls this for every new zoom value.", "name": "zoomValue"}, {"scri": "boolean: whether smooth zoom is stopped. If the value is true,                this is the last zoom update for the application.", "name": "stopped"}, {"scri": "Camera: the Camera service object", "name": "camera"}]}, {"returns": null, "class": "android.hardware.SensorEventListener\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onZoomChange", "throws": null, "funcname": "void onZoomChange (int zoomValue,                 boolean stopped,                 Camera camera)", "descri": "  Called when the zoom value has changed during a smooth zoom. ", "parameters": [{"scri": "int: the current zoom value. In smooth zoom mode, camera                  calls this for every new zoom value.", "name": "zoomValue"}, {"scri": "boolean: whether smooth zoom is stopped. If the value is true,                this is the last zoom update for the application.", "name": "stopped"}, {"scri": "Camera: the Camera service object", "name": "camera"}]}, {"returns": null, "class": "android.hardware.SensorListener\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onPictureTaken", "throws": null, "funcname": "void onPictureTaken (byte[] data,                 Camera camera)", "descri": "  Called when image data is available after a picture is taken. The format of the data depends on the context of the callback and Camera.Parameters settings. ", "parameters": [{"scri": "byte: a byte array of the picture data", "name": "data"}, {"scri": "Camera: the Camera service object", "name": "camera"}]}, {"returns": [{"scri": "true on success, false on failure (for         instance, if the device is in free fall). Free fall is defined as         condition when the magnitude of the gravity is less than 1/10 of         the nominal value. On failure the output matrices are not modified.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "static\n        \n        \n        boolean", "name": "getRotationMatrix", "throws": null, "funcname": "boolean getRotationMatrix (float[] R,                 float[] I,                 float[] gravity,                 float[] geomagnetic)", "descri": "   Computes the inclination matrix I as well as the rotation matrix R transforming a vector from the device coordinate system to the world's coordinate system which is defined as a direct orthonormal basis, where:  X is defined as the vector product Y.Z (It is tangential to the ground at the device's current location and roughly points East). Y is tangential to the ground at the device's current location and points towards the magnetic North Pole. Z points towards the sky and is perpendicular to the ground.        By definition: [0 0 g] = R * gravity (g = magnitude of gravity) [0 m 0] = I * R * geomagnetic (m = magnitude of geomagnetic field) R is the identity matrix when the device is aligned with the world's coordinate system, that is, when the device's X axis points toward East, the Y axis points to the North Pole and the device is facing the sky. I is a rotation matrix transforming the geomagnetic vector into the same coordinate space as gravity (the world's coordinate space). I is a simple rotation around the X axis. The inclination angle in radians can be computed with getInclination(float[]).   Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: If the array length is 16: /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \\     *   |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  |   |  M[ 8]   M[ 9]   M[10]   M[11]  |   \\  M[12]   M[13]   M[14]   M[15]  / This matrix is ready to be used by OpenGL ES's glLoadMatrixf(float[], int) . Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. Also note that the returned matrices always have this form: /  M[ 0]   M[ 1]   M[ 2]   0  \\     *   |  M[ 4]   M[ 5]   M[ 6]   0  |   |  M[ 8]   M[ 9]   M[10]   0  |   \\      0       0       0   1  /  If the array length is 9: /  M[ 0]   M[ 1]   M[ 2]  \\     *   |  M[ 3]   M[ 4]   M[ 5]  |   \\  M[ 6]   M[ 7]   M[ 8]  /    The inverse of each matrix can be computed easily by taking its transpose. The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.    See also: getInclination(float[])getOrientation(float[], float[])remapCoordinateSystem(float[], int, int, float[])", "parameters": [{"scri": "float: is an array of 9 floats holding the rotation matrix R when        this function returns. R can be null.", "name": "R"}, {"scri": "float: is an array of 9 floats holding the rotation matrix I when        this function returns. I can be null.", "name": "I"}, {"scri": "float: is an array of 3 floats containing the gravity vector expressed in        the device's coordinate. You can simply use the        values returned by a        SensorEvent of a        Sensor of type        TYPE_ACCELEROMETER.", "name": "gravity"}, {"scri": "float: is an array of 3 floats containing the geomagnetic vector        expressed in the device's coordinate. You can simply use the        values returned by a        SensorEvent of a        Sensor of type        TYPE_MAGNETIC_FIELD.", "name": "geomagnetic"}]}, {"returns": [{"scri": "true if dynamic sensor discovery is supported, false otherwise.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "boolean", "name": "isDynamicSensorDiscoverySupported", "throws": null, "funcname": "boolean isDynamicSensorDiscoverySupported ()", "descri": "  Tell if dynamic sensor discovery feature is supported by system. ", "parameters": null}, {"returns": null, "class": "android.hardware.TriggerEventListener\n", "type": "void", "name": "registerDynamicSensorCallback", "throws": [{"scri": "when callback is null.", "type": "IllegalArgumentException"}], "funcname": "void registerDynamicSensorCallback (SensorManager.DynamicSensorCallback callback)", "descri": "  Add a DynamicSensorCallback to receive dynamic sensor connection callbacks. Repeat registration with the already registered callback object will have no additional effect.    See also: ERROR(/#addDynamicSensorCallback(DynamicSensorCallback, Handler))", "parameters": [{"scri": "SensorManager.DynamicSensorCallback: An object that implements the        DynamicSensorCallback        interface for receiving callbacks.", "name": "callback"}]}, {"returns": null, "class": "android.hardware.TriggerEventListener\n", "type": "void", "name": "registerDynamicSensorCallback", "throws": [{"scri": "when callback is null.", "type": "IllegalArgumentException"}], "funcname": "void registerDynamicSensorCallback (SensorManager.DynamicSensorCallback callback,                 Handler handler)", "descri": "  Add a DynamicSensorCallback to receive dynamic sensor connection callbacks. Repeat registration with the already registered callback object will have no additional effect.   ", "parameters": [{"scri": "SensorManager.DynamicSensorCallback: An object that implements the        DynamicSensorCallback interface for receiving callbacks.", "name": "callback"}, {"scri": "Handler: The Handler the sensor connection events will be delivered to.", "name": "handler"}]}, {"returns": [{"scri": "true if the sensor is supported and successfully enabled.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "boolean", "name": "registerListener", "throws": null, "funcname": "boolean registerListener (SensorEventListener listener,                 Sensor sensor,                 int samplingPeriodUs)", "descri": "  Registers a SensorEventListener for the given sensor at the given sampling frequency. The events will be delivered to the provided SensorEventListener as soon as they are available. To reduce the power consumption, applications can use registerListener(SensorEventListener, Sensor, int, int) instead and specify a positive non-zero maximum reporting latency.  In the case of non-wake-up sensors, the events are only delivered while the Application Processor (AP) is not in suspend mode. See isWakeUpSensor() for more details. To ensure delivery of events from non-wake-up sensors even when the screen is OFF, the application registering to the sensor must hold a partial wake-lock to keep the AP awake, otherwise some events might be lost while the AP is asleep. Note that although events might be lost while the AP is asleep, the sensor will still consume power if it is not explicitly deactivated by the application. Applications must unregister their SensorEventListeners in their activity's onPause() method to avoid consuming power while the device is inactive.  See registerListener(SensorEventListener, Sensor, int, int) for more details on hardware FIFO (queueing) capabilities and when some sensor events might be lost.  In the case of wake-up sensors, each event generated by the sensor will cause the AP to wake-up, ensuring that each event can be delivered. Because of this, registering to a wake-up sensor has very significant power implications. Call isWakeUpSensor() to check whether a sensor is a wake-up sensor. See registerListener(SensorEventListener, Sensor, int, int) for information on how to reduce the power impact of registering to wake-up sensors.  Note: Don't use this method with one-shot trigger sensors such as TYPE_SIGNIFICANT_MOTION. Use requestTriggerSensor(TriggerEventListener, Sensor) instead. Use getReportingMode() to obtain the reporting mode of a given sensor.    See also: registerListener(SensorEventListener, Sensor, int, Handler)unregisterListener(SensorEventListener)unregisterListener(SensorEventListener, Sensor)", "parameters": [{"scri": "SensorEventListener: A SensorEventListener object.", "name": "listener"}, {"scri": "Sensor: The Sensor to register to.", "name": "sensor"}, {"scri": "int: The rate sensor events are            delivered at. This is only a hint to the system. Events may be received faster or            slower than the specified rate. Usually events are received faster. The value must            be one of SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI,            SENSOR_DELAY_GAME, or SENSOR_DELAY_FASTEST or, the desired delay            between events in microseconds. Specifying the delay in microseconds only works            from Android 2.3 (API level 9) onwards. For earlier releases, you must use one of            the SENSOR_DELAY_* constants.", "name": "samplingPeriodUs"}]}, {"returns": [{"scri": "true if the sensor is supported and successfully enabled.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "boolean", "name": "registerListener", "throws": null, "funcname": "boolean registerListener (SensorEventListener listener,                 Sensor sensor,                 int samplingPeriodUs,                 int maxReportLatencyUs)", "descri": "  Registers a SensorEventListener for the given sensor at the given sampling frequency and the given maximum reporting latency. This function is similar to registerListener(SensorEventListener, Sensor, int) but it allows events to stay temporarily in the hardware FIFO (queue) before being delivered. The events can be stored in the hardware FIFO up to maxReportLatencyUs microseconds. Once one of the events in the FIFO needs to be reported, all of the events in the FIFO are reported sequentially. This means that some events will be reported before the maximum reporting latency has elapsed. When maxReportLatencyUs is 0, the call is equivalent to a call to registerListener(SensorEventListener, Sensor, int), as it requires the events to be delivered as soon as possible. When sensor.maxFifoEventCount() is 0, the sensor does not use a FIFO, so the call will also be equivalent to registerListener(SensorEventListener, Sensor, int). Setting maxReportLatencyUs to a positive value allows to reduce the number of interrupts the AP (Application Processor) receives, hence reducing power consumption, as the AP can switch to a lower power state while the sensor is capturing the data. This is especially important when registering to wake-up sensors, for which each interrupt causes the AP to wake up if it was in suspend mode. See isWakeUpSensor() for more information on wake-up sensors.   Note: Don't use this method with one-shot trigger sensors such as TYPE_SIGNIFICANT_MOTION . Use requestTriggerSensor(TriggerEventListener, Sensor) instead.   See also: registerListener(SensorEventListener, Sensor, int)unregisterListener(SensorEventListener)flush(SensorEventListener)", "parameters": [{"scri": "SensorEventListener: A SensorEventListener object            that will receive the sensor events. If the application is interested in receiving            flush complete notifications, it should register with            SensorEventListener2 instead.", "name": "listener"}, {"scri": "Sensor: The Sensor to register to.", "name": "sensor"}, {"scri": "int: The desired delay between two consecutive events in microseconds.            This is only a hint to the system. Events may be received faster or slower than            the specified rate. Usually events are received faster. Can be one of            SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI,            SENSOR_DELAY_GAME, SENSOR_DELAY_FASTEST or the delay in            microseconds.", "name": "samplingPeriodUs"}, {"scri": "int: Maximum time in microseconds that events can be delayed before            being reported to the application. A large value allows reducing the power            consumption associated with the sensor. If maxReportLatencyUs is set to zero,            events are delivered as soon as they are available, which is equivalent to calling            registerListener(SensorEventListener, Sensor, int).", "name": "maxReportLatencyUs"}]}, {"returns": [{"scri": "true if the sensor is supported and successfully enabled.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "boolean", "name": "registerListener", "throws": null, "funcname": "boolean registerListener (SensorEventListener listener,                 Sensor sensor,                 int samplingPeriodUs,                 int maxReportLatencyUs)", "descri": "  Registers a SensorEventListener for the given sensor at the given sampling frequency and the given maximum reporting latency. This function is similar to registerListener(SensorEventListener, Sensor, int) but it allows events to stay temporarily in the hardware FIFO (queue) before being delivered. The events can be stored in the hardware FIFO up to maxReportLatencyUs microseconds. Once one of the events in the FIFO needs to be reported, all of the events in the FIFO are reported sequentially. This means that some events will be reported before the maximum reporting latency has elapsed. When maxReportLatencyUs is 0, the call is equivalent to a call to registerListener(SensorEventListener, Sensor, int), as it requires the events to be delivered as soon as possible. When sensor.maxFifoEventCount() is 0, the sensor does not use a FIFO, so the call will also be equivalent to registerListener(SensorEventListener, Sensor, int). Setting maxReportLatencyUs to a positive value allows to reduce the number of interrupts the AP (Application Processor) receives, hence reducing power consumption, as the AP can switch to a lower power state while the sensor is capturing the data. This is especially important when registering to wake-up sensors, for which each interrupt causes the AP to wake up if it was in suspend mode. See isWakeUpSensor() for more information on wake-up sensors.   Note: Don't use this method with one-shot trigger sensors such as TYPE_SIGNIFICANT_MOTION . Use requestTriggerSensor(TriggerEventListener, Sensor) instead.   See also: registerListener(SensorEventListener, Sensor, int)unregisterListener(SensorEventListener)flush(SensorEventListener)", "parameters": [{"scri": "SensorEventListener: A SensorEventListener object            that will receive the sensor events. If the application is interested in receiving            flush complete notifications, it should register with            SensorEventListener2 instead.", "name": "listener"}, {"scri": "Sensor: The Sensor to register to.", "name": "sensor"}, {"scri": "int: The desired delay between two consecutive events in microseconds.            This is only a hint to the system. Events may be received faster or slower than            the specified rate. Usually events are received faster. Can be one of            SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI,            SENSOR_DELAY_GAME, SENSOR_DELAY_FASTEST or the delay in            microseconds.", "name": "samplingPeriodUs"}, {"scri": "int: Maximum time in microseconds that events can be delayed before            being reported to the application. A large value allows reducing the power            consumption associated with the sensor. If maxReportLatencyUs is set to zero,            events are delivered as soon as they are available, which is equivalent to calling            registerListener(SensorEventListener, Sensor, int).", "name": "maxReportLatencyUs"}]}, {"returns": [{"scri": "true if the sensor is supported and successfully enabled.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "boolean", "name": "registerListener", "throws": null, "funcname": "boolean registerListener (SensorEventListener listener,                 Sensor sensor,                 int samplingPeriodUs,                 Handler handler)", "descri": "  Registers a SensorEventListener for the given sensor. Events are delivered in continuous mode as soon as they are available. To reduce the power consumption, applications can use registerListener(SensorEventListener, Sensor, int, int) instead and specify a positive non-zero maximum reporting latency.  Note: Don't use this method with a one shot trigger sensor such as TYPE_SIGNIFICANT_MOTION . Use requestTriggerSensor(TriggerEventListener, Sensor) instead.   See also: registerListener(SensorEventListener, Sensor, int)unregisterListener(SensorEventListener)unregisterListener(SensorEventListener, Sensor)", "parameters": [{"scri": "SensorEventListener: A SensorEventListener object.", "name": "listener"}, {"scri": "Sensor: The Sensor to register to.", "name": "sensor"}, {"scri": "int: The rate sensor events are            delivered at. This is only a hint to the system. Events may be received faster or            slower than the specified rate. Usually events are received faster. The value must            be one of SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI,            SENSOR_DELAY_GAME, or SENSOR_DELAY_FASTEST or, the desired            delay between events in microseconds. Specifying the delay in microseconds only            works from Android 2.3 (API level 9) onwards. For earlier releases, you must use            one of the SENSOR_DELAY_* constants.", "name": "samplingPeriodUs"}, {"scri": "Handler: The Handler the sensor events will be delivered to.", "name": "handler"}]}, {"returns": [{"scri": "true if the sensor is supported and successfully enabled.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "boolean", "name": "registerListener", "throws": null, "funcname": "boolean registerListener (SensorEventListener listener,                 Sensor sensor,                 int samplingPeriodUs,                 int maxReportLatencyUs,                 Handler handler)", "descri": "  Registers a SensorEventListener for the given sensor at the given sampling frequency and the given maximum reporting latency.    See also: registerListener(SensorEventListener, Sensor, int, int)", "parameters": [{"scri": "SensorEventListener: A SensorEventListener object            that will receive the sensor events. If the application is interested in receiving            flush complete notifications, it should register with            SensorEventListener2 instead.", "name": "listener"}, {"scri": "Sensor: The Sensor to register to.", "name": "sensor"}, {"scri": "int: The desired delay between two consecutive events in microseconds.            This is only a hint to the system. Events may be received faster or slower than            the specified rate. Usually events are received faster. Can be one of            SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI,            SENSOR_DELAY_GAME, SENSOR_DELAY_FASTEST or the delay in            microseconds.", "name": "samplingPeriodUs"}, {"scri": "int: Maximum time in microseconds that events can be delayed before            being reported to the application. A large value allows reducing the power            consumption associated with the sensor. If maxReportLatencyUs is set to zero,            events are delivered as soon as they are available, which is equivalent to calling            registerListener(SensorEventListener, Sensor, int).", "name": "maxReportLatencyUs"}, {"scri": "Handler: The Handler the sensor events will be delivered to.", "name": "handler"}]}, {"returns": [{"scri": "true if the sensor is supported and successfully enabled.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "boolean", "name": "registerListener", "throws": null, "funcname": "boolean registerListener (SensorEventListener listener,                 Sensor sensor,                 int samplingPeriodUs,                 int maxReportLatencyUs,                 Handler handler)", "descri": "  Registers a SensorEventListener for the given sensor at the given sampling frequency and the given maximum reporting latency.    See also: registerListener(SensorEventListener, Sensor, int, int)", "parameters": [{"scri": "SensorEventListener: A SensorEventListener object            that will receive the sensor events. If the application is interested in receiving            flush complete notifications, it should register with            SensorEventListener2 instead.", "name": "listener"}, {"scri": "Sensor: The Sensor to register to.", "name": "sensor"}, {"scri": "int: The desired delay between two consecutive events in microseconds.            This is only a hint to the system. Events may be received faster or slower than            the specified rate. Usually events are received faster. Can be one of            SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI,            SENSOR_DELAY_GAME, SENSOR_DELAY_FASTEST or the delay in            microseconds.", "name": "samplingPeriodUs"}, {"scri": "int: Maximum time in microseconds that events can be delayed before            being reported to the application. A large value allows reducing the power            consumption associated with the sensor. If maxReportLatencyUs is set to zero,            events are delivered as soon as they are available, which is equivalent to calling            registerListener(SensorEventListener, Sensor, int).", "name": "maxReportLatencyUs"}, {"scri": "Handler: The Handler the sensor events will be delivered to.", "name": "handler"}]}, {"returns": [{"scri": "true on success. false if the input         parameters are incorrect, for instance if X and Y define the same         axis. Or if inR and outR don't have the same length.", "type": "boolean"}], "class": "android.hardware.TriggerEventListener\n", "type": "static\n        \n        \n        boolean", "name": "remapCoordinateSystem", "throws": null, "funcname": "boolean remapCoordinateSystem (float[] inR,                 int X,                 int Y,                 float[] outR)", "descri": "   Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see getOrientation(float[], float[])) in a different coordinate system.  When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually doesn't need to be transformed by this function, unless the screen is physically rotated, in which case you can use Display.getRotation() to retrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here.  Examples:  Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed:   remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);  Using the device as a mechanical compass when rotation is Surface.ROTATION_90:   remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);   Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see getOrientation(float[], float[])). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your Activity is running in landscape mode.  Since the resulting coordinate system is orthonormal, only two axes need to be specified.    See also: getRotationMatrix(float[], float[], float[], float[])", "parameters": [{"scri": "float: the rotation matrix to be transformed. Usually it is the matrix        returned by getRotationMatrix(float[], float[], float[], float[]).", "name": "inR"}, {"scri": "int: defines the axis of the new cooridinate system that coincide with the X axis of the        original coordinate system.", "name": "X"}, {"scri": "int: defines the axis of the new cooridinate system that coincide with the Y axis of the        original coordinate system.", "name": "Y"}, {"scri": "float: the transformed rotation matrix. inR and outR should not be the same        array.", "name": "outR"}]}, {"returns": null, "class": "android.hardware.TriggerEventListener\n", "type": "void", "name": "unregisterDynamicSensorCallback", "throws": null, "funcname": "void unregisterDynamicSensorCallback (SensorManager.DynamicSensorCallback callback)", "descri": "  Remove a DynamicSensorCallback to stop sending dynamic sensor connection events to that callback. ", "parameters": [{"scri": "SensorManager.DynamicSensorCallback: An object that implements the        DynamicSensorCallback        interface for receiving callbacks.", "name": "callback"}]}, {"returns": null, "class": "android.hardware.usb.UsbAccessory\n", "type": "void", "name": "onAuthenticationFailed", "throws": null, "funcname": "void onAuthenticationFailed ()", "descri": "  Called when a fingerprint is valid but not recognized.", "parameters": null}, {"returns": null, "class": "android.hardware.usb.UsbAccessory\n", "type": "void", "name": "onAuthenticationSucceeded", "throws": null, "funcname": "void onAuthenticationSucceeded (FingerprintManager.AuthenticationResult result)", "descri": "  Called when a fingerprint is recognized. ", "parameters": [{"scri": "FingerprintManager.AuthenticationResult: An object containing authentication-related data", "name": "result"}]}, {"returns": [{"scri": "true if the queueing operation succeeded", "type": "boolean"}], "class": "android.icu.lang.UCharacter.EastAsianWidth\n", "type": "boolean", "name": "queue", "throws": null, "funcname": "boolean queue (ByteBuffer buffer,                 int length)", "descri": "   This method was deprecated      in API level 26.    Use queue(ByteBuffer) instead.  Queues the request to send or receive data on its endpoint. For OUT endpoints, the given buffer data will be sent on the endpoint. For IN endpoints, the endpoint will attempt to read the given number of bytes into the specified buffer. If the queueing operation is successful, return true. The result will be returned via requestWait()  ", "parameters": [{"scri": "ByteBuffer: the buffer containing the bytes to write, or location to store the results of a               read. Position and array offset will be ignored and assumed to be 0. Limit and               capacity will be ignored. Once the request               is processed the position will be set               to the number of bytes read/written.", "name": "buffer"}, {"scri": "int: number of bytes to read or write. Before Build.VERSION_CODES.P, a               value larger than 16384 bytes would be truncated down to 16384. In API               Build.VERSION_CODES.P and after, any value of length is valid.", "name": "length"}]}, {"returns": [{"scri": "<0 or 0 or >0 as usual for string comparisons", "type": "int"}], "class": "android.icu.text.NumberFormat.Field\n", "type": "static\n        \n        \n        int", "name": "compare", "throws": null, "funcname": "int compare (char[] s1,                 int s1Start,                 int s1Limit,                 char[] s2,                 int s2Start,                 int s2Limit,                 int options)", "descri": "  Compare two strings for canonical equivalence. Further options include case-insensitive comparison and code point order (as opposed to code unit order). Canonical equivalence between two strings is defined as their normalized forms (NFD or NFC) being identical. This function compares strings incrementally instead of normalizing (and optionally case-folding) both strings entirely, improving performance significantly. Bulk normalization is only necessary if the strings do not fulfill the FCD conditions. Only in this case, and only if the strings are relatively long, is memory allocated temporarily. For FCD strings and short non-FCD strings there is no memory allocation. Semantically, this is equivalent to   strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2))) where code point order and foldCase are all optional.  ", "parameters": [{"scri": "char: First source character array.", "name": "s1"}, {"scri": "int: start index of source", "name": "s1Start"}, {"scri": "int: limit of the source", "name": "s1Limit"}, {"scri": "char: Second source character array.", "name": "s2"}, {"scri": "int: start index of the source", "name": "s2Start"}, {"scri": "int: limit of the source", "name": "s2Limit"}, {"scri": "int: A bit set of options:   - FOLD_CASE_DEFAULT or 0 is used for default options:     Case-sensitive comparison in code unit order, and the input strings     are quick-checked for FCD.   - INPUT_IS_FCD     Set if the caller knows that both s1 and s2 fulfill the FCD     conditions.If not set, the function will quickCheck for FCD     and normalize if necessary.   - COMPARE_CODE_POINT_ORDER     Set to choose code point order instead of code unit order   - COMPARE_IGNORE_CASE     Set to compare strings case-insensitively using case folding,     instead of case-sensitively.     If set, then the following case folding options are used.", "name": "options"}]}, {"returns": [{"scri": "<0 or 0 or >0 as usual for string comparisons", "type": "int"}], "class": "android.icu.text.NumberFormat.Field\n", "type": "static\n        \n        \n        int", "name": "compare", "throws": null, "funcname": "int compare (String s1,                 String s2,                 int options)", "descri": "  Compare two strings for canonical equivalence. Further options include case-insensitive comparison and code point order (as opposed to code unit order). Canonical equivalence between two strings is defined as their normalized forms (NFD or NFC) being identical. This function compares strings incrementally instead of normalizing (and optionally case-folding) both strings entirely, improving performance significantly. Bulk normalization is only necessary if the strings do not fulfill the FCD conditions. Only in this case, and only if the strings are relatively long, is memory allocated temporarily. For FCD strings and short non-FCD strings there is no memory allocation. Semantically, this is equivalent to   strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2))) where code point order and foldCase are all optional.  ", "parameters": [{"scri": "String: First source string.", "name": "s1"}, {"scri": "String: Second source string.", "name": "s2"}, {"scri": "int: A bit set of options:   - FOLD_CASE_DEFAULT or 0 is used for default options:     Case-sensitive comparison in code unit order, and the input strings     are quick-checked for FCD.   - INPUT_IS_FCD     Set if the caller knows that both s1 and s2 fulfill the FCD     conditions. If not set, the function will quickCheck for FCD     and normalize if necessary.   - COMPARE_CODE_POINT_ORDER     Set to choose code point order instead of code unit order   - COMPARE_IGNORE_CASE     Set to compare strings case-insensitively using case folding,     instead of case-sensitively.     If set, then the following case folding options are used.", "name": "options"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.icu.text.RelativeDateTimeFormatter\n", "type": "boolean", "name": "isAlgorithmic", "throws": null, "funcname": "boolean isAlgorithmic ()", "descri": "  Returns the numbering system's algorithmic status.  If true, the numbering system is algorithmic and uses an RBNF formatter to format numerals.  If false, the numbering system is numeric and uses a fixed set of digits. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.icu.text.RelativeDateTimeFormatter\n", "type": "static\n        \n        \n        boolean", "name": "isValidDigitString", "throws": null, "funcname": "boolean isValidDigitString (String str)", "descri": "  Convenience method to determine if a given digit string is valid for use as a descriptor of a numeric ( non-algorithmic ) numbering system.  In order for a digit string to be valid, it must contain exactly ten Unicode code points.  ", "parameters": [{"scri": "String", "name": "str"}]}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "type": "void", "name": "setCalculationType", "throws": null, "funcname": "void setCalculationType (IslamicCalendar.CalculationType type)", "descri": "  sets the calculation type for this calendar. ", "parameters": [{"scri": "IslamicCalendar.CalculationType", "name": "type"}]}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar ()", "parameters": null, "descri": "  Constructs a default IslamicCalendar using the current time in the default time zone with the default FORMAT locale.  See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (TimeZone zone)", "parameters": [{"scri": "TimeZone: the given time zone.", "name": "zone"}], "descri": "  Constructs an IslamicCalendar based on the current time in the given time zone with the default FORMAT locale.   See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (Locale aLocale)", "parameters": [{"scri": "Locale: the given locale.", "name": "aLocale"}], "descri": "  Constructs an IslamicCalendar based on the current time in the default time zone with the given locale. "}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (ULocale locale)", "parameters": [{"scri": "ULocale: the given ulocale.", "name": "locale"}], "descri": "  Constructs an IslamicCalendar based on the current time in the default time zone with the given locale. "}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (TimeZone zone,                 Locale aLocale)", "parameters": [{"scri": "TimeZone: the given time zone.", "name": "zone"}, {"scri": "Locale: the given locale.", "name": "aLocale"}], "descri": "  Constructs an IslamicCalendar based on the current time in the given time zone with the given locale. "}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (TimeZone zone,                 ULocale locale)", "parameters": [{"scri": "TimeZone: the given time zone.", "name": "zone"}, {"scri": "ULocale: the given ulocale.", "name": "locale"}], "descri": "  Constructs an IslamicCalendar based on the current time in the given time zone with the given locale. "}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (Date date)", "parameters": [{"scri": "Date: The date to which the new calendar is set.", "name": "date"}], "descri": "  Constructs an IslamicCalendar with the given date set in the default time zone with the default FORMAT locale.   See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (int year,                 int month,                 int date)", "parameters": [{"scri": "int: the value used to set the YEAR time field in the calendar.", "name": "year"}, {"scri": "int: the value used to set the MONTH time field in the calendar.              Note that the month value is 0-based. e.g., 0 for Muharram.", "name": "month"}, {"scri": "int: the value used to set the DATE time field in the calendar.", "name": "date"}], "descri": "  Constructs an IslamicCalendar with the given date set in the default time zone with the default FORMAT locale.   See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (int year,                 int month,                 int date,                 int hour,                 int minute,                 int second)", "parameters": [{"scri": "int: the value used to set the YEAR time field in the calendar.", "name": "year"}, {"scri": "int: the value used to set the MONTH time field in the calendar.              Note that the month value is 0-based. e.g., 0 for Muharram.", "name": "month"}, {"scri": "int: the value used to set the DATE time field in the calendar.", "name": "date"}, {"scri": "int: the value used to set the HOUR_OF_DAY time field              in the calendar.", "name": "hour"}, {"scri": "int: the value used to set the MINUTE time field              in the calendar.", "name": "minute"}, {"scri": "int: the value used to set the SECOND time field              in the calendar.", "name": "second"}], "descri": "  Constructs an IslamicCalendar with the given date and time set for the default time zone with the default FORMAT locale.   See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar ()", "parameters": null, "descri": "  Constructs a default IslamicCalendar using the current time in the default time zone with the default FORMAT locale.  See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (TimeZone zone)", "parameters": [{"scri": "TimeZone: the given time zone.", "name": "zone"}], "descri": "  Constructs an IslamicCalendar based on the current time in the given time zone with the default FORMAT locale.   See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (Locale aLocale)", "parameters": [{"scri": "Locale: the given locale.", "name": "aLocale"}], "descri": "  Constructs an IslamicCalendar based on the current time in the default time zone with the given locale. "}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (ULocale locale)", "parameters": [{"scri": "ULocale: the given ulocale.", "name": "locale"}], "descri": "  Constructs an IslamicCalendar based on the current time in the default time zone with the given locale. "}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (TimeZone zone,                 Locale aLocale)", "parameters": [{"scri": "TimeZone: the given time zone.", "name": "zone"}, {"scri": "Locale: the given locale.", "name": "aLocale"}], "descri": "  Constructs an IslamicCalendar based on the current time in the given time zone with the given locale. "}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (TimeZone zone,                 ULocale locale)", "parameters": [{"scri": "TimeZone: the given time zone.", "name": "zone"}, {"scri": "ULocale: the given ulocale.", "name": "locale"}], "descri": "  Constructs an IslamicCalendar based on the current time in the given time zone with the given locale. "}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (Date date)", "parameters": [{"scri": "Date: The date to which the new calendar is set.", "name": "date"}], "descri": "  Constructs an IslamicCalendar with the given date set in the default time zone with the default FORMAT locale.   See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (int year,                 int month,                 int date)", "parameters": [{"scri": "int: the value used to set the YEAR time field in the calendar.", "name": "year"}, {"scri": "int: the value used to set the MONTH time field in the calendar.              Note that the month value is 0-based. e.g., 0 for Muharram.", "name": "month"}, {"scri": "int: the value used to set the DATE time field in the calendar.", "name": "date"}], "descri": "  Constructs an IslamicCalendar with the given date set in the default time zone with the default FORMAT locale.   See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "name": "IslamicCalendar", "throws": null, "funcname": "IslamicCalendar (int year,                 int month,                 int date,                 int hour,                 int minute,                 int second)", "parameters": [{"scri": "int: the value used to set the YEAR time field in the calendar.", "name": "year"}, {"scri": "int: the value used to set the MONTH time field in the calendar.              Note that the month value is 0-based. e.g., 0 for Muharram.", "name": "month"}, {"scri": "int: the value used to set the DATE time field in the calendar.", "name": "date"}, {"scri": "int: the value used to set the HOUR_OF_DAY time field              in the calendar.", "name": "hour"}, {"scri": "int: the value used to set the MINUTE time field              in the calendar.", "name": "minute"}, {"scri": "int: the value used to set the SECOND time field              in the calendar.", "name": "second"}], "descri": "  Constructs an IslamicCalendar with the given date and time set for the default time zone with the default FORMAT locale.   See also: FORMAT"}, {"returns": null, "class": "android.icu.util.LocaleData.MeasurementSystem\n", "type": "void", "name": "handleComputeFields", "throws": null, "funcname": "void handleComputeFields (int julianDay)", "descri": "  Override Calendar to compute several fields specific to the Islamic calendar system.  These are: ERA YEAR MONTH DAY_OF_MONTH DAY_OF_YEAR EXTENDED_YEAR The DAY_OF_WEEK and DOW_LOCAL fields are already set when this method is called. The getGregorianXxx() methods return Gregorian calendar equivalents for the given Julian day.", "parameters": [{"scri": "int", "name": "julianDay"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.icu.util.LocaleData.MeasurementSystem\n", "type": "int", "name": "handleGetYearLength", "throws": null, "funcname": "int handleGetYearLength (int extendedYear)", "descri": "  Return the number of days in the given Islamic year  ", "parameters": [{"scri": "int", "name": "extendedYear"}]}, {"returns": null, "class": "android.icu.util.VersionInfo\n", "type": "static\n        \n        \n        ULocale", "name": "ULocale", "throws": null, "funcname": "ULocale (String localeID)", "descri": "  [icu] Constructs a ULocale from a RFC 3066 locale ID. The locale ID consists of optional language, script, country, and variant fields in that order, separated by underscores, followed by an optional keyword list.  The script, if present, is four characters long-- this distinguishes it from a country code, which is two characters long.  Other fields are distinguished by position as indicated by the underscores.  The start of the keyword list is indicated by '@', and consists of two or more keyword/value pairs separated by semicolons(';'). This constructor does not canonicalize the localeID.  So, for example, \"zh__pinyin\" remains unchanged instead of converting to \"zh@collation=pinyin\".  By default ICU only recognizes the latter as specifying pinyin collation.  Use createCanonical(String) or canonicalize(String) if you need to canonicalize the localeID. ", "parameters": [{"scri": "String: string representation of the locale, e.g: \"en_US\", \"sy_Cyrl_YU\", \"zh__pinyin\", \"es_ES@currency=EUR;collation=traditional\"", "name": "localeID"}]}, {"returns": null, "class": "android.icu.util.VersionInfo\n", "name": "ULocale", "throws": null, "funcname": "ULocale (String localeID)", "parameters": [{"scri": "String: string representation of the locale, e.g: \"en_US\", \"sy_Cyrl_YU\", \"zh__pinyin\", \"es_ES@currency=EUR;collation=traditional\"", "name": "localeID"}], "descri": "  [icu] Constructs a ULocale from a RFC 3066 locale ID. The locale ID consists of optional language, script, country, and variant fields in that order, separated by underscores, followed by an optional keyword list.  The script, if present, is four characters long-- this distinguishes it from a country code, which is two characters long.  Other fields are distinguished by position as indicated by the underscores.  The start of the keyword list is indicated by '@', and consists of two or more keyword/value pairs separated by semicolons(';'). This constructor does not canonicalize the localeID.  So, for example, \"zh__pinyin\" remains unchanged instead of converting to \"zh@collation=pinyin\".  By default ICU only recognizes the latter as specifying pinyin collation.  Use createCanonical(String) or canonicalize(String) if you need to canonicalize the localeID. "}, {"returns": null, "class": "android.icu.util.VersionInfo\n", "name": "ULocale", "throws": null, "funcname": "ULocale (String localeID)", "parameters": [{"scri": "String: string representation of the locale, e.g: \"en_US\", \"sy_Cyrl_YU\", \"zh__pinyin\", \"es_ES@currency=EUR;collation=traditional\"", "name": "localeID"}], "descri": "  [icu] Constructs a ULocale from a RFC 3066 locale ID. The locale ID consists of optional language, script, country, and variant fields in that order, separated by underscores, followed by an optional keyword list.  The script, if present, is four characters long-- this distinguishes it from a country code, which is two characters long.  Other fields are distinguished by position as indicated by the underscores.  The start of the keyword list is indicated by '@', and consists of two or more keyword/value pairs separated by semicolons(';'). This constructor does not canonicalize the localeID.  So, for example, \"zh__pinyin\" remains unchanged instead of converting to \"zh@collation=pinyin\".  By default ICU only recognizes the latter as specifying pinyin collation.  Use createCanonical(String) or canonicalize(String) if you need to canonicalize the localeID. "}, {"returns": [{"scri": "", "type": "int"}], "class": "android.inputmethodservice.Keyboard\n", "type": "int", "name": "getMaxWidth", "throws": null, "funcname": "int getMaxWidth ()", "descri": "  Return the maximum width, in pixels, available the input method. Input methods are positioned at the bottom of the screen and, unless running in fullscreen, will generally want to be as short as possible so should compute their height based on their contents.  However, they can stretch as much as needed horizontally.  The function returns to you the maximum amount of space available horizontally, which you can use if needed for UI placement. In many cases this is not needed, you can just rely on the normal view layout mechanisms to position your views within the full horizontal space given to the input method. Note that this value can change dynamically, in particular when the screen orientation changes. ", "parameters": null}, {"returns": null, "class": "android.inputmethodservice.Keyboard\n", "type": "void", "name": "onUpdateCursor", "throws": null, "funcname": "void onUpdateCursor (Rect newCursor)", "descri": "   This method was deprecated      in API level 21.    Use {#link onUpdateCursorAnchorInfo(CursorAnchorInfo)} instead.  Called when the application has reported a new location of its text cursor.  This is only called if explicitly requested by the input method. The default implementation does nothing. ", "parameters": [{"scri": "Rect", "name": "newCursor"}]}, {"returns": null, "class": "android.inputmethodservice.Keyboard\n", "type": "void", "name": "onUpdateCursorAnchorInfo", "throws": null, "funcname": "void onUpdateCursorAnchorInfo (CursorAnchorInfo cursorAnchorInfo)", "descri": "  Called when the application has reported a new location of its text insertion point and characters in the composition string.  This is only called if explicitly requested by the input method. The default implementation does nothing. ", "parameters": [{"scri": "CursorAnchorInfo: The positional information of the text insertion point and the composition string.", "name": "cursorAnchorInfo"}]}, {"returns": null, "class": "android.inputmethodservice.Keyboard\n", "type": "void", "name": "setCandidatesView", "throws": null, "funcname": "void setCandidatesView (View view)", "descri": "  Replaces the current candidates view with a new one.  You only need to call this when dynamically changing the view; normally, you should implement onCreateCandidatesView() and create your view when first needed by the input method. ", "parameters": [{"scri": "View", "name": "view"}]}, {"returns": null, "class": "android.inputmethodservice.Keyboard\n", "type": "void", "name": "setInputView", "throws": null, "funcname": "void setInputView (View view)", "descri": "  Replaces the current input view with a new one.  You only need to call this when dynamically changing the view; normally, you should implement onCreateInputView() and create your view when first needed by the input method. ", "parameters": [{"scri": "View", "name": "view"}]}, {"returns": null, "class": "android.location.Address\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onGpsStatusChanged", "throws": null, "funcname": "void onGpsStatusChanged (int event)", "descri": "  Called to report changes in the GPS status. The event number is one of: GPS_EVENT_STARTED  GPS_EVENT_STOPPED  GPS_EVENT_FIRST_FIX  GPS_EVENT_SATELLITE_STATUS When this method is called, the client should call getGpsStatus(GpsStatus) to get additional status information.", "parameters": [{"scri": "int: event number for this notification", "name": "event"}]}, {"returns": null, "class": "android.location.Geocoder\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onLocationChanged", "throws": null, "funcname": "void onLocationChanged (Location location)", "descri": "  Called when the location has changed. There are no restrictions on the use of the supplied Location object. ", "parameters": [{"scri": "Location: The new location, as a Location object.", "name": "location"}]}, {"returns": null, "class": "android.location.Geocoder\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onProviderDisabled", "throws": null, "funcname": "void onProviderDisabled (String provider)", "descri": "  Called when the provider is disabled by the user. If requestLocationUpdates is called on an already disabled provider, this method is called immediately. ", "parameters": [{"scri": "String: the name of the location provider associated with this update.", "name": "provider"}]}, {"returns": null, "class": "android.location.Geocoder\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onProviderEnabled", "throws": null, "funcname": "void onProviderEnabled (String provider)", "descri": "  Called when the provider is enabled by the user. ", "parameters": [{"scri": "String: the name of the location provider associated with this update.", "name": "provider"}]}, {"returns": null, "class": "android.location.Geocoder\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onStatusChanged", "throws": null, "funcname": "void onStatusChanged (String provider,                 int status,                 Bundle extras)", "descri": "  Called when the provider status changes. This method is called when a provider is unable to fetch a location or if the provider has recently become available after a period of unavailability. ", "parameters": [{"scri": "String: the name of the location provider associated with this update.", "name": "provider"}, {"scri": "int: OUT_OF_SERVICE if the provider is out of service, and this is not expected to change in the near future; TEMPORARILY_UNAVAILABLE if the provider is temporarily unavailable but is expected to be available shortly; and AVAILABLE if the provider is currently available.", "name": "status"}, {"scri": "Bundle: an optional Bundle which will contain provider specific status variables.  A number of common key/value pairs for the extras Bundle are listed below. Providers that use any of the keys on this list must provide the corresponding value as described below.   satellites - the number of satellites used to derive the fix", "name": "extras"}]}, {"returns": null, "class": "android.location.GnssClock\n", "type": "void", "name": "setPhone", "throws": null, "funcname": "void setPhone (String phone)", "descri": "  Sets the phone number associated with this address. ", "parameters": [{"scri": "String", "name": "phone"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.location.GnssMeasurement\n", "type": "int", "name": "getAccuracy", "throws": null, "funcname": "int getAccuracy ()", "descri": "  Returns a constant indicating desired accuracy of location Accuracy may be ACCURACY_FINE if desired location is fine, else it can be ACCURACY_COARSE. ", "parameters": null}, {"returns": null, "class": "android.location.GnssMeasurement\n", "type": "void", "name": "setAccuracy", "throws": [{"scri": "if accuracy is not one of the supported constants", "type": "IllegalArgumentException"}], "funcname": "void setAccuracy (int accuracy)", "descri": "  Indicates the desired accuracy for latitude and longitude. Accuracy may be ACCURACY_FINE if desired location is fine, else it can be ACCURACY_COARSE. More accurate location may consume more power and may take longer.   ", "parameters": [{"scri": "int", "name": "accuracy"}]}, {"returns": null, "class": "android.location.GnssMeasurement\n", "type": "void", "name": "setBearingAccuracy", "throws": [{"scri": "if accuracy is not one of the supported constants", "type": "IllegalArgumentException"}], "funcname": "void setBearingAccuracy (int accuracy)", "descri": "  Indicates the desired bearing accuracy. Accuracy may be ACCURACY_LOW, ACCURACY_HIGH, or NO_REQUIREMENT. More accurate location may consume more power and may take longer.   ", "parameters": [{"scri": "int", "name": "accuracy"}]}, {"returns": null, "class": "android.location.GnssMeasurement\n", "type": "void", "name": "setHorizontalAccuracy", "throws": [{"scri": "if accuracy is not one of the supported constants", "type": "IllegalArgumentException"}], "funcname": "void setHorizontalAccuracy (int accuracy)", "descri": "  Indicates the desired horizontal accuracy (latitude and longitude). Accuracy may be ACCURACY_LOW, ACCURACY_MEDIUM, ACCURACY_HIGH or NO_REQUIREMENT. More accurate location may consume more power and may take longer.   ", "parameters": [{"scri": "int", "name": "accuracy"}]}, {"returns": null, "class": "android.location.GnssMeasurement\n", "type": "void", "name": "setSpeedAccuracy", "throws": [{"scri": "if accuracy is not one of the supported constants", "type": "IllegalArgumentException"}], "funcname": "void setSpeedAccuracy (int accuracy)", "descri": "  Indicates the desired speed accuracy. Accuracy may be ACCURACY_LOW, ACCURACY_HIGH, or NO_REQUIREMENT. More accurate location may consume more power and may take longer.   ", "parameters": [{"scri": "int", "name": "accuracy"}]}, {"returns": null, "class": "android.location.GnssMeasurement\n", "type": "void", "name": "setVerticalAccuracy", "throws": [{"scri": "if accuracy is not one of the supported constants", "type": "IllegalArgumentException"}], "funcname": "void setVerticalAccuracy (int accuracy)", "descri": "  Indicates the desired vertical accuracy (altitude). Accuracy may be ACCURACY_LOW, ACCURACY_MEDIUM, ACCURACY_HIGH or NO_REQUIREMENT. More accurate location may consume more power and may take longer.   ", "parameters": [{"scri": "int", "name": "accuracy"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.location.GnssMeasurementsEvent.Callback\n", "type": "static\n        \n        \n        boolean", "name": "isPresent", "throws": null, "funcname": "boolean isPresent ()", "descri": "  Returns true if the Geocoder methods getFromLocation and getFromLocationName are implemented.  Lack of network connectivity may still cause these methods to return null or empty lists. ", "parameters": null}, {"returns": [{"scri": "", "type": "double"}], "class": "android.location.GnssNavigationMessage\n", "type": "double", "name": "getBiasNanos", "throws": null, "funcname": "double getBiasNanos ()", "descri": "  Gets the clock's sub-nanosecond bias. See the description of how this field is part of converting from hardware clock time, to GPS time, in getFullBiasNanos(). The error estimate for the sum of this field and getFullBiasNanos() is getBiasUncertaintyNanos(). The value is only available if hasBiasNanos() is true. ", "parameters": null}, {"returns": [{"scri": "", "type": "double"}], "class": "android.location.GnssNavigationMessage\n", "type": "double", "name": "getBiasUncertaintyNanos", "throws": null, "funcname": "double getBiasUncertaintyNanos ()", "descri": "  Gets the clock's Bias Uncertainty (1-Sigma) in nanoseconds. See the description of how this field provides the error estimate in the conversion from hardware clock time, to GPS time, in getFullBiasNanos(). The value is only available if hasBiasUncertaintyNanos() is true. ", "parameters": null}, {"returns": [{"scri": "", "type": "double"}], "class": "android.location.GnssNavigationMessage\n", "type": "double", "name": "getDriftNanosPerSecond", "throws": null, "funcname": "double getDriftNanosPerSecond ()", "descri": "  Gets the clock's Drift in nanoseconds per second. This value is the instantaneous time-derivative of the value provided by getBiasNanos(). A positive value indicates that the frequency is higher than the nominal (e.g. GPS master clock) frequency. The error estimate for this reported drift is getDriftUncertaintyNanosPerSecond(). The value is only available if hasDriftNanosPerSecond() is true. ", "parameters": null}, {"returns": [{"scri": "", "type": "long"}], "class": "android.location.GnssNavigationMessage\n", "type": "long", "name": "getFullBiasNanos", "throws": null, "funcname": "long getFullBiasNanos ()", "descri": "  Gets the difference between hardware clock (getTimeNanos()) inside GPS receiver and the true GPS time since 0000Z, January 6, 1980, in nanoseconds. This value is available if the receiver has estimated GPS time. If the computed time is for a non-GPS constellation, the time offset of that constellation to GPS has to be applied to fill this value. The value is only available if hasFullBiasNanos() is true. The error estimate for the sum of this field and getBiasNanos() is getBiasUncertaintyNanos(). The sign of the value is defined by the following equation: local estimate of GPS time = TimeNanos - (FullBiasNanos + BiasNanos) ", "parameters": null}, {"returns": [{"scri": "", "type": "long"}], "class": "android.location.GnssNavigationMessage\n", "type": "long", "name": "getTimeNanos", "throws": null, "funcname": "long getTimeNanos ()", "descri": "  Gets the GNSS receiver internal hardware clock value in nanoseconds. This value is expected to be monotonically increasing while the hardware clock remains powered on. For the case of a hardware clock that is not continuously on, see the getHardwareClockDiscontinuityCount() field. The GPS time can be derived by subtracting the sum of getFullBiasNanos() and getBiasNanos() (when they are available) from this value. Sub-nanosecond accuracy can be provided by means of getBiasNanos(). The error estimate for this value (if applicable) is getTimeUncertaintyNanos(). ", "parameters": null}, {"returns": [{"scri": "This value will never be null.", "type": "byte[]"}], "class": "android.location.GpsSatellite\n", "type": "byte[]", "name": "getData", "throws": null, "funcname": "byte[] getData ()", "descri": "  Gets the data of the reported GPS message. The bytes (or words) specified using big endian format (MSB first). For GPS L1 C/A, Beidou D1 & Beidou D2, each subframe contains 10 30-bit words. Each word (30 bits) should be fit into the last 30 bits in a 4-byte word (skip B31 and B32), with MSB first, for a total of 40 bytes, covering a time period of 6, 6, and 0.6 seconds, respectively. For Glonass L1 C/A, each string contains 85 data bits, including the checksum.  These bits should be fit into 11 bytes, with MSB first (skip B86-B88), covering a time period of 2 seconds. For Galileo F/NAV, each word consists of 238-bit (sync & tail symbols excluded). Each word should be fit into 30-bytes, with MSB first (skip B239, B240), covering a time period of 10 seconds. For Galileo I/NAV, each page contains 2 page parts, even and odd, with a total of 2x114 = 228 bits, (sync & tail excluded) that should be fit into 29 bytes, with MSB first (skip B229-B232). ", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.location.GpsSatellite\n", "type": "int", "name": "getMessageId", "throws": null, "funcname": "int getMessageId ()", "descri": "  Gets the Message identifier. This provides an index to help with complete Navigation Message assembly. Similar identifiers within the data bits themselves often supplement this information, in ways even more specific to each message type; see the relevant satellite constellation ICDs for details. For GPS L1 C/A subframe 4 and 5, this value corresponds to the 'frame id' of the navigation message, in the range of 1-25 (Subframe 1, 2, 3 does not contain a 'frame id' and this value can be set to -1.)  For Glonass L1 C/A, this refers to the frame ID, in the range of 1-5.  For BeiDou D1, this refers to the frame number in the range of 1-24  For Beidou D2, this refers to the frame number, in the range of 1-120  For Galileo F/NAV nominal frame structure, this refers to the subframe number, in the range of 1-12  For Galileo I/NAV nominal frame structure, this refers to the subframe number in the range of 1-24 ", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.location.GpsSatellite\n", "type": "int", "name": "getSubmessageId", "throws": null, "funcname": "int getSubmessageId ()", "descri": "  Gets the sub-message identifier, relevant to the getType() of the message. For GPS L1 C/A, BeiDou D1 & BeiDou D2, the submessage id corresponds to the subframe number of the navigation message, in the range of 1-5. For Glonass L1 C/A, this refers to the String number, in the range from 1-15 For Galileo F/NAV, this refers to the page type in the range 1-6 For Galileo I/NAV, this refers to the word type in the range 1-10+ For Galileo in particular, the type information embedded within the data bits may be even more useful in interpretation, than the nominal page and word types provided in this field. ", "parameters": null}, {"returns": [{"scri": "the carrier frequency of the signal tracked in Hz.", "type": "float"}], "class": "android.location.Location\n", "type": "float", "name": "getCarrierFrequencyHz", "throws": null, "funcname": "float getCarrierFrequencyHz (int satIndex)", "descri": "  Gets the carrier frequency of the signal tracked. For example it can be the GPS central frequency for L1 = 1575.45 MHz, or L2 = 1227.60 MHz, L5 = 1176.45 MHz, varying GLO channels, etc. If the field is not set, it is the primary common use central frequency, e.g. L1 = 1575.45 MHz for GPS. For an L1, L5 receiver tracking a satellite on L1 and L5 at the same time, two measurements will be reported for this same satellite, in one all the values related to L1 will be filled, and in the other all of the values related to L5 will be filled. The value is only available if hasCarrierFrequencyHz(int) is true.  ", "parameters": [{"scri": "int: the index of the satellite in the list.", "name": "satIndex"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.location.Location\n", "type": "int", "name": "getSvid", "throws": null, "funcname": "int getSvid (int satIndex)", "descri": "  Gets the identification number for the satellite at the specific index. This svid is pseudo-random number for most constellations. It is FCN & OSN number for Glonass. The distinction is made by looking at constellation field getConstellationType(int) Expected values are in the range of: GPS: 1-32 SBAS: 120-151, 183-192 GLONASS: One of: OSN, or FCN+100  1-24 as the orbital slot number (OSN) (preferred, if known) 93-106 as the frequency channel number (FCN) (-7 to +6) plus 100.   i.e. encode FCN of -7 as 93, 0 as 100, and +6 as 106  QZSS: 193-200 Galileo: 1-36 Beidou: 1-37  ", "parameters": [{"scri": "int: the index of the satellite in the list.", "name": "satIndex"}]}, {"returns": [{"scri": "true if the satellite has almanac data", "type": "boolean"}], "class": "android.location.LocationProvider\n", "type": "boolean", "name": "hasAlmanac", "throws": null, "funcname": "boolean hasAlmanac ()", "descri": "  Returns true if the GPS engine has almanac data for the satellite. ", "parameters": null}, {"returns": [{"scri": "true if the satellite has ephemeris data", "type": "boolean"}], "class": "android.location.LocationProvider\n", "type": "boolean", "name": "hasEphemeris", "throws": null, "funcname": "boolean hasEphemeris ()", "descri": "  Returns true if the GPS engine has ephemeris data for the satellite. ", "parameters": null}, {"returns": [{"scri": "true if the satellite was used to compute the most recent fix.", "type": "boolean"}], "class": "android.location.LocationProvider\n", "type": "boolean", "name": "usedInFix", "throws": null, "funcname": "boolean usedInFix ()", "descri": "  Returns true if the satellite was used by the GPS engine when calculating the most recent GPS fix. ", "parameters": null}, {"returns": null, "class": "android.media.audiofx.EnvironmentalReverb.Settings\n", "name": "AudioEffect.Descriptor", "throws": null, "funcname": "AudioEffect.Descriptor (String type,                 String uuid,                 String connectMode,                 String name,                 String implementor)", "parameters": [{"scri": "String: UUID identifying the effect type. May be one of: EFFECT_TYPE_AEC, EFFECT_TYPE_AGC, EFFECT_TYPE_BASS_BOOST, EFFECT_TYPE_ENV_REVERB, EFFECT_TYPE_EQUALIZER, EFFECT_TYPE_NS, EFFECT_TYPE_PRESET_REVERB, EFFECT_TYPE_VIRTUALIZER, EFFECT_TYPE_DYNAMICS_PROCESSING.", "name": "type"}, {"scri": "String: UUID for this particular implementation", "name": "uuid"}, {"scri": "String: EFFECT_INSERT or EFFECT_AUXILIARY", "name": "connectMode"}, {"scri": "String: human readable effect name", "name": "name"}, {"scri": "String: human readable effect implementor name", "name": "implementor"}], "descri": "   "}, {"returns": null, "class": "android.media.audiofx.EnvironmentalReverb.Settings\n", "name": "AudioEffect.Descriptor", "throws": null, "funcname": "AudioEffect.Descriptor (String type,                 String uuid,                 String connectMode,                 String name,                 String implementor)", "parameters": [{"scri": "String: UUID identifying the effect type. May be one of: EFFECT_TYPE_AEC, EFFECT_TYPE_AGC, EFFECT_TYPE_BASS_BOOST, EFFECT_TYPE_ENV_REVERB, EFFECT_TYPE_EQUALIZER, EFFECT_TYPE_NS, EFFECT_TYPE_PRESET_REVERB, EFFECT_TYPE_VIRTUALIZER, EFFECT_TYPE_DYNAMICS_PROCESSING.", "name": "type"}, {"scri": "String: UUID for this particular implementation", "name": "uuid"}, {"scri": "String: EFFECT_INSERT or EFFECT_AUXILIARY", "name": "connectMode"}, {"scri": "String: human readable effect name", "name": "name"}, {"scri": "String: human readable effect implementor name", "name": "implementor"}], "descri": "   "}, {"returns": [{"scri": "", "type": "int"}], "class": "android.media.AudioManager.OnAudioFocusChangeListener\n", "type": "int", "name": "getAccuracy", "throws": null, "funcname": "int getAccuracy ()", "descri": "  Returns a constant describing horizontal accuracy of this provider. If the provider returns finer grain or exact location, ACCURACY_FINE is returned, otherwise if the location is only approximate then ACCURACY_COARSE is returned. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.AudioManager.OnAudioFocusChangeListener\n", "type": "boolean", "name": "requiresSatellite", "throws": null, "funcname": "boolean requiresSatellite ()", "descri": "  Returns true if the provider requires access to a satellite-based positioning system (e.g., GPS), false otherwise. ", "parameters": null}, {"returns": [{"scri": "the isEnabled() value", "type": "boolean"}], "class": "android.media.AudioRecord.OnRecordPositionUpdateListener\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "onGetEnabled", "throws": null, "funcname": "boolean onGetEnabled ()", "descri": "  Returns the isEnabled() value. Should not perform unpredictably-long operations such as network access--see the running-time comments in the class-level javadoc.  Note that to prevent churn in the settings list, there is no support for dynamically choosing to hide a setting. Instead you should have this method return false, which will disable the setting and its link to your setting activity. One reason why you might choose to do this is if LOCATION_MODE is LOCATION_MODE_OFF .  It is possible that the user may click on the setting before this method returns, so your settings activity must handle the case where it is invoked even though the setting is disabled. The simplest approach may be to simply call finish() when disabled.", "parameters": null}, {"returns": [{"scri": "one of DEFAULT,       MIC,       VOICE_UPLINK,       VOICE_DOWNLINK,       VOICE_CALL,       CAMCORDER,       VOICE_RECOGNITION,       VOICE_COMMUNICATION,       UNPROCESSED.", "type": "int"}], "class": "android.media.AudioTrack.MetricsConstants\n", "type": "int", "name": "getClientAudioSource", "throws": null, "funcname": "int getClientAudioSource ()", "descri": "  Returns the audio source being used for the recording. ", "parameters": null}, {"returns": null, "class": "android.media.browse.MediaBrowser.SubscriptionCallback\n", "type": "void", "name": "onConnectionFailed", "throws": null, "funcname": "void onConnectionFailed ()", "descri": "  Invoked when the connection to the media browser failed.", "parameters": null}, {"returns": null, "class": "android.media.browse.MediaBrowser.SubscriptionCallback\n", "type": "void", "name": "onConnectionSuspended", "throws": null, "funcname": "void onConnectionSuspended ()", "descri": "  Invoked when the client is disconnected from the media browser.", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.DrmInitData.SchemeInitData\n", "type": "static\n        \n        \n        boolean", "name": "hasProfile", "throws": null, "funcname": "boolean hasProfile (int cameraId,                 int quality)", "descri": "  Returns true if camcorder profile exists for the given camera at the given quality level. When using the Camera 2 API in LEGACY mode (i.e. when INFO_SUPPORTED_HARDWARE_LEVEL is set to INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY), hasProfile(int) may return true for unsupported resolutions.  To ensure a a given resolution is supported in LEGACY mode, the configuration given in SCALER_STREAM_CONFIGURATION_MAP must contain the the resolution in the supported output sizes.  The recommended way to check this is with getOutputSizes(Class) with the class of the desired recording endpoint, and check that the desired resolution is contained in the list returned.    See also: CameraManagerCameraCharacteristics", "parameters": [{"scri": "int: the id for the camera", "name": "cameraId"}, {"scri": "int: the target quality level for the camcorder profile", "name": "quality"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.DrmInitData.SchemeInitData\n", "type": "static\n        \n        \n        boolean", "name": "hasProfile", "throws": null, "funcname": "boolean hasProfile (int quality)", "descri": "  Returns true if camcorder profile exists for the first back-facing camera at the given quality level. When using the Camera 2 API in LEGACY mode (i.e. when INFO_SUPPORTED_HARDWARE_LEVEL is set to INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY), hasProfile(int) may return true for unsupported resolutions.  To ensure a a given resolution is supported in LEGACY mode, the configuration given in SCALER_STREAM_CONFIGURATION_MAP must contain the the resolution in the supported output sizes.  The recommended way to check this is with getOutputSizes(Class) with the class of the desired recording endpoint, and check that the desired resolution is contained in the list returned.    See also: CameraManagerCameraCharacteristics", "parameters": [{"scri": "int: the target quality level for the camcorder profile", "name": "quality"}]}, {"returns": null, "class": "android.media.effect.EffectContext\n", "type": "void", "name": "onError", "throws": null, "funcname": "void onError (String mediaId)", "descri": "  Called there was an error retrieving it or the connected service doesn't support getItem(String, MediaBrowser.ItemCallback). ", "parameters": [{"scri": "String: The media id of the media item which could not be loaded.This value must never be null.", "name": "mediaId"}]}, {"returns": null, "class": "android.media.effect.EffectContext\n", "type": "void", "name": "onItemLoaded", "throws": null, "funcname": "void onItemLoaded (MediaBrowser.MediaItem item)", "descri": "  Called when the item has been returned by the connected service. ", "parameters": [{"scri": "MediaBrowser.MediaItem: The item that was returned or null if it doesn't exist.", "name": "item"}]}, {"returns": null, "class": "android.media.effect.EffectFactory\n", "type": "void", "name": "onChildrenLoaded", "throws": null, "funcname": "void onChildrenLoaded (String parentId,                 List<MediaBrowser.MediaItem> children,                 Bundle options)", "descri": "  Called when the list of children is loaded or updated. ", "parameters": [{"scri": "String: The media id of the parent media item.This value must never be null.", "name": "parentId"}, {"scri": "List: The children which were loaded.This value must never be null.", "name": "children"}, {"scri": "Bundle: The bundle of service-specific arguments sent to the media            browser service. The contents of this bundle may affect the            information returned when browsing.This value must never be null.", "name": "options"}]}, {"returns": null, "class": "android.media.effect.EffectFactory\n", "type": "void", "name": "onError", "throws": null, "funcname": "void onError (String parentId,                 Bundle options)", "descri": "  Called when the id doesn't exist or other errors in subscribing. If this is called, the subscription remains until unsubscribe(String) called, because some errors may heal themselves. ", "parameters": [{"scri": "String: The media id of the parent media item whose children could            not be loaded.This value must never be null.", "name": "parentId"}, {"scri": "Bundle: The bundle of service-specific arguments sent to the media            browser service.This value must never be null.", "name": "options"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.media.ExifInterface\n", "type": "static\n        \n        \n        int", "name": "getJpegEncodingQualityParameter", "throws": null, "funcname": "int getJpegEncodingQualityParameter (int quality)", "descri": "  Returns a pre-defined still image capture (jpeg) quality level used for the given quality level in the Camera application for the first back-facing camera on the device. If the device has no back-facing camera, this returns 0.  ", "parameters": [{"scri": "int: The target quality level", "name": "quality"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.media.ExifInterface\n", "type": "static\n        \n        \n        int", "name": "getJpegEncodingQualityParameter", "throws": null, "funcname": "int getJpegEncodingQualityParameter (int cameraId,                 int quality)", "descri": "  Returns a pre-defined still image capture (jpeg) quality level used for the given quality level in the Camera application for the specified camera.  ", "parameters": [{"scri": "int: The id of the camera", "name": "cameraId"}, {"scri": "int: The target quality level", "name": "quality"}]}, {"returns": null, "class": "android.media.MediaCas.Session\n", "type": "void", "name": "play", "throws": null, "funcname": "void play (int soundName)", "descri": "   Play one of the predefined platform sounds for media actions.  Use this method to play a platform-specific sound for various media actions. The sound playback is done asynchronously, with the same behavior and content as the sounds played by Camera.takePicture, MediaRecorder.start, and MediaRecorder.stop.  With the camera2 API, this method can be used to play standard camera operation sounds with the appropriate system behavior for such sounds.  With the older Camera API, using this method makes it easy to match the default device sounds when recording or capturing data through the preview callbacks, or when implementing custom camera-like features in your application.  If the sound has not been loaded by load(int) before calling play, play will load the sound at the cost of some additional latency before sound playback begins.   See also: takePicture(Camera.ShutterCallback, Camera.PictureCallback, Camera.PictureCallback)MediaRecorderSHUTTER_CLICKFOCUS_COMPLETESTART_VIDEO_RECORDINGSTOP_VIDEO_RECORDING", "parameters": [{"scri": "int: The type of sound to play, selected from         SHUTTER_CLICK, FOCUS_COMPLETE, START_VIDEO_RECORDING, or         STOP_VIDEO_RECORDING.", "name": "soundName"}]}, {"returns": null, "class": "android.media.MediaCasException.DeniedByServerException\n", "type": "void", "name": "replace", "throws": [{"scri": "if the player is uninitialized or if there         is a critical failure. In that case, the VolumeShaper should be         recreated.", "type": "IllegalStateException"}], "funcname": "void replace (VolumeShaper.Configuration configuration,                 VolumeShaper.Operation operation,                 boolean join)", "descri": "  Replaces the current VolumeShaper configuration with a new configuration. This allows the user to change the volume shape while the existing VolumeShaper is in effect. The effect of replace() is similar to an atomic close of the existing VolumeShaper and creation of a new VolumeShaper. If the operation is PLAY then the new curve starts immediately. If the operation is REVERSE, then the new curve will be delayed until PLAY is applied.   ", "parameters": [{"scri": "VolumeShaper.Configuration: the new configuration to use.This value must never be null.", "name": "configuration"}, {"scri": "VolumeShaper.Operation: the operation to apply to the VolumeShaperThis value must never be null.", "name": "operation"}, {"scri": "boolean: if true, match the start volume of the             new configuration to the current volume of the existing             VolumeShaper, to avoid discontinuity.", "name": "join"}]}, {"returns": null, "class": "android.media.MediaCodec.MetricsConstants\n", "type": "void", "name": "set", "throws": null, "funcname": "void set (int newOffset,                 int newSize,                 long newTimeUs,                 int newFlags)", "descri": "  Update the buffer metadata information. ", "parameters": [{"scri": "int: the start-offset of the data in the buffer.", "name": "newOffset"}, {"scri": "int: the amount of data (in bytes) in the buffer.", "name": "newSize"}, {"scri": "long: the presentation timestamp in microseconds.", "name": "newTimeUs"}, {"scri": "int: buffer flags associated with the buffer.  This should be a combination of  BUFFER_FLAG_KEY_FRAME and BUFFER_FLAG_END_OF_STREAM.", "name": "newFlags"}]}, {"returns": [{"scri": "the initial bearing in degrees", "type": "float"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "float", "name": "bearingTo", "throws": null, "funcname": "float bearingTo (Location dest)", "descri": "  Returns the approximate initial bearing in degrees East of true North when traveling along the shortest path between this location and the given location.  The shortest path is defined using the WGS84 ellipsoid.  Locations that are (nearly) antipodal may produce meaningless results.  ", "parameters": [{"scri": "Location: the destination location", "name": "dest"}]}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "static\n        \n        \n        void", "name": "distanceBetween", "throws": [{"scri": "if results is null or has length < 1", "type": "IllegalArgumentException"}], "funcname": "void distanceBetween (double startLatitude,                 double startLongitude,                 double endLatitude,                 double endLongitude,                 float[] results)", "descri": "  Computes the approximate distance in meters between two locations, and optionally the initial and final bearings of the shortest path between them.  Distance and bearing are defined using the WGS84 ellipsoid. The computed distance is stored in results[0].  If results has length 2 or greater, the initial bearing is stored in results[1]. If results has length 3 or greater, the final bearing is stored in results[2].   ", "parameters": [{"scri": "double: the starting latitude", "name": "startLatitude"}, {"scri": "double: the starting longitude", "name": "startLongitude"}, {"scri": "double: the ending latitude", "name": "endLatitude"}, {"scri": "double: the ending longitude", "name": "endLongitude"}, {"scri": "float: an array of floats to hold the results", "name": "results"}]}, {"returns": [{"scri": "the approximate distance in meters", "type": "float"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "float", "name": "distanceTo", "throws": null, "funcname": "float distanceTo (Location dest)", "descri": "  Returns the approximate distance in meters between this location and the given location.  Distance is defined using the WGS84 ellipsoid.  ", "parameters": [{"scri": "Location: the destination location", "name": "dest"}]}, {"returns": [{"scri": "", "type": "float"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "float", "name": "getAccuracy", "throws": null, "funcname": "float getAccuracy ()", "descri": "  Get the estimated horizontal accuracy of this location, radial, in meters. We define horizontal accuracy as the radius of 68% confidence. In other words, if you draw a circle centered at this location's latitude and longitude, and with a radius equal to the accuracy, then there is a 68% probability that the true location is inside the circle. This accuracy estimation is only concerned with horizontal accuracy, and does not indicate the accuracy of bearing, velocity or altitude if those are included in this Location. If this location does not have a horizontal accuracy, then 0.0 is returned. All locations generated by the LocationManager include horizontal accuracy. ", "parameters": null}, {"returns": [{"scri": "", "type": "double"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "double", "name": "getAltitude", "throws": null, "funcname": "double getAltitude ()", "descri": "  Get the altitude if available, in meters above the WGS 84 reference ellipsoid. If this location does not have an altitude then 0.0 is returned. ", "parameters": null}, {"returns": [{"scri": "", "type": "float"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "float", "name": "getBearing", "throws": null, "funcname": "float getBearing ()", "descri": "  Get the bearing, in degrees. Bearing is the horizontal direction of travel of this device, and is not related to the device orientation. It is guaranteed to be in the range (0.0, 360.0] if the device has a bearing. If this location does not have a bearing then 0.0 is returned. ", "parameters": null}, {"returns": [{"scri": "", "type": "float"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "float", "name": "getBearingAccuracyDegrees", "throws": null, "funcname": "float getBearingAccuracyDegrees ()", "descri": "  Get the estimated bearing accuracy of this location, in degrees. We define bearing accuracy at 68% confidence.  Specifically, as 1-side of the 2-sided range on each side of the estimated bearing reported by getBearing(), within which there is a 68% probability of finding the true bearing. In the case where the underlying distribution is assumed Gaussian normal, this would be considered 1 standard deviation. For example, if getBearing() returns 60, and getBearingAccuracyDegrees() returns 10, then there is a 68% probability of the true bearing being between 50 and 70 degrees. If this location does not have a bearing accuracy, then 0.0 is returned. ", "parameters": null}, {"returns": [{"scri": "elapsed real-time of fix, in nanoseconds since system boot.", "type": "long"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "long", "name": "getElapsedRealtimeNanos", "throws": null, "funcname": "long getElapsedRealtimeNanos ()", "descri": "  Return the time of this fix, in elapsed real-time since system boot. This value can be reliably compared to elapsedRealtimeNanos(), to calculate the age of a fix and to compare Location fixes. This is reliable because elapsed real-time is guaranteed monotonic for each system boot and continues to increment even when the system is in deep sleep (unlike getTime(). All locations generated by the LocationManager are guaranteed to have a valid elapsed real-time. ", "parameters": null}, {"returns": [{"scri": "", "type": "double"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "double", "name": "getLatitude", "throws": null, "funcname": "double getLatitude ()", "descri": "  Get the latitude, in degrees. All locations generated by the LocationManager will have a valid latitude. ", "parameters": null}, {"returns": [{"scri": "", "type": "double"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "double", "name": "getLongitude", "throws": null, "funcname": "double getLongitude ()", "descri": "  Get the longitude, in degrees. All locations generated by the LocationManager will have a valid longitude. ", "parameters": null}, {"returns": [{"scri": "", "type": "float"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "float", "name": "getSpeed", "throws": null, "funcname": "float getSpeed ()", "descri": "  Get the speed if it is available, in meters/second over ground. If this location does not have a speed then 0.0 is returned. ", "parameters": null}, {"returns": [{"scri": "", "type": "float"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "float", "name": "getSpeedAccuracyMetersPerSecond", "throws": null, "funcname": "float getSpeedAccuracyMetersPerSecond ()", "descri": "  Get the estimated speed accuracy of this location, in meters per second. We define speed accuracy at 68% confidence.  Specifically, as 1-side of the 2-sided range above and below the estimated speed reported by getSpeed(), within which there is a 68% probability of finding the true speed. In the case where the underlying distribution is assumed Gaussian normal, this would be considered 1 standard deviation. For example, if getSpeed() returns 5, and getSpeedAccuracyMetersPerSecond() returns 1, then there is a 68% probability of the true speed being between 4 and 6 meters per second. Note that the speed and speed accuracy is often better than would be obtained simply from differencing sequential positions, such as when the Doppler measurements from GNSS satellites are used. If this location does not have a speed accuracy, then 0.0 is returned. ", "parameters": null}, {"returns": [{"scri": "time of fix, in milliseconds since January 1, 1970.", "type": "long"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "long", "name": "getTime", "throws": null, "funcname": "long getTime ()", "descri": "  Return the UTC time of this fix, in milliseconds since January 1, 1970. Note that the UTC time on a device is not monotonic: it can jump forwards or backwards unpredictably. So always use getElapsedRealtimeNanos() when calculating time deltas. On the other hand, getTime() is useful for presenting a human readable time to the user, or for carefully comparing location fixes across reboot or across devices. All locations generated by the LocationManager are guaranteed to have a valid UTC time, however remember that the system time may have changed since the location was generated. ", "parameters": null}, {"returns": [{"scri": "", "type": "float"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "float", "name": "getVerticalAccuracyMeters", "throws": null, "funcname": "float getVerticalAccuracyMeters ()", "descri": "  Get the estimated vertical accuracy of this location, in meters. We define vertical accuracy at 68% confidence.  Specifically, as 1-side of the 2-sided range above and below the estimated altitude reported by getAltitude(), within which there is a 68% probability of finding the true altitude. In the case where the underlying distribution is assumed Gaussian normal, this would be considered 1 standard deviation. For example, if getAltitude() returns 150, and getVerticalAccuracyMeters() returns 20 then there is a 68% probability of the true altitude being between 130 and 170 meters. If this location does not have a vertical accuracy, then 0.0 is returned. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "boolean", "name": "hasAccuracy", "throws": null, "funcname": "boolean hasAccuracy ()", "descri": "  True if this location has a horizontal accuracy. All locations generated by the LocationManager have an horizontal accuracy. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "boolean", "name": "hasAltitude", "throws": null, "funcname": "boolean hasAltitude ()", "descri": "  True if this location has an altitude. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "boolean", "name": "hasBearing", "throws": null, "funcname": "boolean hasBearing ()", "descri": "  True if this location has a bearing. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "boolean", "name": "hasBearingAccuracy", "throws": null, "funcname": "boolean hasBearingAccuracy ()", "descri": "  True if this location has a bearing accuracy. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "boolean", "name": "hasSpeed", "throws": null, "funcname": "boolean hasSpeed ()", "descri": "  True if this location has a speed. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "boolean", "name": "hasSpeedAccuracy", "throws": null, "funcname": "boolean hasSpeedAccuracy ()", "descri": "  True if this location has a speed accuracy. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "boolean", "name": "hasVerticalAccuracy", "throws": null, "funcname": "boolean hasVerticalAccuracy ()", "descri": "  True if this location has a vertical accuracy. ", "parameters": null}, {"returns": [{"scri": "true if this Location came from a mock provider, false otherwise", "type": "boolean"}], "class": "android.media.MediaDrm.HdcpLevel\n", "type": "boolean", "name": "isFromMockProvider", "throws": null, "funcname": "boolean isFromMockProvider ()", "descri": "  Returns true if the Location came from a mock provider. ", "parameters": null}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "removeAccuracy", "throws": null, "funcname": "void removeAccuracy ()", "descri": "   This method was deprecated      in API level 26.    use a new Location object for location updates.  Remove the horizontal accuracy from this location. Following this call hasAccuracy() will return false, and getAccuracy() will return 0.0.", "parameters": null}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "removeAltitude", "throws": null, "funcname": "void removeAltitude ()", "descri": "   This method was deprecated      in API level 26.    use a new Location object for location updates.  Remove the altitude from this location. Following this call hasAltitude() will return false, and getAltitude() will return 0.0.", "parameters": null}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "removeBearing", "throws": null, "funcname": "void removeBearing ()", "descri": "   This method was deprecated      in API level 26.    use a new Location object for location updates.  Remove the bearing from this location. Following this call hasBearing() will return false, and getBearing() will return 0.0.", "parameters": null}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "removeSpeed", "throws": null, "funcname": "void removeSpeed ()", "descri": "   This method was deprecated      in API level 26.    use a new Location object for location updates.  Remove the speed from this location. Following this call hasSpeed() will return false, and getSpeed() will return 0.0.", "parameters": null}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "reset", "throws": null, "funcname": "void reset ()", "descri": "  Clears the contents of the location.", "parameters": null}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "set", "throws": null, "funcname": "void set (Location l)", "descri": "  Sets the contents of the location to the values from the given location. ", "parameters": [{"scri": "Location", "name": "l"}]}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "setAccuracy", "throws": null, "funcname": "void setAccuracy (float horizontalAccuracy)", "descri": "  Set the estimated horizontal accuracy of this location, meters. See getAccuracy() for the definition of horizontal accuracy. Following this call hasAccuracy() will return true. ", "parameters": [{"scri": "float", "name": "horizontalAccuracy"}]}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "setBearingAccuracyDegrees", "throws": null, "funcname": "void setBearingAccuracyDegrees (float bearingAccuracyDegrees)", "descri": "  Set the estimated bearing accuracy of this location, degrees. See getBearingAccuracyDegrees() for the definition of bearing accuracy. Following this call hasBearingAccuracy() will return true. ", "parameters": [{"scri": "float", "name": "bearingAccuracyDegrees"}]}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "setSpeedAccuracyMetersPerSecond", "throws": null, "funcname": "void setSpeedAccuracyMetersPerSecond (float speedAccuracyMeterPerSecond)", "descri": "  Set the estimated speed accuracy of this location, meters per second. See getSpeedAccuracyMetersPerSecond() for the definition of speed accuracy. Following this call hasSpeedAccuracy() will return true. ", "parameters": [{"scri": "float", "name": "speedAccuracyMeterPerSecond"}]}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "type": "void", "name": "setVerticalAccuracyMeters", "throws": null, "funcname": "void setVerticalAccuracyMeters (float verticalAccuracyMeters)", "descri": "  Set the estimated vertical accuracy of this location, meters. See getVerticalAccuracyMeters() for the definition of vertical accuracy. Following this call hasVerticalAccuracy() will return true. ", "parameters": [{"scri": "float", "name": "verticalAccuracyMeters"}]}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "name": "Location", "throws": null, "funcname": "Location (String provider)", "parameters": [{"scri": "String: the name of the provider that generated this location", "name": "provider"}], "descri": "  Construct a new Location with a named provider. By default time, latitude and longitude are 0, and the location has no bearing, altitude, speed, accuracy or extras. "}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "name": "Location", "throws": null, "funcname": "Location (Location l)", "parameters": [{"scri": "Location", "name": "l"}], "descri": "  Construct a new Location object that is copied from an existing one. "}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "name": "Location", "throws": null, "funcname": "Location (String provider)", "parameters": [{"scri": "String: the name of the provider that generated this location", "name": "provider"}], "descri": "  Construct a new Location with a named provider. By default time, latitude and longitude are 0, and the location has no bearing, altitude, speed, accuracy or extras. "}, {"returns": null, "class": "android.media.MediaDrm.HdcpLevel\n", "name": "Location", "throws": null, "funcname": "Location (Location l)", "parameters": [{"scri": "Location", "name": "l"}], "descri": "  Construct a new Location object that is copied from an existing one. "}, {"returns": [{"scri": "true if the listener was successfully added", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "addGpsStatusListener", "throws": [{"scri": "if the ACCESS_FINE_LOCATION permission is not present", "type": "SecurityException"}], "funcname": "boolean addGpsStatusListener (GpsStatus.Listener listener)", "descri": "   This method was deprecated      in API level 24.    use registerGnssStatusCallback(GnssStatus.Callback) instead.  Adds a GPS status listener. Requires the ACCESS_FINE_LOCATION permission.    ", "parameters": [{"scri": "GpsStatus.Listener: GPS status listener object to register", "name": "listener"}]}, {"returns": [{"scri": "true if the listener was successfully added", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "addNmeaListener", "throws": [{"scri": "if the ACCESS_FINE_LOCATION permission is not present", "type": "SecurityException"}], "funcname": "boolean addNmeaListener (OnNmeaMessageListener listener,                 Handler handler)", "descri": "  Adds an NMEA listener. Requires the ACCESS_FINE_LOCATION permission.    ", "parameters": [{"scri": "OnNmeaMessageListener: a OnNmeaMessageListener object to register", "name": "listener"}, {"scri": "Handler: the handler that the listener runs on.", "name": "handler"}]}, {"returns": [{"scri": "true if the listener was successfully added", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "addNmeaListener", "throws": [{"scri": "if the ACCESS_FINE_LOCATION permission is not present", "type": "SecurityException"}], "funcname": "boolean addNmeaListener (OnNmeaMessageListener listener)", "descri": "  Adds an NMEA listener. Requires the ACCESS_FINE_LOCATION permission.    ", "parameters": [{"scri": "OnNmeaMessageListener: a OnNmeaMessageListener object to register", "name": "listener"}]}, {"returns": [{"scri": "true if the listener was successfully added", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "addNmeaListener", "throws": [{"scri": "if the ACCESS_FINE_LOCATION permission is not present", "type": "SecurityException"}], "funcname": "boolean addNmeaListener (GpsStatus.NmeaListener listener)", "descri": "   This method was deprecated      in API level 24.    use addNmeaListener(OnNmeaMessageListener) instead.  Adds an NMEA listener. Requires the ACCESS_FINE_LOCATION permission.    ", "parameters": [{"scri": "GpsStatus.NmeaListener: a GpsStatus.NmeaListener object to register", "name": "listener"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "addProximityAlert", "throws": [{"scri": "if ACCESS_FINE_LOCATION permission is not present", "type": "SecurityException"}], "funcname": "void addProximityAlert (double latitude,                 double longitude,                 float radius,                 long expiration,                 PendingIntent intent)", "descri": "  Set a proximity alert for the location given by the position (latitude, longitude) and the given radius. When the device detects that it has entered or exited the area surrounding the location, the given PendingIntent will be used to create an Intent to be fired. The fired Intent will have a boolean extra added with key KEY_PROXIMITY_ENTERING. If the value is true, the device is entering the proximity region; if false, it is exiting. Due to the approximate nature of position estimation, if the device passes through the given area briefly, it is possible that no Intent will be fired.  Similarly, an Intent could be fired if the device passes very close to the given area but does not actually enter it. After the number of milliseconds given by the expiration parameter, the location manager will delete this proximity alert and no longer monitor it.  A value of -1 indicates that there should be no expiration time. Internally, this method uses both NETWORK_PROVIDER and GPS_PROVIDER. Before API version 17, this method could be used with ACCESS_FINE_LOCATION or ACCESS_COARSE_LOCATION. From API version 17 and onwards, this method requires ACCESS_FINE_LOCATION permission. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "double: the latitude of the central point of the alert region", "name": "latitude"}, {"scri": "double: the longitude of the central point of the alert region", "name": "longitude"}, {"scri": "float: the radius of the central point of the alert region, in meters", "name": "radius"}, {"scri": "long: time for this proximity alert, in milliseconds, or -1 to indicate no expiration", "name": "expiration"}, {"scri": "PendingIntent: a PendingIntent that will be used to generate an Intent to fire when entry to or exit from the alert region is detected", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "addTestProvider", "throws": [{"scri": "if mock location app op is not set to allowed for your app.", "type": "SecurityException"}, {"scri": "if a provider with the given name already exists", "type": "IllegalArgumentException"}], "funcname": "void addTestProvider (String name,                 boolean requiresNetwork,                 boolean requiresSatellite,                 boolean requiresCell,                 boolean hasMonetaryCost,                 boolean supportsAltitude,                 boolean supportsSpeed,                 boolean supportsBearing,                 int powerRequirement,                 int accuracy)", "descri": "  Creates a mock location provider and adds it to the set of active providers.   ", "parameters": [{"scri": "String: the provider name", "name": "name"}, {"scri": "boolean", "name": "requiresNetwork"}, {"scri": "boolean", "name": "requiresSatellite"}, {"scri": "boolean", "name": "requiresCell"}, {"scri": "boolean", "name": "hasMonetaryCost"}, {"scri": "boolean", "name": "supportsAltitude"}, {"scri": "boolean", "name": "supportsSpeed"}, {"scri": "boolean", "name": "supportsBearing"}, {"scri": "int", "name": "powerRequirement"}, {"scri": "int", "name": "accuracy"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "clearTestProviderLocation", "throws": [{"scri": "if mock location app op is not set to allowed for your app.", "type": "SecurityException"}, {"scri": "if no provider with the given name exists", "type": "IllegalArgumentException"}], "funcname": "void clearTestProviderLocation (String provider)", "descri": "  Removes any mock location associated with the given provider.   ", "parameters": [{"scri": "String: the provider name", "name": "provider"}]}, {"returns": [{"scri": "true if location is enabled. false if location is disabled.", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "isLocationEnabled", "throws": null, "funcname": "boolean isLocationEnabled ()", "descri": "  Returns the current enabled/disabled status of location ", "parameters": null}, {"returns": [{"scri": "true if the provider exists and is enabled", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "isProviderEnabled", "throws": [{"scri": "if provider is null", "type": "IllegalArgumentException"}], "funcname": "boolean isProviderEnabled (String provider)", "descri": "  Returns the current enabled/disabled status of the given provider. If the user has enabled this provider in the Settings menu, true is returned otherwise false is returned Callers should instead use isLocationEnabled() unless they depend on provider-specific APIs such as requestLocationUpdates(String, long, float, LocationListener). Before API version LOLLIPOP, this method would throw SecurityException if the location permissions were not sufficient to use the specified provider.    ", "parameters": [{"scri": "String: the name of the provider", "name": "provider"}]}, {"returns": [{"scri": "true if the callback was added successfully, false otherwise.", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "registerGnssMeasurementsCallback", "throws": null, "funcname": "boolean registerGnssMeasurementsCallback (GnssMeasurementsEvent.Callback callback)", "descri": "  Registers a GPS Measurement callback. Requires the ACCESS_FINE_LOCATION permission.  ", "parameters": [{"scri": "GnssMeasurementsEvent.Callback: a GnssMeasurementsEvent.Callback object to register.", "name": "callback"}]}, {"returns": [{"scri": "true if the callback was added successfully, false otherwise.", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "registerGnssMeasurementsCallback", "throws": null, "funcname": "boolean registerGnssMeasurementsCallback (GnssMeasurementsEvent.Callback callback,                 Handler handler)", "descri": "  Registers a GPS Measurement callback. Requires the ACCESS_FINE_LOCATION permission.  ", "parameters": [{"scri": "GnssMeasurementsEvent.Callback: a GnssMeasurementsEvent.Callback object to register.", "name": "callback"}, {"scri": "Handler: the handler that the callback runs on.", "name": "handler"}]}, {"returns": [{"scri": "true if the callback was added successfully, false otherwise.", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "registerGnssNavigationMessageCallback", "throws": null, "funcname": "boolean registerGnssNavigationMessageCallback (GnssNavigationMessage.Callback callback,                 Handler handler)", "descri": "  Registers a GNSS Navigation Message callback. Requires the ACCESS_FINE_LOCATION permission.  ", "parameters": [{"scri": "GnssNavigationMessage.Callback: a GnssNavigationMessage.Callback object to register.", "name": "callback"}, {"scri": "Handler: the handler that the callback runs on.", "name": "handler"}]}, {"returns": [{"scri": "true if the listener was successfully added", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "registerGnssStatusCallback", "throws": [{"scri": "if the ACCESS_FINE_LOCATION permission is not present", "type": "SecurityException"}], "funcname": "boolean registerGnssStatusCallback (GnssStatus.Callback callback)", "descri": "  Registers a GNSS status callback. Requires the ACCESS_FINE_LOCATION permission.    ", "parameters": [{"scri": "GnssStatus.Callback: GNSS status callback object to register", "name": "callback"}]}, {"returns": [{"scri": "true if the listener was successfully added", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "registerGnssStatusCallback", "throws": [{"scri": "if the ACCESS_FINE_LOCATION permission is not present", "type": "SecurityException"}], "funcname": "boolean registerGnssStatusCallback (GnssStatus.Callback callback,                 Handler handler)", "descri": "  Registers a GNSS status callback. Requires the ACCESS_FINE_LOCATION permission.    ", "parameters": [{"scri": "GnssStatus.Callback: GNSS status callback object to register", "name": "callback"}, {"scri": "Handler: the handler that the callback runs on.", "name": "handler"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "removeGpsStatusListener", "throws": null, "funcname": "void removeGpsStatusListener (GpsStatus.Listener listener)", "descri": "   This method was deprecated      in API level 24.    use unregisterGnssStatusCallback(GnssStatus.Callback) instead.  Removes a GPS status listener. ", "parameters": [{"scri": "GpsStatus.Listener: GPS status listener object to remove", "name": "listener"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "removeProximityAlert", "throws": [{"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if ACCESS_FINE_LOCATION permission is not present", "type": "SecurityException"}], "funcname": "void removeProximityAlert (PendingIntent intent)", "descri": "  Removes the proximity alert with the given PendingIntent. Before API version 17, this method could be used with ACCESS_FINE_LOCATION or ACCESS_COARSE_LOCATION. From API version 17 and onwards, this method requires ACCESS_FINE_LOCATION permission.   ", "parameters": [{"scri": "PendingIntent: the PendingIntent that no longer needs to be notified of proximity alerts", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "removeTestProvider", "throws": [{"scri": "if mock location app op is not set to allowed for your app.", "type": "SecurityException"}, {"scri": "if no provider with the given name exists", "type": "IllegalArgumentException"}], "funcname": "void removeTestProvider (String provider)", "descri": "  Removes the mock location provider with the given name.   ", "parameters": [{"scri": "String: the provider name", "name": "provider"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "removeUpdates", "throws": [{"scri": "if listener is null", "type": "IllegalArgumentException"}], "funcname": "void removeUpdates (LocationListener listener)", "descri": "  Removes all location updates for the specified LocationListener. Following this call, updates will no longer occur for this listener.   ", "parameters": [{"scri": "LocationListener: listener object that no longer needs location updates", "name": "listener"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "removeUpdates", "throws": [{"scri": "if intent is null", "type": "IllegalArgumentException"}], "funcname": "void removeUpdates (PendingIntent intent)", "descri": "  Removes all location updates for the specified pending intent. Following this call, updates will no longer for this pending intent.   ", "parameters": [{"scri": "PendingIntent: pending intent object that no longer needs location updates", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist on this device", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if the calling thread has no Looper", "type": "RuntimeException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 LocationListener listener)", "descri": "  Register for location updates using the named provider, and a pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist on this device", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if the calling thread has no Looper", "type": "RuntimeException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 LocationListener listener)", "descri": "  Register for location updates using the named provider, and a pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist on this device", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if the calling thread has no Looper", "type": "RuntimeException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 LocationListener listener)", "descri": "  Register for location updates using the named provider, and a pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (long minTime,                 float minDistance,                 Criteria criteria,                 LocationListener listener,                 Looper looper)", "descri": "  Register for location updates using a Criteria, and a callback on the specified looper thread. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (long minTime,                 float minDistance,                 Criteria criteria,                 LocationListener listener,                 Looper looper)", "descri": "  Register for location updates using a Criteria, and a callback on the specified looper thread. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (long minTime,                 float minDistance,                 Criteria criteria,                 LocationListener listener,                 Looper looper)", "descri": "  Register for location updates using a Criteria, and a callback on the specified looper thread. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (long minTime,                 float minDistance,                 Criteria criteria,                 LocationListener listener,                 Looper looper)", "descri": "  Register for location updates using a Criteria, and a callback on the specified looper thread. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 LocationListener listener,                 Looper looper)", "descri": "  Register for location updates using the named provider, and a callback on the specified looper thread. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 LocationListener listener,                 Looper looper)", "descri": "  Register for location updates using the named provider, and a callback on the specified looper thread. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 LocationListener listener,                 Looper looper)", "descri": "  Register for location updates using the named provider, and a callback on the specified looper thread. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called for each location update", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (long minTime,                 float minDistance,                 Criteria criteria,                 PendingIntent intent)", "descri": "  Register for location updates using a Criteria and pending intent. The requestLocationUpdates() and requestSingleUpdate() register the current activity to be updated periodically by the named provider, or by the provider matching the specified Criteria, with location and status updates. It may take a while to receive the first location update. If an immediate location is required, applications may use the getLastKnownLocation(String) method. Location updates are received either by LocationListener callbacks, or by broadcast intents to a supplied PendingIntent. If the caller supplied a pending intent, then location updates are sent with a key of KEY_LOCATION_CHANGED and a Location value. The location update interval can be controlled using the minTime parameter. The elapsed time between location updates will never be less than minTime, although it can be more depending on the Location Provider implementation and the update interval requested by other applications. Choosing a sensible value for minTime is important to conserve battery life. Each location update requires power from GPS, WIFI, Cell and other radios. Select a minTime value as high as possible while still providing a reasonable user experience. If your application is not in the foreground and showing location to the user then your application should avoid using an active provider (such as NETWORK_PROVIDER or GPS_PROVIDER), but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes) or greater. If your application is in the foreground and showing location to the user then it is appropriate to select a faster update interval. The minDistance parameter can also be used to control the frequency of location updates. If it is greater than 0 then the location provider will only send your application an update when the location has changed by at least minDistance meters, AND at least minTime milliseconds have passed. However it is more difficult for location providers to save power using the minDistance parameter, so minTime should be the primary tool to conserving battery life. If your application wants to passively observe location updates triggered by other applications, but not consume any additional power otherwise, then use the PASSIVE_PROVIDER This provider does not actively turn on or modify active location providers, so you do not need to be as careful about minTime and minDistance. However if your application performs heavy work on a location update (such as network activity) then you should select non-zero values for minTime and/or minDistance to rate-limit your update frequency in the case another application enables a location provider with extremely fast updates. In case the provider is disabled by the user, updates will stop, and a provider availability update will be sent. As soon as the provider is enabled again, location updates will immediately resume and a provider availability update sent. Providers can also send status updates, at any time, with extra's specific to the provider. If a callback was supplied then status and availability updates are via onProviderDisabled(String), onProviderEnabled(String) or onStatusChanged(String, int, Bundle). Alternately, if a pending intent was supplied then status and availability updates are broadcast intents with extra keys of KEY_PROVIDER_ENABLED or KEY_STATUS_CHANGED. If a LocationListener is used but with no Looper specified then the calling thread must already be a Looper thread such as the main thread of the calling Activity. If a Looper is specified with a LocationListener then callbacks are made on the supplied Looper thread. Prior to Jellybean, the minTime parameter was only a hint, and some location provider implementations ignored it. From Jellybean and onwards it is mandatory for Android compatible devices to observe both the minTime and minDistance parameters. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "PendingIntent: a PendingIntent to be sent for each location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (long minTime,                 float minDistance,                 Criteria criteria,                 PendingIntent intent)", "descri": "  Register for location updates using a Criteria and pending intent. The requestLocationUpdates() and requestSingleUpdate() register the current activity to be updated periodically by the named provider, or by the provider matching the specified Criteria, with location and status updates. It may take a while to receive the first location update. If an immediate location is required, applications may use the getLastKnownLocation(String) method. Location updates are received either by LocationListener callbacks, or by broadcast intents to a supplied PendingIntent. If the caller supplied a pending intent, then location updates are sent with a key of KEY_LOCATION_CHANGED and a Location value. The location update interval can be controlled using the minTime parameter. The elapsed time between location updates will never be less than minTime, although it can be more depending on the Location Provider implementation and the update interval requested by other applications. Choosing a sensible value for minTime is important to conserve battery life. Each location update requires power from GPS, WIFI, Cell and other radios. Select a minTime value as high as possible while still providing a reasonable user experience. If your application is not in the foreground and showing location to the user then your application should avoid using an active provider (such as NETWORK_PROVIDER or GPS_PROVIDER), but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes) or greater. If your application is in the foreground and showing location to the user then it is appropriate to select a faster update interval. The minDistance parameter can also be used to control the frequency of location updates. If it is greater than 0 then the location provider will only send your application an update when the location has changed by at least minDistance meters, AND at least minTime milliseconds have passed. However it is more difficult for location providers to save power using the minDistance parameter, so minTime should be the primary tool to conserving battery life. If your application wants to passively observe location updates triggered by other applications, but not consume any additional power otherwise, then use the PASSIVE_PROVIDER This provider does not actively turn on or modify active location providers, so you do not need to be as careful about minTime and minDistance. However if your application performs heavy work on a location update (such as network activity) then you should select non-zero values for minTime and/or minDistance to rate-limit your update frequency in the case another application enables a location provider with extremely fast updates. In case the provider is disabled by the user, updates will stop, and a provider availability update will be sent. As soon as the provider is enabled again, location updates will immediately resume and a provider availability update sent. Providers can also send status updates, at any time, with extra's specific to the provider. If a callback was supplied then status and availability updates are via onProviderDisabled(String), onProviderEnabled(String) or onStatusChanged(String, int, Bundle). Alternately, if a pending intent was supplied then status and availability updates are broadcast intents with extra keys of KEY_PROVIDER_ENABLED or KEY_STATUS_CHANGED. If a LocationListener is used but with no Looper specified then the calling thread must already be a Looper thread such as the main thread of the calling Activity. If a Looper is specified with a LocationListener then callbacks are made on the supplied Looper thread. Prior to Jellybean, the minTime parameter was only a hint, and some location provider implementations ignored it. From Jellybean and onwards it is mandatory for Android compatible devices to observe both the minTime and minDistance parameters. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "PendingIntent: a PendingIntent to be sent for each location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (long minTime,                 float minDistance,                 Criteria criteria,                 PendingIntent intent)", "descri": "  Register for location updates using a Criteria and pending intent. The requestLocationUpdates() and requestSingleUpdate() register the current activity to be updated periodically by the named provider, or by the provider matching the specified Criteria, with location and status updates. It may take a while to receive the first location update. If an immediate location is required, applications may use the getLastKnownLocation(String) method. Location updates are received either by LocationListener callbacks, or by broadcast intents to a supplied PendingIntent. If the caller supplied a pending intent, then location updates are sent with a key of KEY_LOCATION_CHANGED and a Location value. The location update interval can be controlled using the minTime parameter. The elapsed time between location updates will never be less than minTime, although it can be more depending on the Location Provider implementation and the update interval requested by other applications. Choosing a sensible value for minTime is important to conserve battery life. Each location update requires power from GPS, WIFI, Cell and other radios. Select a minTime value as high as possible while still providing a reasonable user experience. If your application is not in the foreground and showing location to the user then your application should avoid using an active provider (such as NETWORK_PROVIDER or GPS_PROVIDER), but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes) or greater. If your application is in the foreground and showing location to the user then it is appropriate to select a faster update interval. The minDistance parameter can also be used to control the frequency of location updates. If it is greater than 0 then the location provider will only send your application an update when the location has changed by at least minDistance meters, AND at least minTime milliseconds have passed. However it is more difficult for location providers to save power using the minDistance parameter, so minTime should be the primary tool to conserving battery life. If your application wants to passively observe location updates triggered by other applications, but not consume any additional power otherwise, then use the PASSIVE_PROVIDER This provider does not actively turn on or modify active location providers, so you do not need to be as careful about minTime and minDistance. However if your application performs heavy work on a location update (such as network activity) then you should select non-zero values for minTime and/or minDistance to rate-limit your update frequency in the case another application enables a location provider with extremely fast updates. In case the provider is disabled by the user, updates will stop, and a provider availability update will be sent. As soon as the provider is enabled again, location updates will immediately resume and a provider availability update sent. Providers can also send status updates, at any time, with extra's specific to the provider. If a callback was supplied then status and availability updates are via onProviderDisabled(String), onProviderEnabled(String) or onStatusChanged(String, int, Bundle). Alternately, if a pending intent was supplied then status and availability updates are broadcast intents with extra keys of KEY_PROVIDER_ENABLED or KEY_STATUS_CHANGED. If a LocationListener is used but with no Looper specified then the calling thread must already be a Looper thread such as the main thread of the calling Activity. If a Looper is specified with a LocationListener then callbacks are made on the supplied Looper thread. Prior to Jellybean, the minTime parameter was only a hint, and some location provider implementations ignored it. From Jellybean and onwards it is mandatory for Android compatible devices to observe both the minTime and minDistance parameters. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "PendingIntent: a PendingIntent to be sent for each location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (long minTime,                 float minDistance,                 Criteria criteria,                 PendingIntent intent)", "descri": "  Register for location updates using a Criteria and pending intent. The requestLocationUpdates() and requestSingleUpdate() register the current activity to be updated periodically by the named provider, or by the provider matching the specified Criteria, with location and status updates. It may take a while to receive the first location update. If an immediate location is required, applications may use the getLastKnownLocation(String) method. Location updates are received either by LocationListener callbacks, or by broadcast intents to a supplied PendingIntent. If the caller supplied a pending intent, then location updates are sent with a key of KEY_LOCATION_CHANGED and a Location value. The location update interval can be controlled using the minTime parameter. The elapsed time between location updates will never be less than minTime, although it can be more depending on the Location Provider implementation and the update interval requested by other applications. Choosing a sensible value for minTime is important to conserve battery life. Each location update requires power from GPS, WIFI, Cell and other radios. Select a minTime value as high as possible while still providing a reasonable user experience. If your application is not in the foreground and showing location to the user then your application should avoid using an active provider (such as NETWORK_PROVIDER or GPS_PROVIDER), but if you insist then select a minTime of 5 * 60 * 1000 (5 minutes) or greater. If your application is in the foreground and showing location to the user then it is appropriate to select a faster update interval. The minDistance parameter can also be used to control the frequency of location updates. If it is greater than 0 then the location provider will only send your application an update when the location has changed by at least minDistance meters, AND at least minTime milliseconds have passed. However it is more difficult for location providers to save power using the minDistance parameter, so minTime should be the primary tool to conserving battery life. If your application wants to passively observe location updates triggered by other applications, but not consume any additional power otherwise, then use the PASSIVE_PROVIDER This provider does not actively turn on or modify active location providers, so you do not need to be as careful about minTime and minDistance. However if your application performs heavy work on a location update (such as network activity) then you should select non-zero values for minTime and/or minDistance to rate-limit your update frequency in the case another application enables a location provider with extremely fast updates. In case the provider is disabled by the user, updates will stop, and a provider availability update will be sent. As soon as the provider is enabled again, location updates will immediately resume and a provider availability update sent. Providers can also send status updates, at any time, with extra's specific to the provider. If a callback was supplied then status and availability updates are via onProviderDisabled(String), onProviderEnabled(String) or onStatusChanged(String, int, Bundle). Alternately, if a pending intent was supplied then status and availability updates are broadcast intents with extra keys of KEY_PROVIDER_ENABLED or KEY_STATUS_CHANGED. If a LocationListener is used but with no Looper specified then the calling thread must already be a Looper thread such as the main thread of the calling Activity. If a Looper is specified with a LocationListener then callbacks are made on the supplied Looper thread. Prior to Jellybean, the minTime parameter was only a hint, and some location provider implementations ignored it. From Jellybean and onwards it is mandatory for Android compatible devices to observe both the minTime and minDistance parameters. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "PendingIntent: a PendingIntent to be sent for each location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist on this device", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 PendingIntent intent)", "descri": "  Register for location updates using the named provider, and a pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "PendingIntent: a PendingIntent to be sent for each location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist on this device", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 PendingIntent intent)", "descri": "  Register for location updates using the named provider, and a pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "PendingIntent: a PendingIntent to be sent for each location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestLocationUpdates", "throws": [{"scri": "if provider is null or doesn't exist on this device", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestLocationUpdates (String provider,                 long minTime,                 float minDistance,                 PendingIntent intent)", "descri": "  Register for location updates using the named provider, and a pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "long: minimum time interval between location updates, in milliseconds", "name": "minTime"}, {"scri": "float: minimum distance between location updates, in meters", "name": "minDistance"}, {"scri": "PendingIntent: a PendingIntent to be sent for each location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestSingleUpdate", "throws": [{"scri": "if provider is null or doesn't exist", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestSingleUpdate (String provider,                 PendingIntent intent)", "descri": "  Register for a single location update using a named provider and pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "PendingIntent: a PendingIntent to be sent for the location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestSingleUpdate", "throws": [{"scri": "if provider is null or doesn't exist", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestSingleUpdate (Criteria criteria,                 PendingIntent intent)", "descri": "  Register for a single location update using a Criteria and pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "PendingIntent: a PendingIntent to be sent for the location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestSingleUpdate", "throws": [{"scri": "if provider is null or doesn't exist", "type": "IllegalArgumentException"}, {"scri": "if intent is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestSingleUpdate (Criteria criteria,                 PendingIntent intent)", "descri": "  Register for a single location update using a Criteria and pending intent. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "PendingIntent: a PendingIntent to be sent for the location update", "name": "intent"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestSingleUpdate", "throws": [{"scri": "if provider is null or doesn't exist", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestSingleUpdate (String provider,                 LocationListener listener,                 Looper looper)", "descri": "  Register for a single location update using the named provider and a callback. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "String: the name of the provider with which to register", "name": "provider"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called when the location update is available", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestSingleUpdate", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestSingleUpdate (Criteria criteria,                 LocationListener listener,                 Looper looper)", "descri": "  Register for a single location update using a Criteria and a callback. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called when the location update is available", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "requestSingleUpdate", "throws": [{"scri": "if criteria is null", "type": "IllegalArgumentException"}, {"scri": "if listener is null", "type": "IllegalArgumentException"}, {"scri": "if no suitable permission is present", "type": "SecurityException"}], "funcname": "void requestSingleUpdate (Criteria criteria,                 LocationListener listener,                 Looper looper)", "descri": "  Register for a single location update using a Criteria and a callback. See requestLocationUpdates(long, float, Criteria, PendingIntent) for more detail on how to use this method. Requires the ACCESS_COARSE_LOCATION or ACCESS_FINE_LOCATION permissions.   ", "parameters": [{"scri": "Criteria: contains parameters for the location manager to choose the appropriate provider and parameters to compute the location", "name": "criteria"}, {"scri": "LocationListener: a LocationListener whose onLocationChanged(Location) method will be called when the location update is available", "name": "listener"}, {"scri": "Looper: a Looper object whose message queue will be used to implement the callback mechanism, or null to make callbacks on the calling thread", "name": "looper"}]}, {"returns": [{"scri": "true if the command succeeds.", "type": "boolean"}], "class": "android.media.MediaDrm.SecurityLevel\n", "type": "boolean", "name": "sendExtraCommand", "throws": null, "funcname": "boolean sendExtraCommand (String provider,                 String command,                 Bundle extras)", "descri": "  Sends additional commands to a location provider. Can be used to support provider specific extensions to the Location Manager API  ", "parameters": [{"scri": "String: name of the location provider.", "name": "provider"}, {"scri": "String: name of the command to send to the provider.", "name": "command"}, {"scri": "Bundle: optional arguments for the command (or null). The provider may optionally fill the extras Bundle with results from the command.", "name": "extras"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "setTestProviderLocation", "throws": [{"scri": "if mock location app op is not set to allowed for your app.", "type": "SecurityException"}, {"scri": "if no provider with the given name exists", "type": "IllegalArgumentException"}, {"scri": "if the location is incomplete", "type": "IllegalArgumentException"}], "funcname": "void setTestProviderLocation (String provider,                 Location loc)", "descri": "  Sets a mock location for the given provider. This location will be used in place of any actual location from the provider. The location object must have a minimum number of fields set to be considered a valid LocationProvider Location, as per documentation on Location class.   ", "parameters": [{"scri": "String: the provider name", "name": "provider"}, {"scri": "Location: the mock location", "name": "loc"}]}, {"returns": null, "class": "android.media.MediaDrm.SecurityLevel\n", "type": "void", "name": "unregisterGnssMeasurementsCallback", "throws": null, "funcname": "void unregisterGnssMeasurementsCallback (GnssMeasurementsEvent.Callback callback)", "descri": "  Unregisters a GPS Measurement callback. ", "parameters": [{"scri": "GnssMeasurementsEvent.Callback: a GnssMeasurementsEvent.Callback object to remove.", "name": "callback"}]}, {"returns": [{"scri": "", "type": "long"}], "class": "android.media.MediaMetadata.Builder\n", "type": "long", "name": "getCachedDuration", "throws": null, "funcname": "long getCachedDuration ()", "descri": "  Returns an estimate of how much data is presently cached in memory expressed in microseconds. Returns -1 if that information is unavailable or not applicable (no cache). ", "parameters": null}, {"returns": [{"scri": "", "type": "long"}], "class": "android.media.MediaMetadata.Builder\n", "type": "long", "name": "getSampleTime", "throws": null, "funcname": "long getSampleTime ()", "descri": "  Returns the current sample's presentation time in microseconds. or -1 if no more samples are available. ", "parameters": null}, {"returns": null, "class": "android.media.MediaPlayer.TrackInfo\n", "type": "void", "name": "setAuxEffectSendLevel", "throws": null, "funcname": "void setAuxEffectSendLevel (float level)", "descri": "  Sets the send level of the player to the attached auxiliary effect. See attachAuxEffect(int). The level value range is 0 to 1.0. By default the send level is 0, so even if an effect is attached to the player this method must be called for the effect to be applied. Note that the passed level value is a raw scalar. UI controls should be scaled logarithmically: the gain applied by audio framework ranges from -72dB to 0dB, so an appropriate conversion from linear UI input x to level is: x == 0 -> level = 0 0 < x <= R -> level = 10^(72*(x-R)/20/R) ", "parameters": [{"scri": "float: send level scalar", "name": "level"}]}, {"returns": null, "class": "android.media.MediaPlayer.TrackInfo\n", "type": "void", "name": "setVolume", "throws": null, "funcname": "void setVolume (float leftVolume,                 float rightVolume)", "descri": "  Sets the volume on this player. This API is recommended for balancing the output of audio streams within an application. Unless you are writing an application to control user settings, this API should be used in preference to setStreamVolume(int, int, int) which sets the volume of ALL streams of a particular type. Note that the passed volume values are raw scalars in range 0.0 to 1.0. UI controls should be scaled logarithmically. ", "parameters": [{"scri": "float: left volume scalar", "name": "leftVolume"}, {"scri": "float: right volume scalar", "name": "rightVolume"}]}, {"returns": null, "class": "android.media.midi.MidiReceiver\n", "type": "void", "name": "openBluetoothDevice", "throws": null, "funcname": "void openBluetoothDevice (BluetoothDevice bluetoothDevice,                 MidiManager.OnDeviceOpenedListener listener,                 Handler handler)", "descri": "  Opens a Bluetooth MIDI device for reading and writing. ", "parameters": [{"scri": "BluetoothDevice: a BluetoothDevice to open as a MIDI device", "name": "bluetoothDevice"}, {"scri": "MidiManager.OnDeviceOpenedListener: a MidiManager.OnDeviceOpenedListener to be called to receive the result", "name": "listener"}, {"scri": "Handler: the Handler that will be used for delivering                the result. If handler is null, then the thread used for the                listener is unspecified.", "name": "handler"}]}, {"returns": [{"scri": "", "type": "long"}], "class": "android.media.Rating\n", "type": "long", "name": "getAnchorMediaTimeUs", "throws": null, "funcname": "long getAnchorMediaTimeUs ()", "descri": "  Get the media time of the anchor in microseconds. ", "parameters": null}, {"returns": [{"scri": "the directionality of microphoneValue is either 0 or combination of DIRECTIONALITY_UNKNOWN, DIRECTIONALITY_OMNI, DIRECTIONALITY_BI_DIRECTIONAL, DIRECTIONALITY_CARDIOID, DIRECTIONALITY_HYPER_CARDIOID or DIRECTIONALITY_SUPER_CARDIOID.", "type": "int"}], "class": "android.media.RemoteControlClient.MetadataEditor\n", "type": "int", "name": "getDirectionality", "throws": null, "funcname": "int getDirectionality ()", "descri": "  Returns the directionality of microphone. The return value is one of DIRECTIONALITY_UNKNOWN, DIRECTIONALITY_OMNI, DIRECTIONALITY_BI_DIRECTIONAL, DIRECTIONALITY_CARDIOID, DIRECTIONALITY_HYPER_CARDIOID, or DIRECTIONALITY_SUPER_CARDIOID. ", "parameters": null}, {"returns": [{"scri": "the group of the microphone or GROUP_UNKNOWN if the group is unknown", "type": "int"}], "class": "android.media.RemoteControlClient.MetadataEditor\n", "type": "int", "name": "getGroup", "throws": null, "funcname": "int getGroup ()", "descri": "  Returns A device group id that can be used to group together microphones on the same peripheral, attachments or logical groups. Main body is usually group 0. ", "parameters": null}, {"returns": [{"scri": "the microphone's id", "type": "int"}], "class": "android.media.RemoteControlClient.MetadataEditor\n", "type": "int", "name": "getId", "throws": null, "funcname": "int getId ()", "descri": "  Returns The system unique device ID that corresponds to the id returned by getId(). ", "parameters": null}, {"returns": [{"scri": "the microphone's index in its group or INDEX_IN_THE_GROUP_UNKNOWN if the index in the group is unknown", "type": "int"}], "class": "android.media.RemoteControlClient.MetadataEditor\n", "type": "int", "name": "getIndexInTheGroup", "throws": null, "funcname": "int getIndexInTheGroup ()", "descri": "  Returns unique index for device within its group. ", "parameters": null}, {"returns": [{"scri": "the location of the microphoneValue is either 0 or combination of LOCATION_UNKNOWN, LOCATION_MAINBODY, LOCATION_MAINBODY_MOVABLE or LOCATION_PERIPHERAL.", "type": "int"}], "class": "android.media.RemoteControlClient.MetadataEditor\n", "type": "int", "name": "getLocation", "throws": null, "funcname": "int getLocation ()", "descri": "  Returns the location of the microphone. The return value is one of LOCATION_UNKNOWN, LOCATION_MAINBODY, LOCATION_MAINBODY_MOVABLE, or LOCATION_PERIPHERAL. ", "parameters": null}, {"returns": [{"scri": "the sensitivity of the microphone or SENSITIVITY_UNKNOWN if the sensitivity is unknown", "type": "float"}], "class": "android.media.RemoteControlClient.MetadataEditor\n", "type": "float", "name": "getSensitivity", "throws": null, "funcname": "float getSensitivity ()", "descri": "  Returns the level in dBFS produced by a 1000Hz tone at 94 dB SPL. ", "parameters": null}, {"returns": [{"scri": "the device type of the microphone", "type": "int"}], "class": "android.media.RemoteControlClient.MetadataEditor\n", "type": "int", "name": "getType", "throws": null, "funcname": "int getType ()", "descri": "  Returns the device type identifier of the microphone (e.g AudioDeviceInfo.TYPE_BUILTIN_MIC). ", "parameters": null}, {"returns": null, "class": "android.media.session.MediaSessionManager\n", "type": "void", "name": "onPlayFromMediaId", "throws": null, "funcname": "void onPlayFromMediaId (String mediaId,                 Bundle extras)", "descri": "  Override to handle requests to play a specific mediaId that was provided by your app's MediaBrowserService. ", "parameters": [{"scri": "String", "name": "mediaId"}, {"scri": "Bundle", "name": "extras"}]}, {"returns": null, "class": "android.media.session.MediaSessionManager\n", "type": "void", "name": "onPrepareFromMediaId", "throws": null, "funcname": "void onPrepareFromMediaId (String mediaId,                 Bundle extras)", "descri": "  Override to handle requests to prepare for playing a specific mediaId that was provided by your app's MediaBrowserService. During the preparation, a session should not hold audio focus in order to allow other sessions play seamlessly. The state of playback should be updated to STATE_PAUSED after the preparation is done. The playback of the prepared content should start in the implementation of onPlay(). Override onPlayFromMediaId(String, Bundle) to handle requests for starting playback without preparation. ", "parameters": [{"scri": "String", "name": "mediaId"}, {"scri": "Bundle", "name": "extras"}]}, {"returns": null, "class": "android.media.tv.TvInputService.RecordingSession\n", "type": "void", "name": "updateTvInputInfo", "throws": [{"scri": "if the argument is null.", "type": "IllegalArgumentException"}], "funcname": "void updateTvInputInfo (TvInputInfo inputInfo)", "descri": "  Updates the TvInputInfo for an existing TV input. A TV input service implementation may call this method to pass the application and system an up-to-date TvInputInfo object that describes itself. The system automatically creates a TvInputInfo object for each TV input, based on the information collected from the AndroidManifest.xml, thus it is not necessary to call this method unless such information has changed dynamically. Use TvInputInfo.Builder to build a new TvInputInfo object. Attempting to change information about a TV input that the calling package does not own does nothing.    See also: onTvInputInfoUpdated(TvInputInfo)", "parameters": [{"scri": "TvInputInfo: The TvInputInfo object that contains new information.This value must never be null.", "name": "inputInfo"}]}, {"returns": null, "class": "android.media.tv.TvInputService.Session\n", "type": "void", "name": "onTvInputInfoUpdated", "throws": null, "funcname": "void onTvInputInfoUpdated (TvInputInfo inputInfo)", "descri": "  This is called when the information about an existing TV input has been updated. Because the system automatically creates a TvInputInfo object for each TV input based on the information collected from the AndroidManifest.xml, this method is only called back when such information has changed dynamically. ", "parameters": [{"scri": "TvInputInfo: The TvInputInfo object that contains new information.", "name": "inputInfo"}]}, {"returns": [{"scri": "the timestamp associated with this metadata access unit in microseconds; 0 denotes playback start.", "type": "long"}], "class": "android.media.VolumeShaper\n", "type": "long", "name": "getTimestamp", "throws": null, "funcname": "long getTimestamp ()", "descri": "   ", "parameters": null}, {"returns": [{"scri": "an integer representing the preferred network type", "type": "int"}], "class": "android.net.IpSecManager.SecurityParameterIndex\n", "type": "int", "name": "getNetworkPreference", "throws": null, "funcname": "int getNetworkPreference ()", "descri": "   This method was deprecated      in API level 21.    Functionality has been removed as it no longer makes sense,             with many more than two networks - we'd need an array to express             preference.  Instead we use dynamic network properties of             the networks to describe their precedence.  Retrieves the current preferred network type. Requires the ACCESS_NETWORK_STATE permission. ", "parameters": null}, {"returns": null, "class": "android.net.IpSecManager.SecurityParameterIndex\n", "type": "void", "name": "setNetworkPreference", "throws": null, "funcname": "void setNetworkPreference (int preference)", "descri": "   This method was deprecated      in API level 21.    Functionality has been removed as it no longer makes sense,             with many more than two networks - we'd need an array to express             preference.  Instead we use dynamic network properties of             the networks to describe their precedence.  Specifies the preferred network type.  When the device has more than one type available the preferred network type will be used. ", "parameters": [{"scri": "int: the network type to prefer over all others.  It is         unspecified what happens to the old preferred network in the         overall ordering.", "name": "preference"}]}, {"returns": [{"scri": "one of TYPE_MOBILE, TYPE_WIFI, TYPE_WIMAX, TYPE_ETHERNET,  TYPE_BLUETOOTH, or other types defined by ConnectivityManager.", "type": "int"}], "class": "android.net.NetworkRequest.Builder\n", "type": "int", "name": "getType", "throws": null, "funcname": "int getType ()", "descri": "   This method was deprecated      in API level P.    Callers should switch to checking hasTransport(int)             instead with one of the NetworkCapabilities#TRANSPORT_* constants :             getType() and getTypeName() cannot account for networks using             multiple transports. Note that generally apps should not care about transport;             NET_CAPABILITY_NOT_METERED and             getLinkDownstreamBandwidthKbps() are calls that             apps concerned with meteredness or bandwidth should be looking at, as they             offer this information with much better accuracy.  Reports the type of network to which the info in this NetworkInfo pertains. ", "parameters": null}, {"returns": [{"scri": "true if roaming is in effect, false otherwise.", "type": "boolean"}], "class": "android.net.NetworkRequest.Builder\n", "type": "boolean", "name": "isRoaming", "throws": null, "funcname": "boolean isRoaming ()", "descri": "   This method was deprecated      in API level P.    Callers should switch to checking             NET_CAPABILITY_NOT_ROAMING             instead, since that handles more complex situations, such as             VPNs.  Indicates whether the device is currently roaming on this network. When true, it suggests that use of data on this network may incur extra costs. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.net.Proxy\n", "type": "boolean", "name": "hasCapability", "throws": null, "funcname": "boolean hasCapability (int capability)", "descri": "      See also: addCapability(int)", "parameters": [{"scri": "int Value is NET_CAPABILITY_MMS, NET_CAPABILITY_SUPL, NET_CAPABILITY_DUN, NET_CAPABILITY_FOTA, NET_CAPABILITY_IMS, NET_CAPABILITY_CBS, NET_CAPABILITY_WIFI_P2P, NET_CAPABILITY_IA, NET_CAPABILITY_RCS, NET_CAPABILITY_XCAP, NET_CAPABILITY_EIMS, NET_CAPABILITY_NOT_METERED, NET_CAPABILITY_INTERNET, NET_CAPABILITY_NOT_RESTRICTED, NET_CAPABILITY_TRUSTED, NET_CAPABILITY_NOT_VPN, NET_CAPABILITY_VALIDATED, NET_CAPABILITY_CAPTIVE_PORTAL, NET_CAPABILITY_NOT_ROAMING, NET_CAPABILITY_FOREGROUND, NET_CAPABILITY_NOT_CONGESTED or NET_CAPABILITY_NOT_SUSPENDED.", "name": "capability"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.net.Proxy\n", "type": "boolean", "name": "hasTransport", "throws": null, "funcname": "boolean hasTransport (int transportType)", "descri": "      See also: addTransportType(int)", "parameters": [{"scri": "int Value is TRANSPORT_CELLULAR, TRANSPORT_WIFI, TRANSPORT_BLUETOOTH, TRANSPORT_ETHERNET, TRANSPORT_VPN, TRANSPORT_WIFI_AWARE or TRANSPORT_LOWPAN.", "name": "transportType"}]}, {"returns": null, "class": "android.net.rtp.RtpStream\n", "type": "void", "name": "onRevoke", "throws": null, "funcname": "void onRevoke ()", "descri": "  Invoked when the application is revoked. At this moment, the VPN interface is already deactivated by the system. The application should close the file descriptor and shut down gracefully. The default implementation of this method is calling stopSelf(). Calls to this method may not happen on the main thread of the process.  See also: prepare(Context)", "parameters": null}, {"returns": [{"scri": "true on success.", "type": "boolean"}], "class": "android.net.rtp.RtpStream\n", "type": "boolean", "name": "protect", "throws": null, "funcname": "boolean protect (Socket socket)", "descri": "  Convenience method to protect a Socket from VPN connections.    See also: protect(int)", "parameters": [{"scri": "Socket", "name": "socket"}]}, {"returns": [{"scri": "true on success.", "type": "boolean"}], "class": "android.net.rtp.RtpStream\n", "type": "boolean", "name": "protect", "throws": null, "funcname": "boolean protect (int socket)", "descri": "  Protect a socket from VPN connections. After protecting, data sent through this socket will go directly to the underlying network, so its traffic will not be forwarded through the VPN. This method is useful if some connections need to be kept outside of VPN. For example, a VPN tunnel should protect itself if its destination is covered by VPN routes. Otherwise its outgoing packets will be sent back to the VPN interface and cause an infinite loop. This method will fail if the application is not prepared or is revoked. The socket is NOT closed by this method.  ", "parameters": [{"scri": "int", "name": "socket"}]}, {"returns": [{"scri": "true on success.", "type": "boolean"}], "class": "android.net.rtp.RtpStream\n", "type": "boolean", "name": "protect", "throws": null, "funcname": "boolean protect (DatagramSocket socket)", "descri": "  Convenience method to protect a DatagramSocket from VPN connections.    See also: protect(int)", "parameters": [{"scri": "DatagramSocket", "name": "socket"}]}, {"returns": [{"scri": "true on success.", "type": "boolean"}], "class": "android.net.rtp.RtpStream\n", "type": "boolean", "name": "setUnderlyingNetworks", "throws": null, "funcname": "boolean setUnderlyingNetworks (Network[] networks)", "descri": "  Sets the underlying networks used by the VPN for its upstream connections. Used by the system to know the actual networks that carry traffic for apps affected by this VPN in order to present this information to the user (e.g., via status bar icons). This method only needs to be called if the VPN has explicitly bound its underlying communications channels \u2014 such as the socket(s) passed to protect(int) \u2014 to a Network using APIs such as bindSocket(Socket) or bindSocket(DatagramSocket). The VPN should call this method every time the set of Networks it is using changes. networks is one of the following: a non-empty array: an array of one or more Networks, in decreasing preference order. For example, if this VPN uses both wifi and mobile (cellular) networks to carry app traffic, but prefers or uses wifi more than mobile, wifi should appear first in the array. an empty array: a zero-element array, meaning that the VPN has no underlying network connection, and thus, app traffic will not be sent or received. null: (default) signifies that the VPN uses whatever is the system's default network. I.e., it doesn't use the bindSocket or bindDatagramSocket APIs mentioned above to send traffic over specific channels.  This call will succeed only if the VPN is currently established. For setting this value when the VPN has not yet been established, see setUnderlyingNetworks(Network[]).  ", "parameters": [{"scri": "Network: An array of networks the VPN uses to tunnel traffic to/from its servers.", "name": "networks"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.net.sip.SipSession.Listener\n", "type": "static\n        \n        \n        boolean", "name": "isSipWifiOnly", "throws": null, "funcname": "boolean isSipWifiOnly (Context context)", "descri": "  Returns true if SIP is only available on WIFI.  ", "parameters": [{"scri": "Context", "name": "context"}]}, {"returns": null, "class": "android.net.Uri.Builder\n", "name": "SSLSessionCache", "throws": null, "funcname": "SSLSessionCache (Context context)", "parameters": [{"scri": "Context: for the application", "name": "context"}], "descri": "  Create a session cache at the default location for this app. Multiple instances share data internally. "}, {"returns": null, "class": "android.net.Uri.Builder\n", "name": "SSLSessionCache", "throws": null, "funcname": "SSLSessionCache (Context context)", "parameters": [{"scri": "Context: for the application", "name": "context"}], "descri": "  Create a session cache at the default location for this app. Multiple instances share data internally. "}, {"returns": [{"scri": "the object's sequence number", "type": "int"}], "class": "android.net.UrlQuerySanitizer.ValueSanitizer\n", "type": "int", "name": "getSequenceNumber", "throws": null, "funcname": "int getSequenceNumber ()", "descri": "  Returns the sequence number for the MTP object This field is typically not used for MTP devices, but is sometimes used to define a sequence of photos on PTP cameras. ", "parameters": null}, {"returns": [{"scri": "the object's sequence number", "type": "long"}], "class": "android.net.UrlQuerySanitizer.ValueSanitizer\n", "type": "long", "name": "getSequenceNumberLong", "throws": null, "funcname": "long getSequenceNumberLong ()", "descri": "  Returns the sequence number for the MTP object This field is typically not used for MTP devices, but is sometimes used to define a sequence of photos on PTP cameras. ", "parameters": null}, {"returns": null, "class": "android.net.wifi.aware.IdentityChangedListener\n", "type": "void", "name": "onAttached", "throws": null, "funcname": "void onAttached (WifiAwareSession session)", "descri": "  Called when Aware attach operation attach(AttachCallback, android.os.Handler) is completed and that we can now start discovery sessions or connections. ", "parameters": [{"scri": "WifiAwareSession: The Aware object on which we can execute further Aware operations - e.g.                discovery, connections.", "name": "session"}]}, {"returns": null, "class": "android.net.wifi.aware.PublishDiscoverySession\n", "type": "void", "name": "onIdentityChanged", "throws": null, "funcname": "void onIdentityChanged (byte[] mac)", "descri": "   ", "parameters": [{"scri": "byte: The MAC address of the Aware discovery interface. The application must have the ACCESS_COARSE_LOCATION to get the actual MAC address,            otherwise all 0's will be provided.", "name": "mac"}]}, {"returns": null, "class": "android.net.wifi.hotspot2.pps.Credential\n", "type": "void", "name": "publish", "throws": null, "funcname": "void publish (PublishConfig publishConfig,                 DiscoverySessionCallback callback,                 Handler handler)", "descri": "  Issue a request to the Aware service to create a new Aware publish discovery session, using the specified publishConfig configuration. The results of the publish operation are routed to the callbacks of DiscoverySessionCallback: onPublishStarted(PublishDiscoverySession)     is called when the publish session is created and provides a handle to the session.     Further operations on the publish session can be executed on that object.     onSessionConfigFailed() is called if the     publish operation failed.  Other results of the publish session operations will also be routed to callbacks on the callback object. The resulting publish session can be modified using updatePublish(PublishConfig). An application must use the close() to      terminate the publish discovery session once it isn't needed. This will free      resources as well terminate any on-air transmissions. The application must have the ACCESS_COARSE_LOCATION permission to start a publish discovery session. ", "parameters": [{"scri": "PublishConfig: The PublishConfig specifying the            configuration of the requested publish session.This value must never be null.", "name": "publishConfig"}, {"scri": "DiscoverySessionCallback: A DiscoverySessionCallback derived object to be used for                 session event callbacks.This value must never be null.", "name": "callback"}, {"scri": "Handler: The Handler on whose thread to execute the callbacks of the callback object. If a null is provided then the application's main thread will be used.", "name": "handler"}]}, {"returns": null, "class": "android.net.wifi.hotspot2.pps.Credential\n", "type": "void", "name": "subscribe", "throws": null, "funcname": "void subscribe (SubscribeConfig subscribeConfig,                 DiscoverySessionCallback callback,                 Handler handler)", "descri": "  Issue a request to the Aware service to create a new Aware subscribe discovery session, using the specified subscribeConfig configuration. The results of the subscribe operation are routed to the callbacks of DiscoverySessionCallback: onSubscribeStarted(SubscribeDiscoverySession)     is called when the subscribe session is created and provides a handle to the session.     Further operations on the subscribe session can be executed on that object.     onSessionConfigFailed() is called if the     subscribe operation failed.  Other results of the subscribe session operations will also be routed to callbacks on the callback object. The resulting subscribe session can be modified using updateSubscribe(SubscribeConfig). An application must use the close() to      terminate the subscribe discovery session once it isn't needed. This will free      resources as well terminate any on-air transmissions. The application must have the ACCESS_COARSE_LOCATION permission to start a subscribe discovery session. ", "parameters": [{"scri": "SubscribeConfig: The SubscribeConfig specifying the            configuration of the requested subscribe session.This value must never be null.", "name": "subscribeConfig"}, {"scri": "DiscoverySessionCallback: A DiscoverySessionCallback derived object to be used for                 session event callbacks.This value must never be null.", "name": "callback"}, {"scri": "Handler: The Handler on whose thread to execute the callbacks of the callback object. If a null is provided then the application's main thread will be used.", "name": "handler"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceInfo\n", "name": "WifiP2pGroup", "throws": null, "funcname": "WifiP2pGroup (WifiP2pGroup source)", "parameters": [{"scri": "WifiP2pGroup", "name": "source"}], "descri": "  copy constructor "}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceInfo\n", "name": "WifiP2pGroup", "throws": null, "funcname": "WifiP2pGroup (WifiP2pGroup source)", "parameters": [{"scri": "WifiP2pGroup", "name": "source"}], "descri": "  copy constructor "}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceRequest\n", "name": "WifiP2pInfo", "throws": null, "funcname": "WifiP2pInfo (WifiP2pInfo source)", "parameters": [{"scri": "WifiP2pInfo", "name": "source"}], "descri": "  copy constructor "}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceRequest\n", "name": "WifiP2pInfo", "throws": null, "funcname": "WifiP2pInfo (WifiP2pInfo source)", "parameters": [{"scri": "WifiP2pInfo", "name": "source"}], "descri": "  copy constructor "}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "addLocalService", "throws": null, "funcname": "void addLocalService (WifiP2pManager.Channel c,                 WifiP2pServiceInfo servInfo,                 WifiP2pManager.ActionListener listener)", "descri": "  Register a local service for service discovery. If a local service is registered, the framework automatically responds to a service discovery request from a peer. The function call immediately returns after sending a request to add a local service to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). The service information is set through WifiP2pServiceInfo. or its subclass calls  newInstance(String, String, List) or  newInstance(String, String, Map) for a Upnp or Bonjour service respectively The service information can be cleared with calls to  removeLocalService(WifiP2pManager.Channel, WifiP2pServiceInfo, WifiP2pManager.ActionListener) or clearLocalServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceInfo: is a local service information.", "name": "servInfo"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "addLocalService", "throws": null, "funcname": "void addLocalService (WifiP2pManager.Channel c,                 WifiP2pServiceInfo servInfo,                 WifiP2pManager.ActionListener listener)", "descri": "  Register a local service for service discovery. If a local service is registered, the framework automatically responds to a service discovery request from a peer. The function call immediately returns after sending a request to add a local service to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). The service information is set through WifiP2pServiceInfo. or its subclass calls  newInstance(String, String, List) or  newInstance(String, String, Map) for a Upnp or Bonjour service respectively The service information can be cleared with calls to  removeLocalService(WifiP2pManager.Channel, WifiP2pServiceInfo, WifiP2pManager.ActionListener) or clearLocalServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceInfo: is a local service information.", "name": "servInfo"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "addLocalService", "throws": null, "funcname": "void addLocalService (WifiP2pManager.Channel c,                 WifiP2pServiceInfo servInfo,                 WifiP2pManager.ActionListener listener)", "descri": "  Register a local service for service discovery. If a local service is registered, the framework automatically responds to a service discovery request from a peer. The function call immediately returns after sending a request to add a local service to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). The service information is set through WifiP2pServiceInfo. or its subclass calls  newInstance(String, String, List) or  newInstance(String, String, Map) for a Upnp or Bonjour service respectively The service information can be cleared with calls to  removeLocalService(WifiP2pManager.Channel, WifiP2pServiceInfo, WifiP2pManager.ActionListener) or clearLocalServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceInfo: is a local service information.", "name": "servInfo"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "addServiceRequest", "throws": null, "funcname": "void addServiceRequest (WifiP2pManager.Channel c,                 WifiP2pServiceRequest req,                 WifiP2pManager.ActionListener listener)", "descri": "  Add a service discovery request. The function call immediately returns after sending a request to add service discovery request to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). After service discovery request is added, you can initiate service discovery by discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener). The added service requests can be cleared with calls to removeServiceRequest(Channel, WifiP2pServiceRequest, ActionListener) or clearServiceRequests(Channel, ActionListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceRequest: is the service discovery request.", "name": "req"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "addServiceRequest", "throws": null, "funcname": "void addServiceRequest (WifiP2pManager.Channel c,                 WifiP2pServiceRequest req,                 WifiP2pManager.ActionListener listener)", "descri": "  Add a service discovery request. The function call immediately returns after sending a request to add service discovery request to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). After service discovery request is added, you can initiate service discovery by discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener). The added service requests can be cleared with calls to removeServiceRequest(Channel, WifiP2pServiceRequest, ActionListener) or clearServiceRequests(Channel, ActionListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceRequest: is the service discovery request.", "name": "req"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "addServiceRequest", "throws": null, "funcname": "void addServiceRequest (WifiP2pManager.Channel c,                 WifiP2pServiceRequest req,                 WifiP2pManager.ActionListener listener)", "descri": "  Add a service discovery request. The function call immediately returns after sending a request to add service discovery request to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). After service discovery request is added, you can initiate service discovery by discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener). The added service requests can be cleared with calls to removeServiceRequest(Channel, WifiP2pServiceRequest, ActionListener) or clearServiceRequests(Channel, ActionListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceRequest: is the service discovery request.", "name": "req"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "cancelConnect", "throws": null, "funcname": "void cancelConnect (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Cancel any ongoing p2p group negotiation The function call immediately returns after sending a connection cancellation request to the framework. The application is notified of a success or failure to initiate cancellation through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "cancelConnect", "throws": null, "funcname": "void cancelConnect (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Cancel any ongoing p2p group negotiation The function call immediately returns after sending a connection cancellation request to the framework. The application is notified of a success or failure to initiate cancellation through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "clearLocalServices", "throws": null, "funcname": "void clearLocalServices (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Clear all registered local services of service discovery. The function call immediately returns after sending a request to clear all local services to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "clearLocalServices", "throws": null, "funcname": "void clearLocalServices (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Clear all registered local services of service discovery. The function call immediately returns after sending a request to clear all local services to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "clearServiceRequests", "throws": null, "funcname": "void clearServiceRequests (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Clear all registered service discovery requests. The function call immediately returns after sending a request to clear all service discovery requests to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "clearServiceRequests", "throws": null, "funcname": "void clearServiceRequests (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Clear all registered service discovery requests. The function call immediately returns after sending a request to clear all service discovery requests to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "connect", "throws": null, "funcname": "void connect (WifiP2pManager.Channel c,                 WifiP2pConfig config,                 WifiP2pManager.ActionListener listener)", "descri": "  Start a p2p connection to a device with the specified configuration. The function call immediately returns after sending a connection request to the framework. The application is notified of a success or failure to initiate connect through listener callbacks onSuccess() or onFailure(int). Register for WIFI_P2P_CONNECTION_CHANGED_ACTION intent to determine when the framework notifies of a change in connectivity. If the current device is not part of a p2p group, a connect request initiates a group negotiation with the peer. If the current device is part of an existing p2p group or has created a p2p group with createGroup(WifiP2pManager.Channel, WifiP2pManager.ActionListener), an invitation to join the group is sent to the peer device. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pConfig: options as described in WifiP2pConfig class", "name": "config"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "connect", "throws": null, "funcname": "void connect (WifiP2pManager.Channel c,                 WifiP2pConfig config,                 WifiP2pManager.ActionListener listener)", "descri": "  Start a p2p connection to a device with the specified configuration. The function call immediately returns after sending a connection request to the framework. The application is notified of a success or failure to initiate connect through listener callbacks onSuccess() or onFailure(int). Register for WIFI_P2P_CONNECTION_CHANGED_ACTION intent to determine when the framework notifies of a change in connectivity. If the current device is not part of a p2p group, a connect request initiates a group negotiation with the peer. If the current device is part of an existing p2p group or has created a p2p group with createGroup(WifiP2pManager.Channel, WifiP2pManager.ActionListener), an invitation to join the group is sent to the peer device. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pConfig: options as described in WifiP2pConfig class", "name": "config"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "connect", "throws": null, "funcname": "void connect (WifiP2pManager.Channel c,                 WifiP2pConfig config,                 WifiP2pManager.ActionListener listener)", "descri": "  Start a p2p connection to a device with the specified configuration. The function call immediately returns after sending a connection request to the framework. The application is notified of a success or failure to initiate connect through listener callbacks onSuccess() or onFailure(int). Register for WIFI_P2P_CONNECTION_CHANGED_ACTION intent to determine when the framework notifies of a change in connectivity. If the current device is not part of a p2p group, a connect request initiates a group negotiation with the peer. If the current device is part of an existing p2p group or has created a p2p group with createGroup(WifiP2pManager.Channel, WifiP2pManager.ActionListener), an invitation to join the group is sent to the peer device. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pConfig: options as described in WifiP2pConfig class", "name": "config"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "createGroup", "throws": null, "funcname": "void createGroup (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Create a p2p group with the current device as the group owner. This essentially creates an access point that can accept connections from legacy clients as well as other p2p devices. Note: This function would normally not be used unless the current device needs to form a p2p connection with a legacy client The function call immediately returns after sending a group creation request to the framework. The application is notified of a success or failure to initiate group creation through listener callbacks onSuccess() or onFailure(int). Application can request for the group details with requestGroupInfo(WifiP2pManager.Channel, WifiP2pManager.GroupInfoListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "createGroup", "throws": null, "funcname": "void createGroup (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Create a p2p group with the current device as the group owner. This essentially creates an access point that can accept connections from legacy clients as well as other p2p devices. Note: This function would normally not be used unless the current device needs to form a p2p connection with a legacy client The function call immediately returns after sending a group creation request to the framework. The application is notified of a success or failure to initiate group creation through listener callbacks onSuccess() or onFailure(int). Application can request for the group details with requestGroupInfo(WifiP2pManager.Channel, WifiP2pManager.GroupInfoListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "discoverPeers", "throws": null, "funcname": "void discoverPeers (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Initiate peer discovery. A discovery process involves scanning for available Wi-Fi peers for the purpose of establishing a connection. The function call immediately returns after sending a discovery request to the framework. The application is notified of a success or failure to initiate discovery through listener callbacks onSuccess() or onFailure(int). The discovery remains active until a connection is initiated or a p2p group is formed. Register for WIFI_P2P_PEERS_CHANGED_ACTION intent to determine when the framework notifies of a change as peers are discovered. Upon receiving a WIFI_P2P_PEERS_CHANGED_ACTION intent, an application can request for the list of peers using requestPeers(WifiP2pManager.Channel, WifiP2pManager.PeerListListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "discoverPeers", "throws": null, "funcname": "void discoverPeers (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Initiate peer discovery. A discovery process involves scanning for available Wi-Fi peers for the purpose of establishing a connection. The function call immediately returns after sending a discovery request to the framework. The application is notified of a success or failure to initiate discovery through listener callbacks onSuccess() or onFailure(int). The discovery remains active until a connection is initiated or a p2p group is formed. Register for WIFI_P2P_PEERS_CHANGED_ACTION intent to determine when the framework notifies of a change as peers are discovered. Upon receiving a WIFI_P2P_PEERS_CHANGED_ACTION intent, an application can request for the list of peers using requestPeers(WifiP2pManager.Channel, WifiP2pManager.PeerListListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "discoverServices", "throws": null, "funcname": "void discoverServices (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Initiate service discovery. A discovery process involves scanning for requested services for the purpose of establishing a connection to a peer that supports an available service. The function call immediately returns after sending a request to start service discovery to the framework. The application is notified of a success or failure to initiate discovery through listener callbacks onSuccess() or onFailure(int). The services to be discovered are specified with calls to addServiceRequest(WifiP2pManager.Channel, WifiP2pServiceRequest, WifiP2pManager.ActionListener). The application is notified of the response against the service discovery request through listener callbacks registered by setServiceResponseListener(WifiP2pManager.Channel, WifiP2pManager.ServiceResponseListener) or setDnsSdResponseListeners(WifiP2pManager.Channel, WifiP2pManager.DnsSdServiceResponseListener, WifiP2pManager.DnsSdTxtRecordListener), or setUpnpServiceResponseListener(WifiP2pManager.Channel, WifiP2pManager.UpnpServiceResponseListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "discoverServices", "throws": null, "funcname": "void discoverServices (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Initiate service discovery. A discovery process involves scanning for requested services for the purpose of establishing a connection to a peer that supports an available service. The function call immediately returns after sending a request to start service discovery to the framework. The application is notified of a success or failure to initiate discovery through listener callbacks onSuccess() or onFailure(int). The services to be discovered are specified with calls to addServiceRequest(WifiP2pManager.Channel, WifiP2pServiceRequest, WifiP2pManager.ActionListener). The application is notified of the response against the service discovery request through listener callbacks registered by setServiceResponseListener(WifiP2pManager.Channel, WifiP2pManager.ServiceResponseListener) or setDnsSdResponseListeners(WifiP2pManager.Channel, WifiP2pManager.DnsSdServiceResponseListener, WifiP2pManager.DnsSdTxtRecordListener), or setUpnpServiceResponseListener(WifiP2pManager.Channel, WifiP2pManager.UpnpServiceResponseListener). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "removeGroup", "throws": null, "funcname": "void removeGroup (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Remove the current p2p group. The function call immediately returns after sending a group removal request to the framework. The application is notified of a success or failure to initiate group removal through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "removeGroup", "throws": null, "funcname": "void removeGroup (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Remove the current p2p group. The function call immediately returns after sending a group removal request to the framework. The application is notified of a success or failure to initiate group removal through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "removeLocalService", "throws": null, "funcname": "void removeLocalService (WifiP2pManager.Channel c,                 WifiP2pServiceInfo servInfo,                 WifiP2pManager.ActionListener listener)", "descri": "  Remove a registered local service added with addLocalService(WifiP2pManager.Channel, WifiP2pServiceInfo, WifiP2pManager.ActionListener) The function call immediately returns after sending a request to remove a local service to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceInfo: is the local service information.", "name": "servInfo"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "removeLocalService", "throws": null, "funcname": "void removeLocalService (WifiP2pManager.Channel c,                 WifiP2pServiceInfo servInfo,                 WifiP2pManager.ActionListener listener)", "descri": "  Remove a registered local service added with addLocalService(WifiP2pManager.Channel, WifiP2pServiceInfo, WifiP2pManager.ActionListener) The function call immediately returns after sending a request to remove a local service to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceInfo: is the local service information.", "name": "servInfo"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "removeLocalService", "throws": null, "funcname": "void removeLocalService (WifiP2pManager.Channel c,                 WifiP2pServiceInfo servInfo,                 WifiP2pManager.ActionListener listener)", "descri": "  Remove a registered local service added with addLocalService(WifiP2pManager.Channel, WifiP2pServiceInfo, WifiP2pManager.ActionListener) The function call immediately returns after sending a request to remove a local service to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceInfo: is the local service information.", "name": "servInfo"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "removeServiceRequest", "throws": null, "funcname": "void removeServiceRequest (WifiP2pManager.Channel c,                 WifiP2pServiceRequest req,                 WifiP2pManager.ActionListener listener)", "descri": "  Remove a specified service discovery request added with addServiceRequest(WifiP2pManager.Channel, WifiP2pServiceRequest, WifiP2pManager.ActionListener) The function call immediately returns after sending a request to remove service discovery request to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceRequest: is the service discovery request.", "name": "req"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "removeServiceRequest", "throws": null, "funcname": "void removeServiceRequest (WifiP2pManager.Channel c,                 WifiP2pServiceRequest req,                 WifiP2pManager.ActionListener listener)", "descri": "  Remove a specified service discovery request added with addServiceRequest(WifiP2pManager.Channel, WifiP2pServiceRequest, WifiP2pManager.ActionListener) The function call immediately returns after sending a request to remove service discovery request to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceRequest: is the service discovery request.", "name": "req"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "removeServiceRequest", "throws": null, "funcname": "void removeServiceRequest (WifiP2pManager.Channel c,                 WifiP2pServiceRequest req,                 WifiP2pManager.ActionListener listener)", "descri": "  Remove a specified service discovery request added with addServiceRequest(WifiP2pManager.Channel, WifiP2pServiceRequest, WifiP2pManager.ActionListener) The function call immediately returns after sending a request to remove service discovery request to the framework. The application is notified of a success or failure to add service through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pServiceRequest: is the service discovery request.", "name": "req"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "requestConnectionInfo", "throws": null, "funcname": "void requestConnectionInfo (WifiP2pManager.Channel c,                 WifiP2pManager.ConnectionInfoListener listener)", "descri": "  Request device connection info. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ConnectionInfoListener: for callback when connection info is available. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "requestConnectionInfo", "throws": null, "funcname": "void requestConnectionInfo (WifiP2pManager.Channel c,                 WifiP2pManager.ConnectionInfoListener listener)", "descri": "  Request device connection info. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ConnectionInfoListener: for callback when connection info is available. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "requestGroupInfo", "throws": null, "funcname": "void requestGroupInfo (WifiP2pManager.Channel c,                 WifiP2pManager.GroupInfoListener listener)", "descri": "  Request p2p group info. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.GroupInfoListener: for callback when group info is available. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "requestGroupInfo", "throws": null, "funcname": "void requestGroupInfo (WifiP2pManager.Channel c,                 WifiP2pManager.GroupInfoListener listener)", "descri": "  Request p2p group info. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.GroupInfoListener: for callback when group info is available. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "requestPeers", "throws": null, "funcname": "void requestPeers (WifiP2pManager.Channel c,                 WifiP2pManager.PeerListListener listener)", "descri": "  Request the current list of peers. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.PeerListListener: for callback when peer list is available. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "requestPeers", "throws": null, "funcname": "void requestPeers (WifiP2pManager.Channel c,                 WifiP2pManager.PeerListListener listener)", "descri": "  Request the current list of peers. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.PeerListListener: for callback when peer list is available. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "setDnsSdResponseListeners", "throws": null, "funcname": "void setDnsSdResponseListeners (WifiP2pManager.Channel c,                 WifiP2pManager.DnsSdServiceResponseListener servListener,                 WifiP2pManager.DnsSdTxtRecordListener txtListener)", "descri": "  Register a callback to be invoked on receiving Bonjour service discovery response. see discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener) for the detail. ", "parameters": [{"scri": "WifiP2pManager.DnsSdServiceResponseListener: is for listening to a Bonjour service response", "name": "servListener"}, {"scri": "WifiP2pManager.DnsSdTxtRecordListener: is for listening to a Bonjour TXT record response", "name": "txtListener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "setDnsSdResponseListeners", "throws": null, "funcname": "void setDnsSdResponseListeners (WifiP2pManager.Channel c,                 WifiP2pManager.DnsSdServiceResponseListener servListener,                 WifiP2pManager.DnsSdTxtRecordListener txtListener)", "descri": "  Register a callback to be invoked on receiving Bonjour service discovery response. see discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener) for the detail. ", "parameters": [{"scri": "WifiP2pManager.DnsSdServiceResponseListener: is for listening to a Bonjour service response", "name": "servListener"}, {"scri": "WifiP2pManager.DnsSdTxtRecordListener: is for listening to a Bonjour TXT record response", "name": "txtListener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "setServiceResponseListener", "throws": null, "funcname": "void setServiceResponseListener (WifiP2pManager.Channel c,                 WifiP2pManager.ServiceResponseListener listener)", "descri": "  Register a callback to be invoked on receiving service discovery response. Used only for vendor specific protocol right now. For Bonjour or Upnp, use setDnsSdResponseListeners(WifiP2pManager.Channel, WifiP2pManager.DnsSdServiceResponseListener, WifiP2pManager.DnsSdTxtRecordListener) or setUpnpServiceResponseListener(WifiP2pManager.Channel, WifiP2pManager.UpnpServiceResponseListener) respectively. see discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener) for the detail. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ServiceResponseListener: for callbacks on receiving service discovery response.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "setServiceResponseListener", "throws": null, "funcname": "void setServiceResponseListener (WifiP2pManager.Channel c,                 WifiP2pManager.ServiceResponseListener listener)", "descri": "  Register a callback to be invoked on receiving service discovery response. Used only for vendor specific protocol right now. For Bonjour or Upnp, use setDnsSdResponseListeners(WifiP2pManager.Channel, WifiP2pManager.DnsSdServiceResponseListener, WifiP2pManager.DnsSdTxtRecordListener) or setUpnpServiceResponseListener(WifiP2pManager.Channel, WifiP2pManager.UpnpServiceResponseListener) respectively. see discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener) for the detail. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ServiceResponseListener: for callbacks on receiving service discovery response.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "setUpnpServiceResponseListener", "throws": null, "funcname": "void setUpnpServiceResponseListener (WifiP2pManager.Channel c,                 WifiP2pManager.UpnpServiceResponseListener listener)", "descri": "  Register a callback to be invoked on receiving upnp service discovery response. see discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener) for the detail. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.UpnpServiceResponseListener: for callbacks on receiving service discovery response.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "setUpnpServiceResponseListener", "throws": null, "funcname": "void setUpnpServiceResponseListener (WifiP2pManager.Channel c,                 WifiP2pManager.UpnpServiceResponseListener listener)", "descri": "  Register a callback to be invoked on receiving upnp service discovery response. see discoverServices(WifiP2pManager.Channel, WifiP2pManager.ActionListener) for the detail. ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.UpnpServiceResponseListener: for callbacks on receiving service discovery response.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "stopPeerDiscovery", "throws": null, "funcname": "void stopPeerDiscovery (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Stop an ongoing peer discovery The function call immediately returns after sending a stop request to the framework. The application is notified of a success or failure to initiate stop through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.nsd.WifiP2pServiceInfo\n", "type": "void", "name": "stopPeerDiscovery", "throws": null, "funcname": "void stopPeerDiscovery (WifiP2pManager.Channel c,                 WifiP2pManager.ActionListener listener)", "descri": "  Stop an ongoing peer discovery The function call immediately returns after sending a stop request to the framework. The application is notified of a success or failure to initiate stop through listener callbacks onSuccess() or onFailure(int). ", "parameters": [{"scri": "WifiP2pManager.Channel: is the channel created at initialize(Context, Looper, WifiP2pManager.ChannelListener)", "name": "c"}, {"scri": "WifiP2pManager.ActionListener: for callbacks on success or failure. Can be null.", "name": "listener"}]}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pConfig\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onPeersAvailable", "throws": null, "funcname": "void onPeersAvailable (WifiP2pDeviceList peers)", "descri": "  The requested peer list is available ", "parameters": [{"scri": "WifiP2pDeviceList: List of available peers", "name": "peers"}]}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pDeviceList\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onServiceAvailable", "throws": null, "funcname": "void onServiceAvailable (int protocolType,                 byte[] responseData,                 WifiP2pDevice srcDevice)", "descri": "  The requested service response is available. ", "parameters": [{"scri": "int: protocol type. currently only SERVICE_TYPE_VENDOR_SPECIFIC.", "name": "protocolType"}, {"scri": "byte: service discovery response data based on the requested  service protocol type. The format depends on the service type.", "name": "responseData"}, {"scri": "WifiP2pDevice: source device.", "name": "srcDevice"}]}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pGroup\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onUpnpServiceAvailable", "throws": null, "funcname": "void onUpnpServiceAvailable (List<String> uniqueServiceNames,                 WifiP2pDevice srcDevice)", "descri": "  The requested upnp service response is available. This function is invoked when the specified device or service is found. ", "parameters": [{"scri": "List: The list of unique service names. e.g) uuid:6859dede-8574-59ab-9332-123456789012::urn:schemas-upnp-org:device: MediaServer:1", "name": "uniqueServiceNames"}, {"scri": "WifiP2pDevice: source device.", "name": "srcDevice"}]}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pManager\n", "name": "WifiP2pConfig", "throws": null, "funcname": "WifiP2pConfig (WifiP2pConfig source)", "parameters": [{"scri": "WifiP2pConfig", "name": "source"}], "descri": "  copy constructor "}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pManager\n", "name": "WifiP2pConfig", "throws": null, "funcname": "WifiP2pConfig (WifiP2pConfig source)", "parameters": [{"scri": "WifiP2pConfig", "name": "source"}], "descri": "  copy constructor "}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pManager.ActionListener\n", "type": "void", "name": "setImsi", "throws": null, "funcname": "void setImsi (String imsi)", "descri": "  Set the IMSI (International Mobile Subscriber Identity) associated with this SIM credential. ", "parameters": [{"scri": "String: The IMSI to set to", "name": "imsi"}]}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pManager.Channel\n", "name": "WifiP2pDeviceList", "throws": null, "funcname": "WifiP2pDeviceList (WifiP2pDeviceList source)", "parameters": [{"scri": "WifiP2pDeviceList", "name": "source"}], "descri": "  copy constructor "}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pManager.Channel\n", "name": "WifiP2pDeviceList", "throws": null, "funcname": "WifiP2pDeviceList (WifiP2pDeviceList source)", "parameters": [{"scri": "WifiP2pDeviceList", "name": "source"}], "descri": "  copy constructor "}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pManager.GroupInfoListener\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onChannelDisconnected", "throws": null, "funcname": "void onChannelDisconnected ()", "descri": "  The channel to the framework has been disconnected. Application could try re-initializing using initialize(Context, Looper, WifiP2pManager.ChannelListener)", "parameters": null}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pManager.ServiceResponseListener\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onConnectionInfoAvailable", "throws": null, "funcname": "void onConnectionInfoAvailable (WifiP2pInfo info)", "descri": "  The requested connection info is available ", "parameters": [{"scri": "WifiP2pInfo: Wi-Fi p2p connection info", "name": "info"}]}, {"returns": null, "class": "android.net.wifi.p2p.WifiP2pManager.UpnpServiceResponseListener\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onDnsSdTxtRecordAvailable", "throws": null, "funcname": "void onDnsSdTxtRecordAvailable (String fullDomainName,                 Map<String,\u00a0String> txtRecordMap,                 WifiP2pDevice srcDevice)", "descri": "  The requested Bonjour service response is available. This function is invoked when the device with the specified full service domain service returned TXT record. ", "parameters": [{"scri": "String: full domain name.  e.g) \"MyPrinter._ipp._tcp.local.\".", "name": "fullDomainName"}, {"scri": "Map: TXT record data as a map of key/value pairs", "name": "txtRecordMap"}, {"scri": "WifiP2pDevice: source device.", "name": "srcDevice"}]}, {"returns": null, "class": "android.net.wifi.WifiManager.WifiLock\n", "type": "void", "name": "onStarted", "throws": null, "funcname": "void onStarted (WifiManager.LocalOnlyHotspotReservation reservation)", "descri": "  LocalOnlyHotspot start succeeded. ", "parameters": [{"scri": "WifiManager.LocalOnlyHotspotReservation", "name": "reservation"}]}, {"returns": null, "class": "android.net.wifi.WpsInfo\n", "type": "void", "name": "acquire", "throws": null, "funcname": "void acquire ()", "descri": "  Locks the Wi-Fi radio on until release() is called. If this WifiLock is reference-counted, each call to acquire will increment the reference count, and the radio will remain locked as long as the reference count is above zero. If this WifiLock is not reference-counted, the first call to acquire will lock the radio, but subsequent calls will be ignored.  Only one call to release() will be required, regardless of the number of times that acquire is called.", "parameters": null}, {"returns": [{"scri": "true if this WifiLock is held, false otherwise", "type": "boolean"}], "class": "android.net.wifi.WpsInfo\n", "type": "boolean", "name": "isHeld", "throws": null, "funcname": "boolean isHeld ()", "descri": "  Checks whether this WifiLock is currently held. ", "parameters": null}, {"returns": null, "class": "android.net.wifi.WpsInfo\n", "type": "void", "name": "release", "throws": null, "funcname": "void release ()", "descri": "  Unlocks the Wi-Fi radio, allowing it to turn off when the device is idle. If this WifiLock is reference-counted, each call to release will decrement the reference count, and the radio will be unlocked only when the reference count reaches zero.  If the reference count goes below zero (that is, if release is called a greater number of times than acquire()), an exception is thrown. If this WifiLock is not reference-counted, the first call to release (after the radio was locked using acquire()) will unlock the radio, and subsequent calls will be ignored.", "parameters": null}, {"returns": null, "class": "android.net.wifi.WpsInfo\n", "type": "void", "name": "setReferenceCounted", "throws": null, "funcname": "void setReferenceCounted (boolean refCounted)", "descri": "  Controls whether this is a reference-counted or non-reference-counted WifiLock. Reference-counted WifiLocks keep track of the number of calls to acquire() and release(), and only allow the radio to sleep when every call to acquire() has been balanced with a call to release().  Non-reference-counted WifiLocks lock the radio whenever acquire() is called and it is unlocked, and unlock the radio whenever release() is called and it is locked. ", "parameters": [{"scri": "boolean: true if this WifiLock should keep a reference count", "name": "refCounted"}]}, {"returns": [{"scri": "whether the service is the default handler for the specified AID Requires the NFC permission.", "type": "boolean"}], "class": "android.nfc.cardemulation.OffHostApduService\n", "type": "boolean", "name": "isDefaultServiceForAid", "throws": null, "funcname": "boolean isDefaultServiceForAid (ComponentName service,                 String aid)", "descri": "  Allows an application to query whether a service is currently the default handler for a specified ISO7816-4 Application ID.  ", "parameters": [{"scri": "ComponentName: The ComponentName of the service", "name": "service"}, {"scri": "String: The ISO7816-4 Application ID", "name": "aid"}]}, {"returns": [{"scri": "whether service is currently the default service for the category. Requires the NFC permission.", "type": "boolean"}], "class": "android.nfc.cardemulation.OffHostApduService\n", "type": "boolean", "name": "isDefaultServiceForCategory", "throws": null, "funcname": "boolean isDefaultServiceForCategory (ComponentName service,                 String category)", "descri": "  Allows an application to query whether a service is currently the default service to handle a card emulation category. Note that if getSelectionModeForCategory(String) returns SELECTION_MODE_ALWAYS_ASK or SELECTION_MODE_ASK_IF_CONFLICT, this method will always return false. That is because in these selection modes a default can't be set at the category level. For categories where the selection mode is SELECTION_MODE_ALWAYS_ASK or SELECTION_MODE_ASK_IF_CONFLICT, use isDefaultServiceForAid(ComponentName, String) to determine whether a service is the default for a specific AID.  ", "parameters": [{"scri": "ComponentName: The ComponentName of the service", "name": "service"}, {"scri": "String: The category", "name": "category"}]}, {"returns": [{"scri": "whether the registration was successful.", "type": "boolean"}], "class": "android.nfc.cardemulation.OffHostApduService\n", "type": "boolean", "name": "registerAidsForService", "throws": null, "funcname": "boolean registerAidsForService (ComponentName service,                 String category,                 List<String> aids)", "descri": "  Registers a list of AIDs for a specific category for the specified service. If a list of AIDs for that category was previously registered for this service (either statically through the manifest, or dynamically by using this API), that list of AIDs will be replaced with this one. Note that you can only register AIDs for a service that is running under the same UID as the caller of this API. Typically this means you need to call this from the same package as the service itself, though UIDs can also be shared between packages using shared UIDs.  ", "parameters": [{"scri": "ComponentName: The component name of the service", "name": "service"}, {"scri": "String: The category of AIDs to be registered", "name": "category"}, {"scri": "List: A list containing the AIDs to be registered", "name": "aids"}]}, {"returns": [{"scri": "whether the group was successfully removed.", "type": "boolean"}], "class": "android.nfc.cardemulation.OffHostApduService\n", "type": "boolean", "name": "removeAidsForService", "throws": null, "funcname": "boolean removeAidsForService (ComponentName service,                 String category)", "descri": "  Removes a previously registered list of AIDs for the specified category for the service provided. Note that this will only remove AIDs that were dynamically registered using the registerAidsForService(ComponentName, String, List) method. It will *not* remove AIDs that were statically registered in the manifest. If dynamically registered AIDs are removed using this method, and a statically registered AID group for the same category exists in the manifest, the static AID group will become active again.  ", "parameters": [{"scri": "ComponentName: The component name of the service", "name": "service"}, {"scri": "String: The category of the AIDs to be removed, e.g. CATEGORY_PAYMENT", "name": "category"}]}, {"returns": null, "class": "android.nfc.NdefRecord\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onNdefPushComplete", "throws": null, "funcname": "void onNdefPushComplete (NfcEvent event)", "descri": "  Called on successful NDEF push. This callback is usually made on a binder thread (not the UI thread).   See also: setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...)", "parameters": [{"scri": "NfcEvent: NfcEvent with the nfcAdapter field set", "name": "event"}]}, {"returns": [{"scri": "A boolean indicating whether the app can use the RTT API at this time (true) or not (false).", "type": "boolean"}], "class": "android.nfc.NfcAdapter.OnTagRemovedListener\n", "type": "boolean", "name": "isAvailable", "throws": null, "funcname": "boolean isAvailable ()", "descri": "  Returns the current status of RTT API: whether or not RTT is available. To track changes in the state of RTT API register for the ACTION_WIFI_RTT_STATE_CHANGED broadcast. Note: availability of RTT does not mean that the app can use the API. The app's permissions and platform Location Mode are validated at run-time. ", "parameters": null}, {"returns": null, "class": "android.nfc.NfcAdapter.OnTagRemovedListener\n", "type": "void", "name": "startRanging", "throws": null, "funcname": "void startRanging (RangingRequest request,                 Executor executor,                 RangingResultCallback callback)", "descri": "  Initiate a request to range to a set of devices specified in the RangingRequest. Results will be returned in the RangingResultCallback set of callbacks. Requires the ACCESS_FINE_LOCATION, CHANGE_WIFI_STATE and ACCESS_WIFI_STATE permissions. ", "parameters": [{"scri": "RangingRequest: A request specifying a set of devices whose distance measurements are                 requested.This value must never be null.", "name": "request"}, {"scri": "Executor: The Executor on which to run the callback.This value must never be null.Callback and listener events are dispatched through this           Executor, providing an easy way to control which thread is           used. To dispatch events through the main thread of your           application, you can use getMainExecutor(). To           dispatch events through a shared thread pool, you can use           THREAD_POOL_EXECUTOR.", "name": "executor"}, {"scri": "RangingResultCallback: A callback for the result of the ranging request.This value must never be null.", "name": "callback"}]}, {"returns": [{"scri": "NDEF Message in binary format", "type": "byte[]"}], "class": "android.nfc.NfcEvent\n", "type": "byte[]", "name": "toByteArray", "throws": null, "funcname": "byte[] toByteArray ()", "descri": "  Return this NDEF Message as raw bytes. The NDEF Message is formatted as per the NDEF 1.0 specification, and the byte array is suitable for network transmission or storage in an NFC Forum NDEF compatible tag. This method will not chunk any records, and will always use the short record (SR) format and omit the identifier field when possible.   See also: ERROR(/getByteArrayLength)", "parameters": null}, {"returns": null, "class": "android.nfc.NfcEvent\n", "name": "NdefMessage", "throws": [{"scri": "if the data cannot be parsed", "type": "FormatException"}], "funcname": "NdefMessage (byte[] data)", "parameters": [{"scri": "byte: raw bytes to parse", "name": "data"}], "descri": "  Construct an NDEF Message by parsing raw bytes. Strict validation of the NDEF binary structure is performed: there must be at least one record, every record flag must be correct, and the total length of the message must match the length of the input data. This parser can handle chunked records, and converts them into logical NdefRecords within the message. Once the input data has been parsed to one or more logical records, basic validation of the tnf, type, id, and payload fields of each record is performed, as per the documentation on on NdefRecord(short, byte[], byte[], byte[]) If either strict validation of the binary format fails, or basic validation during record construction fails, a FormatException is thrown Deep inspection of the type, id and payload fields of each record is not performed, so it is possible to parse input that has a valid binary format and confirms to the basic validation requirements of NdefRecord(short, byte[], byte[], byte[]), but fails more strict requirements as specified by the NFC Forum. It is safe to re-use the data byte array after construction: this constructor will make an internal copy of all necessary fields.   "}, {"returns": null, "class": "android.nfc.NfcEvent\n", "name": "NdefMessage", "throws": [{"scri": "if the data cannot be parsed", "type": "FormatException"}], "funcname": "NdefMessage (byte[] data)", "parameters": [{"scri": "byte: raw bytes to parse", "name": "data"}], "descri": "  Construct an NDEF Message by parsing raw bytes. Strict validation of the NDEF binary structure is performed: there must be at least one record, every record flag must be correct, and the total length of the message must match the length of the input data. This parser can handle chunked records, and converts them into logical NdefRecords within the message. Once the input data has been parsed to one or more logical records, basic validation of the tnf, type, id, and payload fields of each record is performed, as per the documentation on on NdefRecord(short, byte[], byte[], byte[]) If either strict validation of the binary format fails, or basic validation during record construction fails, a FormatException is thrown Deep inspection of the type, id and payload fields of each record is not performed, so it is possible to parse input that has a valid binary format and confirms to the basic validation requirements of NdefRecord(short, byte[], byte[], byte[]), but fails more strict requirements as specified by the NFC Forum. It is safe to re-use the data byte array after construction: this constructor will make an internal copy of all necessary fields.   "}, {"returns": null, "class": "android.nfc.NfcManager\n", "type": "static\n        \n        \n        NdefRecord", "name": "NdefRecord", "throws": [{"scri": "if a valid record cannot be created", "type": ""}], "funcname": "NdefRecord (short tnf,                 byte[] type,                 byte[] id,                 byte[] payload)", "descri": "  Construct an NDEF Record from its component fields. Recommend to use helpers such as {#createUri} or {createExternal(String, String, byte[]) where possible, since they perform stricter validation that the record is correctly formatted as per NDEF specifications. However if you know what you are doing then this constructor offers the most flexibility. An NdefRecord represents a logical (complete) record, and cannot represent NDEF Record chunks. Basic validation of the tnf, type, id and payload is performed as per the following rules: The tnf paramter must be a 3-bit value. Records with a tnf of TNF_EMPTY cannot have a type, id or payload. Records with a tnf of TNF_UNKNOWN or 0x07 cannot have a type. Records with a tnf of TNF_UNCHANGED are not allowed since this class only represents complete (unchunked) records. This minimal validation is specified by NFCForum-TS-NDEF_1.0 section 3.2.6 (Type Name Format). If any of the above validation steps fail then IllegalArgumentException is thrown. Deep inspection of the type, id and payload fields is not performed, so it is possible to create NDEF Records that conform to section 3.2.6 but fail other more strict NDEF specification requirements. For example, the payload may be invalid given the tnf and type. To omit a type, id or payload field, set the parameter to an empty byte array or null.   ", "parameters": [{"scri": "short: a 3-bit TNF constant", "name": "tnf"}, {"scri": "byte: byte array, containing zero to 255 bytes, or null", "name": "type"}, {"scri": "byte: byte array, containing zero to 255 bytes, or null", "name": "id"}, {"scri": "byte: byte array, containing zero to (2 ** 32 - 1) bytes,                or null", "name": "payload"}]}, {"returns": [{"scri": "", "type": "byte[]"}], "class": "android.nfc.NfcManager\n", "type": "byte[]", "name": "toByteArray", "throws": null, "funcname": "byte[] toByteArray ()", "descri": "   This method was deprecated      in API level 16.    use toByteArray() instead  Return this NDEF Record as a byte array. This method is deprecated, use toByteArray() instead. This is because the NDEF binary format is not defined for a record outside of the context of a message: the MB and ME flags cannot be set without knowing the location inside a message. This implementation will attempt to serialize a single record by always setting the MB and ME flags (in other words, assume this is a single-record NDEF Message).  ", "parameters": null}, {"returns": null, "class": "android.nfc.NfcManager\n", "name": "NdefRecord", "throws": [{"scri": "if a valid record cannot be created", "type": ""}], "funcname": "NdefRecord (short tnf,                 byte[] type,                 byte[] id,                 byte[] payload)", "parameters": [{"scri": "short: a 3-bit TNF constant", "name": "tnf"}, {"scri": "byte: byte array, containing zero to 255 bytes, or null", "name": "type"}, {"scri": "byte: byte array, containing zero to 255 bytes, or null", "name": "id"}, {"scri": "byte: byte array, containing zero to (2 ** 32 - 1) bytes,                or null", "name": "payload"}], "descri": "  Construct an NDEF Record from its component fields. Recommend to use helpers such as {#createUri} or {createExternal(String, String, byte[]) where possible, since they perform stricter validation that the record is correctly formatted as per NDEF specifications. However if you know what you are doing then this constructor offers the most flexibility. An NdefRecord represents a logical (complete) record, and cannot represent NDEF Record chunks. Basic validation of the tnf, type, id and payload is performed as per the following rules: The tnf paramter must be a 3-bit value. Records with a tnf of TNF_EMPTY cannot have a type, id or payload. Records with a tnf of TNF_UNKNOWN or 0x07 cannot have a type. Records with a tnf of TNF_UNCHANGED are not allowed since this class only represents complete (unchunked) records. This minimal validation is specified by NFCForum-TS-NDEF_1.0 section 3.2.6 (Type Name Format). If any of the above validation steps fail then IllegalArgumentException is thrown. Deep inspection of the type, id and payload fields is not performed, so it is possible to create NDEF Records that conform to section 3.2.6 but fail other more strict NDEF specification requirements. For example, the payload may be invalid given the tnf and type. To omit a type, id or payload field, set the parameter to an empty byte array or null.   "}, {"returns": null, "class": "android.nfc.NfcManager\n", "name": "NdefRecord", "throws": [{"scri": "if a valid record cannot be created", "type": ""}], "funcname": "NdefRecord (short tnf,                 byte[] type,                 byte[] id,                 byte[] payload)", "parameters": [{"scri": "short: a 3-bit TNF constant", "name": "tnf"}, {"scri": "byte: byte array, containing zero to 255 bytes, or null", "name": "type"}, {"scri": "byte: byte array, containing zero to 255 bytes, or null", "name": "id"}, {"scri": "byte: byte array, containing zero to (2 ** 32 - 1) bytes,                or null", "name": "payload"}], "descri": "  Construct an NDEF Record from its component fields. Recommend to use helpers such as {#createUri} or {createExternal(String, String, byte[]) where possible, since they perform stricter validation that the record is correctly formatted as per NDEF specifications. However if you know what you are doing then this constructor offers the most flexibility. An NdefRecord represents a logical (complete) record, and cannot represent NDEF Record chunks. Basic validation of the tnf, type, id and payload is performed as per the following rules: The tnf paramter must be a 3-bit value. Records with a tnf of TNF_EMPTY cannot have a type, id or payload. Records with a tnf of TNF_UNKNOWN or 0x07 cannot have a type. Records with a tnf of TNF_UNCHANGED are not allowed since this class only represents complete (unchunked) records. This minimal validation is specified by NFCForum-TS-NDEF_1.0 section 3.2.6 (Type Name Format). If any of the above validation steps fail then IllegalArgumentException is thrown. Deep inspection of the type, id and payload fields is not performed, so it is possible to create NDEF Records that conform to section 3.2.6 but fail other more strict NDEF specification requirements. For example, the payload may be invalid given the tnf and type. To omit a type, id or payload field, set the parameter to an empty byte array or null.   "}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "disableForegroundDispatch", "throws": [{"scri": "if the Activity has already been paused", "type": "IllegalStateException"}, {"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void disableForegroundDispatch (Activity activity)", "descri": "  Disable foreground dispatch to the given activity. After calling enableForegroundDispatch(Activity, PendingIntent, IntentFilter[], String[][]), an activity must call this method before its onPause() callback completes. This method must be called from the main thread. Requires the NFC permission.   ", "parameters": [{"scri": "Activity: the Activity to disable dispatch to", "name": "activity"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "disableForegroundNdefPush", "throws": [{"scri": "if the Activity has already been paused", "type": "IllegalStateException"}, {"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void disableForegroundNdefPush (Activity activity)", "descri": "   This method was deprecated      in API level 14.    use setNdefPushMessage(NdefMessage, Activity, Activity...) instead  Disable NDEF message push over P2P. After calling enableForegroundNdefPush(Activity, NdefMessage), an activity must call this method before its onPause() callback completes. Strongly recommend to use the new setNdefPushMessage(NdefMessage, Activity, Activity...) instead: it automatically hooks into your activity life-cycle, so you do not need to call enable/disable in your onResume/onPause. This method must be called from the main thread. Requires the NFC permission.   ", "parameters": [{"scri": "Activity: the Foreground activity", "name": "activity"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "disableReaderMode", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void disableReaderMode (Activity activity)", "descri": "  Restore the NFC adapter to normal mode of operation: supporting peer-to-peer (Android Beam), card emulation, and polling for all supported tag technologies.   ", "parameters": [{"scri": "Activity: the Activity that currently has reader mode enabled", "name": "activity"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "enableForegroundDispatch", "throws": [{"scri": "if the Activity is not currently in the foreground", "type": "IllegalStateException"}, {"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void enableForegroundDispatch (Activity activity,                 PendingIntent intent,                 IntentFilter[] filters,                 String[][] techLists)", "descri": "  Enable foreground dispatch to the given Activity. This will give give priority to the foreground activity when dispatching a discovered Tag to an application. If any IntentFilters are provided to this method they are used to match dispatch Intents for both the ACTION_NDEF_DISCOVERED and ACTION_TAG_DISCOVERED. Since ACTION_TECH_DISCOVERED relies on meta data outside of the IntentFilter matching for that dispatch Intent is handled by passing in the tech lists separately. Each first level entry in the tech list represents an array of technologies that must all be present to match. If any of the first level sets match then the dispatch is routed through the given PendingIntent. In other words, the second level is ANDed together and the first level entries are ORed together. If you pass null for both the filters and techLists parameters that acts a wild card and will cause the foreground activity to receive all tags via the ACTION_TAG_DISCOVERED intent. This method must be called from the main thread, and only when the activity is in the foreground (resumed). Also, activities must call disableForegroundDispatch(Activity) before the completion of their onPause() callback to disable foreground dispatch after it has been enabled. Requires the NFC permission.   ", "parameters": [{"scri": "Activity: the Activity to dispatch to", "name": "activity"}, {"scri": "PendingIntent: the PendingIntent to start for the dispatch", "name": "intent"}, {"scri": "IntentFilter: the IntentFilters to override dispatching for, or null to always dispatch", "name": "filters"}, {"scri": "String: the tech lists used to perform matching for dispatching of the      ACTION_TECH_DISCOVERED intent", "name": "techLists"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "enableForegroundNdefPush", "throws": [{"scri": "if the activity is not currently in the foreground", "type": "IllegalStateException"}, {"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void enableForegroundNdefPush (Activity activity,                 NdefMessage message)", "descri": "   This method was deprecated      in API level 14.    use setNdefPushMessage(NdefMessage, Activity, Activity...) instead  Enable NDEF message push over NFC while this Activity is in the foreground. You must explicitly call this method every time the activity is resumed, and you must call disableForegroundNdefPush(Activity) before your activity completes onPause(). Strongly recommend to use the new setNdefPushMessage(NdefMessage, Activity, Activity...) instead: it automatically hooks into your activity life-cycle, so you do not need to call enable/disable in your onResume/onPause. For NDEF push to function properly the other NFC device must support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or Android's \"com.android.npp\" (Ndef Push Protocol). This was optional on Gingerbread level Android NFC devices, but SNEP is mandatory on Ice-Cream-Sandwich and beyond. This method must be called from the main thread. Requires the NFC permission.   ", "parameters": [{"scri": "Activity: foreground activity", "name": "activity"}, {"scri": "NdefMessage: a NDEF Message to push over NFC", "name": "message"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "enableReaderMode", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void enableReaderMode (Activity activity,                 NfcAdapter.ReaderCallback callback,                 int flags,                 Bundle extras)", "descri": "  Limit the NFC controller to reader mode while this Activity is in the foreground. In this mode the NFC controller will only act as an NFC tag reader/writer, thus disabling any peer-to-peer (Android Beam) and card-emulation modes of the NFC adapter on this device. Use FLAG_READER_SKIP_NDEF_CHECK to prevent the platform from performing any NDEF checks in reader mode. Note that this will prevent the Ndef tag technology from being enumerated on the tag, and that NDEF-based tag dispatch will not be functional. For interacting with tags that are emulated on another Android device using Android's host-based card-emulation, the recommended flags are FLAG_READER_NFC_A and FLAG_READER_SKIP_NDEF_CHECK.   ", "parameters": [{"scri": "Activity: the Activity that requests the adapter to be in reader mode", "name": "activity"}, {"scri": "NfcAdapter.ReaderCallback: the callback to be called when a tag is discovered", "name": "callback"}, {"scri": "int: Flags indicating poll technologies and other optional parameters", "name": "flags"}, {"scri": "Bundle: Additional extras for configuring reader mode.", "name": "extras"}]}, {"returns": [{"scri": "false if the tag couldn't be found (or has already gone out of range), true otherwise", "type": "boolean"}], "class": "android.nfc.Tag\n", "type": "boolean", "name": "ignore", "throws": null, "funcname": "boolean ignore (Tag tag,                 int debounceMs,                 NfcAdapter.OnTagRemovedListener tagRemovedListener,                 Handler handler)", "descri": "  Signals that you are no longer interested in communicating with an NFC tag for as long as it remains in range. All future attempted communication to this tag will fail with IOException. The NFC controller will be put in a low-power polling mode, allowing the device to save power in cases where it's \"attached\" to a tag all the time (e.g. a tag in car dock). Additionally the debounceMs parameter allows you to specify for how long the tag needs to have gone out of range, before it will be dispatched again. Note: the NFC controller typically polls at a pretty slow interval (100 - 500 ms). This means that if the tag repeatedly goes in and out of range (for example, in case of a flaky connection), and the controller happens to poll every time the tag is out of range, it *will* re-dispatch the tag after debounceMs, despite the tag having been \"in range\" during the interval. Note 2: if a tag with another UID is detected after this API is called, its effect will be cancelled; if this tag shows up before the amount of time specified in debounceMs, it will be dispatched again. Note 3: some tags have a random UID, in which case this API won't work reliably.  ", "parameters": [{"scri": "Tag: the Tag to ignore.", "name": "tag"}, {"scri": "int: minimum amount of time the tag needs to be out of range before being                   dispatched again.", "name": "debounceMs"}, {"scri": "NfcAdapter.OnTagRemovedListener: listener to be called when the tag is removed from the field.                           Note that this will only be called if the tag has been out of range                           for at least debounceMs, or if another tag came into range before                           debounceMs. May be null in case you don't want a callback.", "name": "tagRemovedListener"}, {"scri": "Handler: the Handler that will be used for delivering                the callback. if the handler is null, then the thread used for delivering                the callback is unspecified.", "name": "handler"}]}, {"returns": [{"scri": "whether the Beam animation was successfully invoked", "type": "boolean"}], "class": "android.nfc.Tag\n", "type": "boolean", "name": "invokeBeam", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "boolean invokeBeam (Activity activity)", "descri": "  Manually invoke Android Beam to share data. The Android Beam animation is normally only shown when two NFC-capable devices come into range. By calling this method, an Activity can invoke the Beam animation directly even if no other NFC device is in range yet. The Beam animation will then prompt the user to tap another NFC-capable device to complete the data transfer. The main advantage of using this method is that it avoids the need for the user to tap the screen to complete the transfer, as this method already establishes the direction of the transfer and the consent of the user to share data. Callers are responsible for making sure that the user has consented to sharing data on NFC tap. Note that to use this method, the passed in Activity must have already set data to share over Beam by using method calls such as setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...) or setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback, Activity).    ", "parameters": [{"scri": "Activity: the current foreground Activity that has registered data to share", "name": "activity"}]}, {"returns": [{"scri": "true if this NFC Adapter has any features enabled", "type": "boolean"}], "class": "android.nfc.Tag\n", "type": "boolean", "name": "isEnabled", "throws": null, "funcname": "boolean isEnabled ()", "descri": "  Return true if this NFC Adapter has any features enabled. If this method returns false, the NFC hardware is guaranteed not to generate or respond to any NFC communication over its NFC radio. Applications can use this to check if NFC is enabled. Applications can request Settings UI allowing the user to toggle NFC using:  startActivity(new Intent(Settings.ACTION_NFC_SETTINGS))   See also: ACTION_NFC_SETTINGS", "parameters": null}, {"returns": [{"scri": "true if NDEF Push feature is enabled", "type": "boolean"}], "class": "android.nfc.Tag\n", "type": "boolean", "name": "isNdefPushEnabled", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "boolean isNdefPushEnabled ()", "descri": "  Return true if the NDEF Push (Android Beam) feature is enabled. This function will return true only if both NFC is enabled, and the NDEF Push feature is enabled. Note that if NFC is enabled but NDEF Push is disabled then this device can still receive NDEF messages, it just cannot send them. Applications cannot directly toggle the NDEF Push feature, but they can request Settings UI allowing the user to toggle NDEF Push using startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS)) Example usage in an Activity that requires NDEF Push:  protected void onResume() {     super.onResume();     if (!nfcAdapter.isEnabled()) {         startActivity(new Intent(Settings.ACTION_NFC_SETTINGS));     } else if (!nfcAdapter.isNdefPushEnabled()) {         startActivity(new Intent(Settings.ACTION_NFCSHARING_SETTINGS));     } }    See also: ACTION_NFCSHARING_SETTINGS", "parameters": null}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "setBeamPushUris", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void setBeamPushUris (Uri[] uris,                 Activity activity)", "descri": "  Set one or more Uris to send using Android Beam (TM). Every Uri you provide must have either scheme 'file' or scheme 'content'. For the data provided through this method, Android Beam tries to switch to alternate transports such as Bluetooth to achieve a fast transfer speed. Hence this method is very suitable for transferring large files such as pictures or songs. The receiving side will store the content of each Uri in a file and present a notification to the user to open the file with a Intent with action ACTION_VIEW. If multiple URIs are sent, the Intent will refer to the first of the stored files. This method may be called at any time before onDestroy(), but the URI(s) are only made available for Android Beam when the specified activity(s) are in resumed (foreground) state. The recommended approach is to call this method during your Activity's onCreate(Bundle) - see sample code below. This method does not immediately perform any I/O or blocking work, so is safe to call on your main thread. setBeamPushUris(Uri[], Activity) and setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback, Activity) have priority over both setNdefPushMessage(NdefMessage, Activity, Activity...) and setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...). If setBeamPushUris(Uri[], Activity) is called with a null Uri array, and/or setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback, Activity) is called with a null callback, then the Uri push will be completely disabled for the specified activity(s). Code example: protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);     if (nfcAdapter == null) return;  // NFC not available on this device     nfcAdapter.setBeamPushUris(new Uri[] {uri1, uri2}, this); } And that is it. Only one call per activity is necessary. The Android OS will automatically release its references to the Uri(s) and the Activity object when it is destroyed if you follow this pattern. If your Activity wants to dynamically supply Uri(s), then set a callback using setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback, Activity) instead of using this method. Do not pass in an Activity that has already been through onDestroy(). This is guaranteed if you call this API during onCreate(Bundle). If this device does not support alternate transports such as Bluetooth or WiFI, calling this method does nothing. Requires the NFC permission.   ", "parameters": [{"scri": "Uri: an array of Uri(s) to push over Android Beam", "name": "uris"}, {"scri": "Activity: activity for which the Uri(s) will be pushed", "name": "activity"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "setBeamPushUrisCallback", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void setBeamPushUrisCallback (NfcAdapter.CreateBeamUrisCallback callback,                 Activity activity)", "descri": "  Set a callback that will dynamically generate one or more Uris to send using Android Beam (TM). Every Uri the callback provides must have either scheme 'file' or scheme 'content'. For the data provided through this callback, Android Beam tries to switch to alternate transports such as Bluetooth to achieve a fast transfer speed. Hence this method is very suitable for transferring large files such as pictures or songs. The receiving side will store the content of each Uri in a file and present a notification to the user to open the file with a Intent with action ACTION_VIEW. If multiple URIs are sent, the Intent will refer to the first of the stored files. This method may be called at any time before onDestroy(), but the URI(s) are only made available for Android Beam when the specified activity(s) are in resumed (foreground) state. The recommended approach is to call this method during your Activity's onCreate(Bundle) - see sample code below. This method does not immediately perform any I/O or blocking work, so is safe to call on your main thread. setBeamPushUris(Uri[], Activity) and setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback, Activity) have priority over both setNdefPushMessage(NdefMessage, Activity, Activity...) and setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...). If setBeamPushUris(Uri[], Activity) is called with a null Uri array, and/or setBeamPushUrisCallback(NfcAdapter.CreateBeamUrisCallback, Activity) is called with a null callback, then the Uri push will be completely disabled for the specified activity(s). Code example: protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);     if (nfcAdapter == null) return;  // NFC not available on this device     nfcAdapter.setBeamPushUrisCallback(callback, this); } And that is it. Only one call per activity is necessary. The Android OS will automatically release its references to the Uri(s) and the Activity object when it is destroyed if you follow this pattern. Do not pass in an Activity that has already been through onDestroy(). This is guaranteed if you call this API during onCreate(Bundle). If this device does not support alternate transports such as Bluetooth or WiFI, calling this method does nothing. Requires the NFC permission.   ", "parameters": [{"scri": "NfcAdapter.CreateBeamUrisCallback: callback, or null to disable", "name": "callback"}, {"scri": "Activity: activity for which the Uri(s) will be pushed", "name": "activity"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "setNdefPushMessage", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void setNdefPushMessage (NdefMessage message,                 Activity activity,                 Activity... activities)", "descri": "  Set a static NdefMessage to send using Android Beam (TM). This method may be called at any time before onDestroy(), but the NDEF message is only made available for NDEF push when the specified activity(s) are in resumed (foreground) state. The recommended approach is to call this method during your Activity's onCreate(Bundle) - see sample code below. This method does not immediately perform any I/O or blocking work, so is safe to call on your main thread. Only one NDEF message can be pushed by the currently resumed activity. If both setNdefPushMessage(NdefMessage, Activity, Activity...) and setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...) are set, then the callback will take priority. If neither setNdefPushMessage(NdefMessage, Activity, Activity...) or setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...) have been called for your activity, then the Android OS may choose to send a default NDEF message on your behalf, such as a URI for your application. If setNdefPushMessage(NdefMessage, Activity, Activity...) is called with a null NDEF message, and/or setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...) is called with a null callback, then NDEF push will be completely disabled for the specified activity(s). This also disables any default NDEF message the Android OS would have otherwise sent on your behalf for those activity(s). If you want to prevent the Android OS from sending default NDEF messages completely (for all activities), you can include a <meta-data> element inside the <application> element of your AndroidManifest.xml file, like this: <application ...>     <meta-data android:name=\"android.nfc.disable_beam_default\"         android:value=\"true\" /> </application>  The API allows for multiple activities to be specified at a time, but it is strongly recommended to just register one at a time, and to do so during the activity's onCreate(Bundle). For example: protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);     if (nfcAdapter == null) return;  // NFC not available on this device     nfcAdapter.setNdefPushMessage(ndefMessage, this); } And that is it. Only one call per activity is necessary. The Android OS will automatically release its references to the NDEF message and the Activity object when it is destroyed if you follow this pattern. If your Activity wants to dynamically generate an NDEF message, then set a callback using setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...) instead of a static message. Do not pass in an Activity that has already been through onDestroy(). This is guaranteed if you call this API during onCreate(Bundle). For sending large content such as pictures and songs, consider using setBeamPushUris(Uri[], Activity), which switches to alternate transports such as Bluetooth to achieve a fast transfer rate. Requires the NFC permission.   ", "parameters": [{"scri": "NdefMessage: NDEF message to push over NFC, or null to disable", "name": "message"}, {"scri": "Activity: activity for which the NDEF message will be pushed", "name": "activity"}, {"scri": "Activity: optional additional activities, however we strongly recommend        to only register one at a time, and to do so in that activity's        onCreate(Bundle)", "name": "activities"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "setNdefPushMessageCallback", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void setNdefPushMessageCallback (NfcAdapter.CreateNdefMessageCallback callback,                 Activity activity,                 Activity... activities)", "descri": "  Set a callback that dynamically generates NDEF messages to send using Android Beam (TM). This method may be called at any time before onDestroy(), but the NDEF message callback can only occur when the specified activity(s) are in resumed (foreground) state. The recommended approach is to call this method during your Activity's onCreate(Bundle) - see sample code below. This method does not immediately perform any I/O or blocking work, so is safe to call on your main thread. Only one NDEF message can be pushed by the currently resumed activity. If both setNdefPushMessage(NdefMessage, Activity, Activity...) and setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...) are set, then the callback will take priority. If neither setNdefPushMessage(NdefMessage, Activity, Activity...) or setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...) have been called for your activity, then the Android OS may choose to send a default NDEF message on your behalf, such as a URI for your application. If setNdefPushMessage(NdefMessage, Activity, Activity...) is called with a null NDEF message, and/or setNdefPushMessageCallback(NfcAdapter.CreateNdefMessageCallback, Activity, Activity...) is called with a null callback, then NDEF push will be completely disabled for the specified activity(s). This also disables any default NDEF message the Android OS would have otherwise sent on your behalf for those activity(s). If you want to prevent the Android OS from sending default NDEF messages completely (for all activities), you can include a <meta-data> element inside the <application> element of your AndroidManifest.xml file, like this: <application ...>     <meta-data android:name=\"android.nfc.disable_beam_default\"         android:value=\"true\" /> </application>  The API allows for multiple activities to be specified at a time, but it is strongly recommended to just register one at a time, and to do so during the activity's onCreate(Bundle). For example: protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);     if (nfcAdapter == null) return;  // NFC not available on this device     nfcAdapter.setNdefPushMessageCallback(callback, this); } And that is it. Only one call per activity is necessary. The Android OS will automatically release its references to the callback and the Activity object when it is destroyed if you follow this pattern. Do not pass in an Activity that has already been through onDestroy(). This is guaranteed if you call this API during onCreate(Bundle). For sending large content such as pictures and songs, consider using setBeamPushUris(Uri[], Activity), which switches to alternate transports such as Bluetooth to achieve a fast transfer rate. Requires the NFC permission.   ", "parameters": [{"scri": "NfcAdapter.CreateNdefMessageCallback: callback, or null to disable", "name": "callback"}, {"scri": "Activity: activity for which the NDEF message will be pushed", "name": "activity"}, {"scri": "Activity: optional additional activities, however we strongly recommend        to only register one at a time, and to do so in that activity's        onCreate(Bundle)", "name": "activities"}]}, {"returns": null, "class": "android.nfc.Tag\n", "type": "void", "name": "setOnNdefPushCompleteCallback", "throws": [{"scri": "if FEATURE_NFC is unavailable.", "type": "UnsupportedOperationException"}], "funcname": "void setOnNdefPushCompleteCallback (NfcAdapter.OnNdefPushCompleteCallback callback,                 Activity activity,                 Activity... activities)", "descri": "  Set a callback on successful Android Beam (TM). This method may be called at any time before onDestroy(), but the callback can only occur when the specified activity(s) are in resumed (foreground) state. The recommended approach is to call this method during your Activity's onCreate(Bundle) - see sample code below. This method does not immediately perform any I/O or blocking work, so is safe to call on your main thread. The API allows for multiple activities to be specified at a time, but it is strongly recommended to just register one at a time, and to do so during the activity's onCreate(Bundle). For example: protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);     if (nfcAdapter == null) return;  // NFC not available on this device     nfcAdapter.setOnNdefPushCompleteCallback(callback, this); } And that is it. Only one call per activity is necessary. The Android OS will automatically release its references to the callback and the Activity object when it is destroyed if you follow this pattern. Do not pass in an Activity that has already been through onDestroy(). This is guaranteed if you call this API during onCreate(Bundle). Requires the NFC permission.   ", "parameters": [{"scri": "NfcAdapter.OnNdefPushCompleteCallback: callback, or null to disable", "name": "callback"}, {"scri": "Activity: activity for which the NDEF message will be pushed", "name": "activity"}, {"scri": "Activity: optional additional activities, however we strongly recommend        to only register one at a time, and to do so in that activity's        onCreate(Bundle)", "name": "activities"}]}, {"returns": null, "class": "android.nfc.tech.MifareClassic\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.   See also: connect()", "parameters": null}, {"returns": null, "class": "android.nfc.tech.MifareClassic\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "connect", "throws": [{"scri": "if the tag leaves the field", "type": ""}, {"scri": "if there is an I/O failure, or connect is canceled", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.   See also: close()", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NdefFormatable\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NdefFormatable\n", "type": "void", "name": "connect", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.  ", "parameters": null}, {"returns": [{"scri": "timeout value in milliseconds", "type": "int"}], "class": "android.nfc.tech.NdefFormatable\n", "type": "int", "name": "getTimeout", "throws": null, "funcname": "int getTimeout ()", "descri": "  Get the current timeout for transceive(byte[]) in milliseconds. Requires the NFC permission. ", "parameters": null}, {"returns": [{"scri": "whether the NFC adapter on this device supports extended length APDUs.", "type": "boolean"}], "class": "android.nfc.tech.NdefFormatable\n", "type": "boolean", "name": "isExtendedLengthApduSupported", "throws": null, "funcname": "boolean isExtendedLengthApduSupported ()", "descri": "   Standard APDUs have a 1-byte length field, allowing a maximum of 255 payload bytes, which results in a maximum APDU length of 261 bytes. Extended length APDUs have a 3-byte length field, allowing 65535 payload bytes. Some NFC adapters, like the one used in the Nexus S and the Galaxy Nexus do not support extended length APDUs. They are expected to be well-supported in the future though. Use this method to check for extended length APDU support. ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NdefFormatable\n", "type": "void", "name": "setTimeout", "throws": null, "funcname": "void setTimeout (int timeout)", "descri": "  Set the timeout of transceive(byte[]) in milliseconds. The timeout only applies to ISO-DEP transceive(byte[]), and is reset to a default value when close() is called. Setting a longer timeout may be useful when performing transactions that require a long processing time on the tag such as key generation. Requires the NFC permission. ", "parameters": [{"scri": "int: timeout value in milliseconds", "name": "timeout"}]}, {"returns": [{"scri": "response bytes received, will not be null", "type": "byte[]"}], "class": "android.nfc.tech.NdefFormatable\n", "type": "byte[]", "name": "transceive", "throws": [{"scri": "if the tag leaves the field", "type": ""}, {"scri": "if there is an I/O failure, or this operation is canceled", "type": "IOException"}], "funcname": "byte[] transceive (byte[] data)", "descri": "  Send raw ISO-DEP data to the tag and receive the response. Applications must only send the INF payload, and not the start of frame and end of frame indicators. Applications do not need to fragment the payload, it will be automatically fragmented and defragmented by transceive(byte[]) if it exceeds FSD/FSC limits. Use getMaxTransceiveLength() to retrieve the maximum number of bytes that can be sent with transceive(byte[]). This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.    ", "parameters": [{"scri": "byte: command bytes to send, must not be null", "name": "data"}]}, {"returns": [{"scri": "true on success, false on authentication failure", "type": "boolean"}], "class": "android.nfc.tech.NfcA\n", "type": "boolean", "name": "authenticateSectorWithKeyA", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "boolean authenticateSectorWithKeyA (int sectorIndex,                 byte[] key)", "descri": "  Authenticate a sector with key A. Successful authentication of a sector with key A enables other I/O operations on that sector. The set of operations granted by key A key depends on the ACL bits set in that sector. For more information see the MIFARE Classic specification on . A failed authentication attempt causes an implicit reconnection to the tag, so authentication to other sectors will be lost. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.     See also: ERROR(/http://www.nxp.com)", "parameters": [{"scri": "int: index of sector to authenticate, starting from 0", "name": "sectorIndex"}, {"scri": "byte: 6-byte authentication key", "name": "key"}]}, {"returns": [{"scri": "true on success, false on authentication failure", "type": "boolean"}], "class": "android.nfc.tech.NfcA\n", "type": "boolean", "name": "authenticateSectorWithKeyB", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "boolean authenticateSectorWithKeyB (int sectorIndex,                 byte[] key)", "descri": "  Authenticate a sector with key B. Successful authentication of a sector with key B enables other I/O operations on that sector. The set of operations granted by key B depends on the ACL bits set in that sector. For more information see the MIFARE Classic specification on . A failed authentication attempt causes an implicit reconnection to the tag, so authentication to other sectors will be lost. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.     See also: ERROR(/http://www.nxp.com)", "parameters": [{"scri": "int: index of sector to authenticate, starting from 0", "name": "sectorIndex"}, {"scri": "byte: 6-byte authentication key", "name": "key"}]}, {"returns": null, "class": "android.nfc.tech.NfcA\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NfcA\n", "type": "void", "name": "connect", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NfcA\n", "type": "void", "name": "decrement", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "void decrement (int blockIndex,                 int value)", "descri": "  Decrement a value block, storing the result in the temporary block on the tag. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "int: index of block to decrement, starting from 0", "name": "blockIndex"}, {"scri": "int: non-negative to decrement by", "name": "value"}]}, {"returns": [{"scri": "timeout value in milliseconds", "type": "int"}], "class": "android.nfc.tech.NfcA\n", "type": "int", "name": "getTimeout", "throws": null, "funcname": "int getTimeout ()", "descri": "  Get the current transceive(byte[]) timeout in milliseconds. Requires the NFC permission. ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NfcA\n", "type": "void", "name": "increment", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "void increment (int blockIndex,                 int value)", "descri": "  Increment a value block, storing the result in the temporary block on the tag. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "int: index of block to increment, starting from 0", "name": "blockIndex"}, {"scri": "int: non-negative to increment by", "name": "value"}]}, {"returns": [{"scri": "16 byte block", "type": "byte[]"}], "class": "android.nfc.tech.NfcA\n", "type": "byte[]", "name": "readBlock", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "byte[] readBlock (int blockIndex)", "descri": "  Read 16-byte block. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.    ", "parameters": [{"scri": "int: index of block to read, starting from 0", "name": "blockIndex"}]}, {"returns": null, "class": "android.nfc.tech.NfcA\n", "type": "void", "name": "restore", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "void restore (int blockIndex)", "descri": "  Copy from a value block to the temporary block. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "int: index of block to copy from", "name": "blockIndex"}]}, {"returns": null, "class": "android.nfc.tech.NfcA\n", "type": "void", "name": "setTimeout", "throws": null, "funcname": "void setTimeout (int timeout)", "descri": "  Set the transceive(byte[]) timeout in milliseconds. The timeout only applies to transceive(byte[]) on this object, and is reset to a default value when close() is called. Setting a longer timeout may be useful when performing transactions that require a long processing time on the tag such as key generation. Requires the NFC permission. ", "parameters": [{"scri": "int: timeout value in milliseconds", "name": "timeout"}]}, {"returns": [{"scri": "", "type": "byte[]"}], "class": "android.nfc.tech.NfcA\n", "type": "byte[]", "name": "transceive", "throws": [{"scri": "", "type": "IOException"}], "funcname": "byte[] transceive (byte[] data)", "descri": "  Send raw NfcA data to a tag and receive the response. This is equivalent to connecting to this tag via NfcA and calling transceive(byte[]). Note that all MIFARE Classic tags are based on NfcA technology. Use getMaxTransceiveLength() to retrieve the maximum number of bytes that can be sent with transceive(byte[]). This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.     See also: transceive(byte[])", "parameters": [{"scri": "byte", "name": "data"}]}, {"returns": null, "class": "android.nfc.tech.NfcA\n", "type": "void", "name": "transfer", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "void transfer (int blockIndex)", "descri": "  Copy from the temporary block to a value block. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "int: index of block to copy to", "name": "blockIndex"}]}, {"returns": null, "class": "android.nfc.tech.NfcA\n", "type": "void", "name": "writeBlock", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "void writeBlock (int blockIndex,                 byte[] data)", "descri": "  Write 16-byte block. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "int: index of block to write, starting from 0", "name": "blockIndex"}, {"scri": "byte: 16 bytes of data to write", "name": "data"}]}, {"returns": null, "class": "android.nfc.tech.NfcB\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NfcB\n", "type": "void", "name": "connect", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.  ", "parameters": null}, {"returns": [{"scri": "timeout value in milliseconds", "type": "int"}], "class": "android.nfc.tech.NfcB\n", "type": "int", "name": "getTimeout", "throws": null, "funcname": "int getTimeout ()", "descri": "  Get the current transceive(byte[]) timeout in milliseconds. Requires the NFC permission. ", "parameters": null}, {"returns": [{"scri": "4 pages (16 bytes)", "type": "byte[]"}], "class": "android.nfc.tech.NfcB\n", "type": "byte[]", "name": "readPages", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "byte[] readPages (int pageOffset)", "descri": "  Read 4 pages (16 bytes). The MIFARE Ultralight protocol always reads 4 pages at a time, to reduce the number of commands required to read an entire tag. If a read spans past the last readable block, then the tag will return pages that have been wrapped back to the first blocks. MIFARE Ultralight tags have readable blocks 0x00 through 0x0F. So a read to block offset 0x0E would return blocks 0x0E, 0x0F, 0x00, 0x01. MIFARE Ultralight C tags have readable blocks 0x00 through 0x2B. So a read to block 0x2A would return blocks 0x2A, 0x2B, 0x00, 0x01. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.    ", "parameters": [{"scri": "int: index of first page to read, starting from 0", "name": "pageOffset"}]}, {"returns": null, "class": "android.nfc.tech.NfcB\n", "type": "void", "name": "setTimeout", "throws": null, "funcname": "void setTimeout (int timeout)", "descri": "  Set the transceive(byte[]) timeout in milliseconds. The timeout only applies to transceive(byte[]) on this object, and is reset to a default value when close() is called. Setting a longer timeout may be useful when performing transactions that require a long processing time on the tag such as key generation. Requires the NFC permission. ", "parameters": [{"scri": "int: timeout value in milliseconds", "name": "timeout"}]}, {"returns": [{"scri": "", "type": "byte[]"}], "class": "android.nfc.tech.NfcB\n", "type": "byte[]", "name": "transceive", "throws": [{"scri": "", "type": "IOException"}], "funcname": "byte[] transceive (byte[] data)", "descri": "  Send raw NfcA data to a tag and receive the response. This is equivalent to connecting to this tag via NfcA and calling transceive(byte[]). Note that all MIFARE Classic tags are based on NfcA technology. Use getMaxTransceiveLength() to retrieve the maximum number of bytes that can be sent with transceive(byte[]). This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.     See also: transceive(byte[])", "parameters": [{"scri": "byte", "name": "data"}]}, {"returns": null, "class": "android.nfc.tech.NfcB\n", "type": "void", "name": "writePage", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "void writePage (int pageOffset,                 byte[] data)", "descri": "  Write 1 page (4 bytes). The MIFARE Ultralight protocol always writes 1 page at a time, to minimize EEPROM write cycles. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "int: index of page to write, starting from 0", "name": "pageOffset"}, {"scri": "byte: 4 bytes to write", "name": "data"}]}, {"returns": null, "class": "android.nfc.tech.NfcBarcode\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NfcBarcode\n", "type": "void", "name": "connect", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.  ", "parameters": null}, {"returns": [{"scri": "true if the tag is writable", "type": "boolean"}], "class": "android.nfc.tech.NfcBarcode\n", "type": "boolean", "name": "isWritable", "throws": null, "funcname": "boolean isWritable ()", "descri": "  Determine if the tag is writable. NFC Forum tags can be in read-only or read-write states. Does not cause any RF activity and does not block. Requires NFC permission. ", "parameters": null}, {"returns": [{"scri": "true on success, false if it is not possible to make this tag read-only", "type": "boolean"}], "class": "android.nfc.tech.NfcBarcode\n", "type": "boolean", "name": "makeReadOnly", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}], "funcname": "boolean makeReadOnly ()", "descri": "  Make a tag read-only. This sets the CC field to indicate the tag is read-only, and where possible permanently sets the lock bits to prevent any further modification of the memory. This is a one-way process and cannot be reverted! This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NfcBarcode\n", "type": "void", "name": "writeNdefMessage", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}, {"scri": "if the NDEF Message to write is malformed", "type": "FormatException"}], "funcname": "void writeNdefMessage (NdefMessage msg)", "descri": "  Overwrite the NdefMessage on this tag. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "NdefMessage: the NDEF Message to write, must not be null", "name": "msg"}]}, {"returns": null, "class": "android.nfc.tech.NfcF\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NfcF\n", "type": "void", "name": "connect", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.nfc.tech.NfcF\n", "type": "void", "name": "format", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}, {"scri": "if the NDEF Message to write is malformed", "type": "FormatException"}], "funcname": "void format (NdefMessage firstMessage)", "descri": "  Format a tag as NDEF, and write a NdefMessage. This is a multi-step process, an IOException is thrown if any one step fails. The card is left in a read-write state after this operation. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "NdefMessage: the NDEF message to write after formatting, can be null", "name": "firstMessage"}]}, {"returns": null, "class": "android.nfc.tech.NfcF\n", "type": "void", "name": "formatReadOnly", "throws": [{"scri": "if the tag leaves the field", "type": "TagLostException"}, {"scri": "if there is an I/O failure, or the operation is canceled", "type": "IOException"}, {"scri": "if the NDEF Message to write is malformed", "type": "FormatException"}], "funcname": "void formatReadOnly (NdefMessage firstMessage)", "descri": "  Formats a tag as NDEF, write a NdefMessage, and make read-only. This is a multi-step process, an IOException is thrown if any one step fails. The card is left in a read-only state if this method returns successfully. This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.   ", "parameters": [{"scri": "NdefMessage: the NDEF message to write after formatting", "name": "firstMessage"}]}, {"returns": null, "class": "android.nfc.tech.TagTechnology\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onDeactivated", "throws": null, "funcname": "void onDeactivated (int reason)", "descri": "  This method will be called in two possible scenarios: The NFC link has been deactivated or lost", "parameters": [{"scri": "int: Either DEACTIVATION_LINK_LOSS or DEACTIVATION_DESELECTED", "name": "reason"}]}, {"returns": [{"scri": "a byte-array containing the response APDU, or null if no         response APDU can be sent at this point.", "type": "byte[]"}], "class": "android.nfc.tech.TagTechnology\n", "type": "abstract\n        \n        \n        \n        \n        byte[]", "name": "processCommandApdu", "throws": null, "funcname": "byte[] processCommandApdu (byte[] commandApdu,                 Bundle extras)", "descri": "   This method will be called when a command APDU has been received from a remote device. A response APDU can be provided directly by returning a byte-array in this method. Note that in general response APDUs must be sent as quickly as possible, given the fact that the user is likely holding his device over an NFC reader when this method is called. If there are multiple services that have registered for the same AIDs in their meta-data entry, you will only get called if the user has explicitly selected your service, either as a default or just for the next tap. This method is running on the main thread of your application. If you cannot return a response APDU immediately, return null and use the sendResponseApdu(byte[]) method later.  ", "parameters": [{"scri": "byte: The APDU that was received from the remote device", "name": "commandApdu"}, {"scri": "Bundle: A bundle containing extra data. May be null.", "name": "extras"}]}, {"returns": null, "class": "android.opengl.EGLContext\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onSurfaceChanged", "throws": null, "funcname": "void onSurfaceChanged (GL10 gl,                 int width,                 int height)", "descri": "  Called when the surface changed size. Called after the surface is created and whenever the OpenGL ES surface size changes. Typically you will set your viewport here. If your camera is fixed then you could also set your projection matrix here: void onSurfaceChanged(GL10 gl, int width, int height) {     gl.glViewport(0, 0, width, height);     // for a fixed camera, set the projection too     float ratio = (float) width / height;     gl.glMatrixMode(GL10.GL_PROJECTION);     gl.glLoadIdentity();     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10); } ", "parameters": [{"scri": "GL10: the GL interface. Use instanceof to test if the interface supports GL11 or higher interfaces.", "name": "gl"}]}, {"returns": null, "class": "android.opengl.GLES31Ext.DebugProcKHR\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.opengl.GLES31Ext.DebugProcKHR\n", "type": "void", "name": "connect", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.  ", "parameters": null}, {"returns": [{"scri": "bytes received in response", "type": "byte[]"}], "class": "android.opengl.GLES31Ext.DebugProcKHR\n", "type": "byte[]", "name": "transceive", "throws": [{"scri": "if the tag leaves the field", "type": ""}, {"scri": "if there is an I/O failure, or this operation is canceled", "type": "IOException"}], "funcname": "byte[] transceive (byte[] data)", "descri": "  Send raw NFC-B commands to the tag and receive the response. Applications must not append the EoD (CRC) to the payload, it will be automatically calculated. Applications must not send commands that manage the polling loop and initialization (SENSB_REQ, SLOT_MARKER etc). Use getMaxTransceiveLength() to retrieve the maximum number of bytes that can be sent with transceive(byte[]). This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.    ", "parameters": [{"scri": "byte: bytes to send", "name": "data"}]}, {"returns": null, "class": "android.opengl.GLES32.DebugProc\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.opengl.GLES32.DebugProc\n", "type": "void", "name": "connect", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.  ", "parameters": null}, {"returns": [{"scri": "timeout value in milliseconds", "type": "int"}], "class": "android.opengl.GLES32.DebugProc\n", "type": "int", "name": "getTimeout", "throws": null, "funcname": "int getTimeout ()", "descri": "  Get the current transceive(byte[]) timeout in milliseconds. Requires the NFC permission. ", "parameters": null}, {"returns": null, "class": "android.opengl.GLES32.DebugProc\n", "type": "void", "name": "setTimeout", "throws": null, "funcname": "void setTimeout (int timeout)", "descri": "  Set the transceive(byte[]) timeout in milliseconds. The timeout only applies to transceive(byte[]) on this object, and is reset to a default value when close() is called. Setting a longer timeout may be useful when performing transactions that require a long processing time on the tag such as key generation. Requires the NFC permission. ", "parameters": [{"scri": "int: timeout value in milliseconds", "name": "timeout"}]}, {"returns": [{"scri": "bytes received in response", "type": "byte[]"}], "class": "android.opengl.GLES32.DebugProc\n", "type": "byte[]", "name": "transceive", "throws": [{"scri": "if the tag leaves the field", "type": ""}, {"scri": "if there is an I/O failure, or this operation is canceled", "type": "IOException"}], "funcname": "byte[] transceive (byte[] data)", "descri": "  Send raw NFC-F commands to the tag and receive the response. Applications must not prefix the SoD (preamble and sync code) and/or append the EoD (CRC) to the payload, it will be automatically calculated. A typical NFC-F frame for this method looks like: LENGTH (1 byte) --- CMD (1 byte) -- IDm (8 bytes) -- PARAMS (LENGTH - 10 bytes)  Use getMaxTransceiveLength() to retrieve the maximum amount of bytes that can be sent with transceive(byte[]). This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.    ", "parameters": [{"scri": "byte: bytes to send", "name": "data"}]}, {"returns": null, "class": "android.opengl.GLSurfaceView.EGLConfigChooser\n", "type": "void", "name": "close", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void close ()", "descri": "  Disable I/O operations to the tag from this TagTechnology object, and release resources. Also causes all blocked I/O operations on other thread to be canceled and return with IOException. Requires the NFC permission.  ", "parameters": null}, {"returns": null, "class": "android.opengl.GLSurfaceView.EGLConfigChooser\n", "type": "void", "name": "connect", "throws": [{"scri": "", "type": "IOException"}], "funcname": "void connect ()", "descri": "  Enable I/O operations to the tag from this TagTechnology object. May cause RF activity and may block. Must not be called from the main application thread. A blocked call will be canceled with IOException by calling close() from another thread. Only one TagTechnology object can be connected to a Tag at a time. Applications must call close() when I/O operations are complete. Requires the NFC permission.  ", "parameters": null}, {"returns": [{"scri": "bytes received in response", "type": "byte[]"}], "class": "android.opengl.GLSurfaceView.EGLConfigChooser\n", "type": "byte[]", "name": "transceive", "throws": [{"scri": "if the tag leaves the field", "type": ""}, {"scri": "if there is an I/O failure, or this operation is canceled", "type": "IOException"}], "funcname": "byte[] transceive (byte[] data)", "descri": "  Send raw NFC-V commands to the tag and receive the response. Applications must not append the CRC to the payload, it will be automatically calculated. The application does provide FLAGS, CMD and PARAMETER bytes. Use getMaxTransceiveLength() to retrieve the maximum amount of bytes that can be sent with transceive(byte[]). This is an I/O operation and will block until complete. It must not be called from the main application thread. A blocked call will be canceled with IOException if close() is called from another thread. Requires the NFC permission.    ", "parameters": [{"scri": "byte: bytes to send", "name": "data"}]}, {"returns": null, "class": "android.os.DropBoxManager\n", "type": "static\n        \n        \n        void", "name": "getMemoryInfo", "throws": null, "funcname": "void getMemoryInfo (Debug.MemoryInfo memoryInfo)", "descri": "  Retrieves information about this processes memory usages. This information is broken down by how much is in use by dalvik, the native heap, and everything else. Note: this method directly retrieves memory information for the given process from low-level data available to it.  It may not be able to retrieve information about some protected allocations, such as graphics.  If you want to be sure you can see all information about allocations by the process, use getProcessMemoryInfo(int[]) instead. ", "parameters": [{"scri": "Debug.MemoryInfo", "name": "memoryInfo"}]}, {"returns": null, "class": "android.os.DropBoxManager\n", "type": "static\n        \n        \n        void", "name": "resetAllCounts", "throws": null, "funcname": "void resetAllCounts ()", "descri": "   This method was deprecated      in API level 23.    Accurate counting is a burden on the runtime and may be removed.  Clears all the global and thread-local memory allocation counters.  See also: startAllocCounting()", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.os.DropBoxManager\n", "type": "static\n        \n        \n        int", "name": "setAllocationLimit", "throws": null, "funcname": "int setAllocationLimit (int limit)", "descri": "   This method was deprecated      in API level 11.    This method is now obsolete.  Establish an object allocation limit in the current thread. This feature was never enabled in release builds.  The allocation limits feature was removed in Honeycomb.  This method exists for compatibility and always returns -1 and has no effect.  ", "parameters": [{"scri": "int", "name": "limit"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.os.DropBoxManager\n", "type": "static\n        \n        \n        int", "name": "setGlobalAllocationLimit", "throws": null, "funcname": "int setGlobalAllocationLimit (int limit)", "descri": "   This method was deprecated      in API level 11.    This method is now obsolete.  Establish a global object allocation limit.  This feature was never enabled in release builds.  The allocation limits feature was removed in Honeycomb.  This method exists for compatibility and always returns -1 and has no effect.  ", "parameters": [{"scri": "int", "name": "limit"}]}, {"returns": null, "class": "android.os.DropBoxManager\n", "type": "static\n        \n        \n        void", "name": "startAllocCounting", "throws": null, "funcname": "void startAllocCounting ()", "descri": "   This method was deprecated      in API level 18.    Accurate counting is a burden on the runtime and may be removed.  Start counting the number and aggregate size of memory allocations. The start method resets the counts and enables counting. The stop method disables the counting so that the analysis code doesn't cause additional allocations.  The various get methods return the specified value. And the various reset methods reset the specified count.  Counts are kept for the system as a whole (global) and for each thread. The per-thread counts for threads other than the current thread are not cleared by the \"reset\" or \"start\" calls.", "parameters": null}, {"returns": null, "class": "android.os.DropBoxManager\n", "type": "static\n        \n        \n        void", "name": "startMethodTracingSampling", "throws": null, "funcname": "void startMethodTracingSampling (String tracePath,                 int bufferSize,                 int intervalUs)", "descri": "  Start sampling-based method tracing, specifying the trace log file name, the buffer size, and the sampling interval. When a relative file path is given, the trace file will be placed under your package-specific directory on primary shared/external storage, as returned by getExternalFilesDir(String). See Inspect Trace Logs with Traceview for information about reading trace files. ", "parameters": [{"scri": "String: Path to the trace log file to create. If null,            this will default to \"dmtrace.trace\". If the file already            exists, it will be truncated. If the path given does not end            in \".trace\", it will be appended for you.", "name": "tracePath"}, {"scri": "int: The maximum amount of trace data we gather. If not            given, it defaults to 8MB.", "name": "bufferSize"}, {"scri": "int: The amount of time between each sample in microseconds.", "name": "intervalUs"}]}, {"returns": null, "class": "android.os.DropBoxManager\n", "type": "static\n        \n        \n        void", "name": "stopAllocCounting", "throws": null, "funcname": "void stopAllocCounting ()", "descri": "   This method was deprecated      in API level 18.    Accurate counting is a burden on the runtime and may be removed.  Stop counting the number and aggregate size of memory allocations.", "parameters": null}, {"returns": null, "class": "android.os.strictmode.CustomViolation\n", "type": "void", "name": "allocateBytes", "throws": [{"scri": "when the storage device isn't present, or when it             doesn't support allocating space, or if the device had             trouble allocating the requested space.", "type": "IOException"}], "funcname": "void allocateBytes (FileDescriptor fd,                 long bytes)", "descri": "  Allocate the requested number of bytes for your application to use in the given open file. This will cause the system to delete any cached files necessary to satisfy your request. Attempts to allocate disk space beyond the value returned by getAllocatableBytes(UUID) will fail. This method guarantees that bytes have been allocated to the opened file, otherwise it will throw if fast allocation is not possible. Fast allocation is typically only supported in private app data directories, and on shared/external storage devices which are emulated. If you're progressively allocating an unbounded amount of storage space (such as when recording a video) you should avoid calling this method more than once every 60 seconds. This method may take several seconds to complete, so it should            only be called from a worker thread.    See also: ERROR(/#getAllocatableBytes(UUID, int))isAllocationSupported(FileDescriptor)isExternalStorageEmulated(File)", "parameters": [{"scri": "FileDescriptor: the open file that you'd like to allocate disk space for.", "name": "fd"}, {"scri": "long: the number of bytes to allocate. This is the desired final            size of the open file. If the open file is smaller than this            requested size, it will be extended without modifying any            existing contents. If the open file is larger than this            requested size, it will be truncated.Value is a non-negative number of bytes.", "name": "bytes"}]}, {"returns": [{"scri": "the maximum number of new bytes that the calling app can allocate         using allocateBytes(UUID, long) or         allocateBytes(FileDescriptor, long).Value is a non-negative number of bytes.", "type": "long"}], "class": "android.os.strictmode.CustomViolation\n", "type": "long", "name": "getAllocatableBytes", "throws": [{"scri": "when the storage device isn't present, or when it             doesn't support allocating space.", "type": "IOException"}], "funcname": "long getAllocatableBytes (UUID storageUuid)", "descri": "  Return the maximum number of new bytes that your app can allocate for itself on the given storage volume. This value is typically larger than getUsableSpace(), since the system may be willing to delete cached files to satisfy an allocation request. You can then allocate space for yourself using allocateBytes(UUID, long) or allocateBytes(FileDescriptor, long). This method is best used as a pre-flight check, such as deciding if there is enough space to store an entire music album before you allocate space for each audio file in the album. Attempts to allocate disk space beyond the returned value will fail. If the returned value is not large enough for the data you'd like to persist, you can launch ACTION_MANAGE_STORAGE with the EXTRA_UUID and EXTRA_REQUESTED_BYTES options to help involve the user in freeing up disk space. If you're progressively allocating an unbounded amount of storage space (such as when recording a video) you should avoid calling this method more than once every 30 seconds. Note: if your app uses the android:sharedUserId manifest feature, then allocatable space for all packages in your shared UID is tracked together as a single unit. This method may take several seconds to complete, so it should            only be called from a worker thread. Value is a non-negative number of bytes.    ", "parameters": [{"scri": "UUID: the UUID of the storage volume where you're            considering allocating disk space, since allocatable space can            vary widely depending on the underlying storage device. The            UUID for a specific path can be obtained using            getUuidForPath(File).This value must never be null.", "name": "storageUuid"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.os.strictmode.CustomViolation\n", "type": "boolean", "name": "isAllocationSupported", "throws": null, "funcname": "boolean isAllocationSupported (FileDescriptor fd)", "descri": "  Test if the given file descriptor supports allocation of disk space using allocateBytes(FileDescriptor, long).  ", "parameters": [{"scri": "FileDescriptor This value must never be null.", "name": "fd"}]}, {"returns": null, "class": "android.os.Vibrator\n", "type": "static\n        \n        \n        UserHandle", "name": "UserHandle", "throws": null, "funcname": "UserHandle (Parcel in)", "descri": "  Instantiate a new UserHandle from the data in a Parcel that was previously written with writeToParcel(Parcel, int).  Note that you must not use this with data written by writeToParcel(UserHandle, Parcel) since it is not possible to handle a null UserHandle here. ", "parameters": [{"scri": "Parcel: The Parcel containing the previously written UserHandle, positioned at the location in the buffer where it was written.", "name": "in"}]}, {"returns": null, "class": "android.os.Vibrator\n", "name": "UserHandle", "throws": null, "funcname": "UserHandle (Parcel in)", "parameters": [{"scri": "Parcel: The Parcel containing the previously written UserHandle, positioned at the location in the buffer where it was written.", "name": "in"}], "descri": "  Instantiate a new UserHandle from the data in a Parcel that was previously written with writeToParcel(Parcel, int).  Note that you must not use this with data written by writeToParcel(UserHandle, Parcel) since it is not possible to handle a null UserHandle here. "}, {"returns": null, "class": "android.os.Vibrator\n", "name": "UserHandle", "throws": null, "funcname": "UserHandle (Parcel in)", "parameters": [{"scri": "Parcel: The Parcel containing the previously written UserHandle, positioned at the location in the buffer where it was written.", "name": "in"}], "descri": "  Instantiate a new UserHandle from the data in a Parcel that was previously written with writeToParcel(Parcel, int).  Note that you must not use this with data written by writeToParcel(UserHandle, Parcel) since it is not possible to handle a null UserHandle here. "}, {"returns": [{"scri": "A Parcelable object containing the current dynamic state of this Preference, or         null if there is nothing interesting to save. The default implementation         returns null.", "type": "Parcelable"}], "class": "android.preference.Preference.BaseSavedState\n", "type": "Parcelable", "name": "onSaveInstanceState", "throws": null, "funcname": "Parcelable onSaveInstanceState ()", "descri": "  Hook allowing a Preference to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can be reconstructed later. ", "parameters": null}, {"returns": [{"scri": "A Parcelable object containing the current dynamic state of this Preference, or         null if there is nothing interesting to save. The default implementation         returns null.", "type": "Parcelable"}], "class": "android.preference.PreferenceActivity.Header\n", "type": "Parcelable", "name": "onSaveInstanceState", "throws": null, "funcname": "Parcelable onSaveInstanceState ()", "descri": "  Hook allowing a Preference to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can be reconstructed later. ", "parameters": null}, {"returns": [{"scri": "A Parcelable object containing the current dynamic state of this Preference, or         null if there is nothing interesting to save. The default implementation         returns null.", "type": "Parcelable"}], "class": "android.preference.PreferenceCategory\n", "type": "Parcelable", "name": "onSaveInstanceState", "throws": null, "funcname": "Parcelable onSaveInstanceState ()", "descri": "  Hook allowing a Preference to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can be reconstructed later.   See also: onRestoreInstanceState(Parcelable)saveHierarchyState(Bundle)", "parameters": null}, {"returns": null, "class": "android.preference.RingtonePreference\n", "type": "void", "name": "onSaveInstanceState", "throws": null, "funcname": "void onSaveInstanceState (Bundle outState)", "descri": "  Called to ask the fragment to save its current dynamic state, so it can later be reconstructed in a new instance of its process is restarted.  If a new instance of the fragment later needs to be created, the data you place in the Bundle here will be available in the Bundle given to onCreate(Bundle), onCreateView(LayoutInflater, ViewGroup, Bundle), and onActivityCreated(Bundle). This corresponds to Activity.onSaveInstanceState(Bundle) and most of the discussion there applies here as well.  Note however: this method may be called at any time before onDestroy().  There are many situations where a fragment may be mostly torn down (such as when placed on the back stack with no UI showing), but its state will not be saved until its owning activity actually needs to save its state. ", "parameters": [{"scri": "Bundle: Bundle in which to place your saved state.", "name": "outState"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.preference.TwoStatePreference\n", "type": "boolean", "name": "isStorageDefault", "throws": null, "funcname": "boolean isStorageDefault ()", "descri": "  Indicates if the storage location used internally by this class is the default provided by the hosting Context.   See also: setStorageDefault()setStorageDeviceProtected()", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.preference.TwoStatePreference\n", "type": "boolean", "name": "isStorageDeviceProtected", "throws": null, "funcname": "boolean isStorageDeviceProtected ()", "descri": "  Indicates if the storage location used internally by this class is backed by device-protected storage.   See also: setStorageDefault()setStorageDeviceProtected()", "parameters": null}, {"returns": null, "class": "android.preference.TwoStatePreference\n", "type": "void", "name": "setStorageDefault", "throws": null, "funcname": "void setStorageDefault ()", "descri": "  Sets the storage location used internally by this class to be the default provided by the hosting Context.", "parameters": null}, {"returns": null, "class": "android.preference.TwoStatePreference\n", "type": "void", "name": "setStorageDeviceProtected", "throws": null, "funcname": "void setStorageDeviceProtected ()", "descri": "  Explicitly set the storage location used internally by this class to be device-protected storage. On devices with direct boot, data stored in this location is encrypted with a key tied to the physical device, and it can be accessed immediately after the device has booted successfully, both before and after the user has authenticated with their credentials (such as a lock pattern or PIN). Because device-protected data is available without user authentication, you should carefully limit the data you store using this Context. For example, storing sensitive authentication tokens or passwords in the device-protected area is strongly discouraged.  See also: createDeviceProtectedStorageContext()", "parameters": null}, {"returns": [{"scri": "A Parcelable object containing the current dynamic state of this Preference, or         null if there is nothing interesting to save. The default implementation         returns null.", "type": "Parcelable"}], "class": "android.print.PageRange\n", "type": "Parcelable", "name": "onSaveInstanceState", "throws": null, "funcname": "Parcelable onSaveInstanceState ()", "descri": "  Hook allowing a Preference to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can be reconstructed later. ", "parameters": null}, {"returns": null, "class": "android.provider.Contacts.Intents\n", "type": "void", "name": "addPostalLocation", "throws": null, "funcname": "void addPostalLocation (Context context,                 long postalId,                 double latitude,                 double longitude)", "descri": "   This method was deprecated      in API level 5.    see ContactsContract  Add a longitude and latitude location to a postal address. ", "parameters": [{"scri": "Context: the context to use when updating the database", "name": "context"}, {"scri": "long: the address to update", "name": "postalId"}, {"scri": "double: the latitude for the address", "name": "latitude"}, {"scri": "double: the longitude for the address", "name": "longitude"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.provider.ContactsContract.Contacts.Entity\n", "type": "static\n        \n        \n        boolean", "name": "isEnterpriseContactId", "throws": null, "funcname": "boolean isEnterpriseContactId (long contactId)", "descri": "  Return TRUE if a contact ID is from the contacts provider on the enterprise profile. ENTERPRISE_CONTENT_FILTER_URI may return such a contact.  ", "parameters": [{"scri": "long", "name": "contactId"}]}, {"returns": null, "class": "android.provider.ContactsContract.RawContacts.DisplayPhoto\n", "type": "static\n        \n        \n        void", "name": "showQuickContact", "throws": null, "funcname": "void showQuickContact (Context context,                 View target,                 Uri lookupUri,                 String[] excludeMimes,                 String prioritizedMimeType)", "descri": "  Trigger a dialog that lists the various methods of interacting with the requested Contacts entry. This may be based on available ContactsContract.Data rows under that contact, and may also include social status and presence details. ", "parameters": [{"scri": "Context: The parent Context that may be used as the            parent for this dialog.", "name": "context"}, {"scri": "View: Specific View from your layout that this dialog            should be centered around. In particular, if the dialog            has a \"callout\" arrow, it will be pointed and centered            around this View.", "name": "target"}, {"scri": "Uri: A            CONTENT_LOOKUP_URI style            Uri that describes a specific contact to feature            in this dialog. A work lookup uri is supported here,            see ENTERPRISE_CONTENT_LOOKUP_URI and            ENTERPRISE_CONTENT_FILTER_URI.", "name": "lookupUri"}, {"scri": "String: Optional list of MIMETYPE MIME-types            to exclude when showing this dialog. For example, when            already viewing the contact details card, this can be used            to omit the details entry from the dialog.", "name": "excludeMimes"}, {"scri": "String: This mimetype should be prioritized in the QuickContacts UI.             For example, passing the value             CONTENT_ITEM_TYPE can cause phone numbers to be             displayed more prominently in QuickContacts.", "name": "prioritizedMimeType"}]}, {"returns": null, "class": "android.provider.ContactsContract.RawContacts.DisplayPhoto\n", "type": "static\n        \n        \n        void", "name": "showQuickContact", "throws": null, "funcname": "void showQuickContact (Context context,                 Rect target,                 Uri lookupUri,                 String[] excludeMimes,                 String prioritizedMimeType)", "descri": "  Trigger a dialog that lists the various methods of interacting with the requested Contacts entry. This may be based on available ContactsContract.Data rows under that contact, and may also include social status and presence details. ", "parameters": [{"scri": "Context: The parent Context that may be used as the            parent for this dialog.", "name": "context"}, {"scri": "Rect: Specific Rect that this dialog should be            centered around, in screen coordinates. In particular, if            the dialog has a \"callout\" arrow, it will be pointed and            centered around this Rect. If you are running at a            non-native density, you need to manually adjust using            density before calling.", "name": "target"}, {"scri": "Uri: A            CONTENT_LOOKUP_URI style            Uri that describes a specific contact to feature            in this dialog. A work lookup uri is supported here,            see ENTERPRISE_CONTENT_LOOKUP_URI and            ENTERPRISE_CONTENT_FILTER_URI.", "name": "lookupUri"}, {"scri": "String: Optional list of MIMETYPE MIME-types            to exclude when showing this dialog. For example, when            already viewing the contact details card, this can be used            to omit the details entry from the dialog.", "name": "excludeMimes"}, {"scri": "String: This mimetype should be prioritized in the QuickContacts UI.             For example, passing the value             CONTENT_ITEM_TYPE can cause phone numbers to be             displayed more prominently in QuickContacts.", "name": "prioritizedMimeType"}]}, {"returns": [{"scri": "true on success", "type": "boolean"}], "class": "android.provider.Settings\n", "type": "static\n        \n        \n        boolean", "name": "moveItem", "throws": null, "funcname": "boolean moveItem (ContentResolver res,                 long playlistId,                 int from,                 int to)", "descri": "  Convenience method to move a playlist item to a new location  ", "parameters": [{"scri": "ContentResolver: The content resolver to use", "name": "res"}, {"scri": "long: The numeric id of the playlist", "name": "playlistId"}, {"scri": "int: The position of the item to move", "name": "from"}, {"scri": "int: The position to move the item to", "name": "to"}]}, {"returns": [{"scri": "", "type": "long"}], "class": "android.provider.VoicemailContract\n", "type": "static\n        \n        \n        long", "name": "getOrCreateThreadId", "throws": null, "funcname": "long getOrCreateThreadId (Context context,                 String recipient)", "descri": "  This is a single-recipient version of getOrCreateThreadId. It's convenient for use with SMS messages.  ", "parameters": [{"scri": "Context: the context object to use.", "name": "context"}, {"scri": "String: the recipient to send to.", "name": "recipient"}]}, {"returns": null, "class": "android.renderscript.Byte2\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onBufferAvailable", "throws": null, "funcname": "void onBufferAvailable (Allocation a)", "descri": "   ", "parameters": [{"scri": "Allocation", "name": "a"}]}, {"returns": [{"scri": "int", "type": "int"}], "class": "android.renderscript.Element.DataType\n", "type": "int", "name": "getY", "throws": null, "funcname": "int getY ()", "descri": "  Return the value of the Y dimension or 0 for a 1D allocation. ", "parameters": null}, {"returns": [{"scri": "int", "type": "int"}], "class": "android.renderscript.Element.DataType\n", "type": "int", "name": "getZ", "throws": null, "funcname": "int getZ ()", "descri": "  Return the value of the Z dimension or 0 for a 1D or 2D allocation. ", "parameters": null}, {"returns": [{"scri": "offset in bytes of sub-element in this element at given index", "type": "int"}], "class": "android.renderscript.Float2\n", "type": "int", "name": "getSubElementOffsetBytes", "throws": null, "funcname": "int getSubElementOffsetBytes (int index)", "descri": "  This function specifies the location of a sub-element within the element  ", "parameters": [{"scri": "int: index of the sub-element", "name": "index"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadFrustum", "throws": null, "funcname": "void loadFrustum (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Sets current values to be a perspective projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane, must be positive", "name": "n"}, {"scri": "float: location of the far clipping plane, must be positive", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadFrustum", "throws": null, "funcname": "void loadFrustum (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Sets current values to be a perspective projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane, must be positive", "name": "n"}, {"scri": "float: location of the far clipping plane, must be positive", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadFrustum", "throws": null, "funcname": "void loadFrustum (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Sets current values to be a perspective projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane, must be positive", "name": "n"}, {"scri": "float: location of the far clipping plane, must be positive", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadFrustum", "throws": null, "funcname": "void loadFrustum (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Sets current values to be a perspective projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane, must be positive", "name": "n"}, {"scri": "float: location of the far clipping plane, must be positive", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadFrustum", "throws": null, "funcname": "void loadFrustum (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Sets current values to be a perspective projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane, must be positive", "name": "n"}, {"scri": "float: location of the far clipping plane, must be positive", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadFrustum", "throws": null, "funcname": "void loadFrustum (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Sets current values to be a perspective projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane, must be positive", "name": "n"}, {"scri": "float: location of the far clipping plane, must be positive", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadOrtho", "throws": null, "funcname": "void loadOrtho (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Set current values to be an orthographic projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane", "name": "n"}, {"scri": "float: location of the far clipping plane", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadOrtho", "throws": null, "funcname": "void loadOrtho (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Set current values to be an orthographic projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane", "name": "n"}, {"scri": "float: location of the far clipping plane", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadOrtho", "throws": null, "funcname": "void loadOrtho (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Set current values to be an orthographic projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane", "name": "n"}, {"scri": "float: location of the far clipping plane", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadOrtho", "throws": null, "funcname": "void loadOrtho (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Set current values to be an orthographic projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane", "name": "n"}, {"scri": "float: location of the far clipping plane", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadOrtho", "throws": null, "funcname": "void loadOrtho (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Set current values to be an orthographic projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane", "name": "n"}, {"scri": "float: location of the far clipping plane", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadOrtho", "throws": null, "funcname": "void loadOrtho (float l,                 float r,                 float b,                 float t,                 float n,                 float f)", "descri": "  Set current values to be an orthographic projection matrix ", "parameters": [{"scri": "float: location of the left vertical clipping plane", "name": "l"}, {"scri": "float: location of the right vertical clipping plane", "name": "r"}, {"scri": "float: location of the bottom horizontal clipping plane", "name": "b"}, {"scri": "float: location of the top horizontal clipping plane", "name": "t"}, {"scri": "float: location of the near clipping plane", "name": "n"}, {"scri": "float: location of the far clipping plane", "name": "f"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadOrthoWindow", "throws": null, "funcname": "void loadOrthoWindow (int w,                 int h)", "descri": "  Set current values to be an orthographic projection matrix with the right and bottom clipping planes set to the given values. Left and top clipping planes are set to 0. Near and far are set to -1, 1 respectively ", "parameters": [{"scri": "int: location of the right vertical clipping plane", "name": "w"}, {"scri": "int: location of the bottom horizontal clipping plane", "name": "h"}]}, {"returns": null, "class": "android.renderscript.Script\n", "type": "void", "name": "loadOrthoWindow", "throws": null, "funcname": "void loadOrthoWindow (int w,                 int h)", "descri": "  Set current values to be an orthographic projection matrix with the right and bottom clipping planes set to the given values. Left and top clipping planes are set to 0. Near and far are set to -1, 1 respectively ", "parameters": [{"scri": "int: location of the right vertical clipping plane", "name": "w"}, {"scri": "int: location of the bottom horizontal clipping plane", "name": "h"}]}, {"returns": null, "class": "android.renderscript.ScriptGroup.Closure\n", "type": "void", "name": "setInput", "throws": null, "funcname": "void setInput (Script.KernelID s,                 Allocation a)", "descri": "   This method was deprecated      in API level 23.    Set arguments to execute(Object) instead.  Sets an input of the ScriptGroup. This specifies an Allocation to be used for kernels that require an input Allocation provided from outside of the ScriptGroup. ", "parameters": [{"scri": "Script.KernelID: The ID of the kernel where the allocation should be          connected.", "name": "s"}, {"scri": "Allocation: The allocation to connect.", "name": "a"}]}, {"returns": null, "class": "android.renderscript.ScriptGroup.Closure\n", "type": "void", "name": "setInput", "throws": null, "funcname": "void setInput (Script.KernelID s,                 Allocation a)", "descri": "   This method was deprecated      in API level 23.    Set arguments to execute(Object) instead.  Sets an input of the ScriptGroup. This specifies an Allocation to be used for kernels that require an input Allocation provided from outside of the ScriptGroup. ", "parameters": [{"scri": "Script.KernelID: The ID of the kernel where the allocation should be          connected.", "name": "s"}, {"scri": "Allocation: The allocation to connect.", "name": "a"}]}, {"returns": null, "class": "android.renderscript.ScriptGroup.Closure\n", "type": "void", "name": "setOutput", "throws": null, "funcname": "void setOutput (Script.KernelID s,                 Allocation a)", "descri": "   This method was deprecated      in API level 23.    Use return value of execute(Object) instead.  Sets an output of the ScriptGroup. This specifies an Allocation to be used for the kernels that require an output Allocation visible after the ScriptGroup is executed. ", "parameters": [{"scri": "Script.KernelID: The ID of the kernel where the allocation should be          connected.", "name": "s"}, {"scri": "Allocation: The allocation to connect.", "name": "a"}]}, {"returns": null, "class": "android.renderscript.ScriptGroup.Closure\n", "type": "void", "name": "setOutput", "throws": null, "funcname": "void setOutput (Script.KernelID s,                 Allocation a)", "descri": "   This method was deprecated      in API level 23.    Use return value of execute(Object) instead.  Sets an output of the ScriptGroup. This specifies an Allocation to be used for the kernels that require an output Allocation visible after the ScriptGroup is executed. ", "parameters": [{"scri": "Script.KernelID: The ID of the kernel where the allocation should be          connected.", "name": "s"}, {"scri": "Allocation: The allocation to connect.", "name": "a"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve3x3\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation ain,                 Allocation aout)", "descri": "  Invoke the kernel and apply the lookup to each cell of ain and copy to aout. ", "parameters": [{"scri": "Allocation: Input allocation", "name": "ain"}, {"scri": "Allocation: Output allocation", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve3x3\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation ain,                 Allocation aout)", "descri": "  Invoke the kernel and apply the lookup to each cell of ain and copy to aout. ", "parameters": [{"scri": "Allocation: Input allocation", "name": "ain"}, {"scri": "Allocation: Output allocation", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve3x3\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Invoke the kernel and apply the lookup to each cell of ain and copy to aout. ", "parameters": [{"scri": "Allocation: Input allocation", "name": "ain"}, {"scri": "Allocation: Output allocation", "name": "aout"}, {"scri": "Script.LaunchOptions: Launch options for kernel", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve3x3\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Invoke the kernel and apply the lookup to each cell of ain and copy to aout. ", "parameters": [{"scri": "Allocation: Input allocation", "name": "ain"}, {"scri": "Allocation: Output allocation", "name": "aout"}, {"scri": "Script.LaunchOptions: Launch options for kernel", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve3x3\n", "type": "void", "name": "setLUT", "throws": null, "funcname": "void setLUT (Allocation lut)", "descri": "  Sets the Allocation to be used as the lookup table. The lookup table must use the same Element as the intrinsic. ", "parameters": [{"scri": "Allocation", "name": "lut"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachAdd", "throws": null, "funcname": "void forEachAdd (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = min(src + dst, 1.0) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachAdd", "throws": null, "funcname": "void forEachAdd (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = min(src + dst, 1.0) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachAdd", "throws": null, "funcname": "void forEachAdd (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = min(src + dst, 1.0) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachAdd", "throws": null, "funcname": "void forEachAdd (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = min(src + dst, 1.0) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachClear", "throws": null, "funcname": "void forEachClear (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = {0, 0, 0, 0} ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachClear", "throws": null, "funcname": "void forEachClear (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = {0, 0, 0, 0} ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachClear", "throws": null, "funcname": "void forEachClear (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = {0, 0, 0, 0} ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachClear", "throws": null, "funcname": "void forEachClear (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = {0, 0, 0, 0} ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDst", "throws": null, "funcname": "void forEachDst (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = dst This is a NOP. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDst", "throws": null, "funcname": "void forEachDst (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = dst This is a NOP. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDst", "throws": null, "funcname": "void forEachDst (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = dst This is a NOP. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDst", "throws": null, "funcname": "void forEachDst (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = dst This is a NOP. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstAtop", "throws": null, "funcname": "void forEachDstAtop (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  dst = dst.rgb * src.a + (1.0 - dst.a) * src.rgb dst.a = src.a Note: Before API 23, the alpha channel was not correctly set.       Please use with caution when targeting older APIs. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstAtop", "throws": null, "funcname": "void forEachDstAtop (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  dst = dst.rgb * src.a + (1.0 - dst.a) * src.rgb dst.a = src.a Note: Before API 23, the alpha channel was not correctly set.       Please use with caution when targeting older APIs. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstAtop", "throws": null, "funcname": "void forEachDstAtop (Allocation ain,                 Allocation aout)", "descri": "  dst = dst.rgb * src.a + (1.0 - dst.a) * src.rgb dst.a = src.a Note: Before API 23, the alpha channel was not correctly set.       Please use with caution when targeting older APIs. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstAtop", "throws": null, "funcname": "void forEachDstAtop (Allocation ain,                 Allocation aout)", "descri": "  dst = dst.rgb * src.a + (1.0 - dst.a) * src.rgb dst.a = src.a Note: Before API 23, the alpha channel was not correctly set.       Please use with caution when targeting older APIs. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstIn", "throws": null, "funcname": "void forEachDstIn (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = dst * src.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstIn", "throws": null, "funcname": "void forEachDstIn (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = dst * src.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstIn", "throws": null, "funcname": "void forEachDstIn (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = dst * src.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstIn", "throws": null, "funcname": "void forEachDstIn (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = dst * src.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstOut", "throws": null, "funcname": "void forEachDstOut (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = dst * (1.0 - src.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstOut", "throws": null, "funcname": "void forEachDstOut (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = dst * (1.0 - src.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstOut", "throws": null, "funcname": "void forEachDstOut (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = dst * (1.0 - src.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstOut", "throws": null, "funcname": "void forEachDstOut (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = dst * (1.0 - src.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstOver", "throws": null, "funcname": "void forEachDstOver (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = dst + src * (1.0 - dst.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstOver", "throws": null, "funcname": "void forEachDstOver (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = dst + src * (1.0 - dst.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstOver", "throws": null, "funcname": "void forEachDstOver (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = dst + src * (1.0 - dst.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachDstOver", "throws": null, "funcname": "void forEachDstOver (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = dst + src * (1.0 - dst.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachMultiply", "throws": null, "funcname": "void forEachMultiply (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src * dst ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachMultiply", "throws": null, "funcname": "void forEachMultiply (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src * dst ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachMultiply", "throws": null, "funcname": "void forEachMultiply (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src * dst ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachMultiply", "throws": null, "funcname": "void forEachMultiply (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src * dst ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrc", "throws": null, "funcname": "void forEachSrc (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrc", "throws": null, "funcname": "void forEachSrc (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrc", "throws": null, "funcname": "void forEachSrc (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrc", "throws": null, "funcname": "void forEachSrc (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcAtop", "throws": null, "funcname": "void forEachSrcAtop (Allocation ain,                 Allocation aout)", "descri": "  dst.rgb = src.rgb * dst.a + (1.0 - src.a) * dst.rgb dst.a = dst.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcAtop", "throws": null, "funcname": "void forEachSrcAtop (Allocation ain,                 Allocation aout)", "descri": "  dst.rgb = src.rgb * dst.a + (1.0 - src.a) * dst.rgb dst.a = dst.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcAtop", "throws": null, "funcname": "void forEachSrcAtop (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  dst.rgb = src.rgb * dst.a + (1.0 - src.a) * dst.rgb dst.a = dst.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcAtop", "throws": null, "funcname": "void forEachSrcAtop (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  dst.rgb = src.rgb * dst.a + (1.0 - src.a) * dst.rgb dst.a = dst.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcIn", "throws": null, "funcname": "void forEachSrcIn (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src * dst.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcIn", "throws": null, "funcname": "void forEachSrcIn (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src * dst.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcIn", "throws": null, "funcname": "void forEachSrcIn (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src * dst.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcIn", "throws": null, "funcname": "void forEachSrcIn (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src * dst.a ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcOut", "throws": null, "funcname": "void forEachSrcOut (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src * (1.0 - dst.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcOut", "throws": null, "funcname": "void forEachSrcOut (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src * (1.0 - dst.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcOut", "throws": null, "funcname": "void forEachSrcOut (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src * (1.0 - dst.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcOut", "throws": null, "funcname": "void forEachSrcOut (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src * (1.0 - dst.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcOver", "throws": null, "funcname": "void forEachSrcOver (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src + dst * (1.0 - src.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcOver", "throws": null, "funcname": "void forEachSrcOver (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = src + dst * (1.0 - src.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcOver", "throws": null, "funcname": "void forEachSrcOver (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src + dst * (1.0 - src.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSrcOver", "throws": null, "funcname": "void forEachSrcOver (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = src + dst * (1.0 - src.a) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSubtract", "throws": null, "funcname": "void forEachSubtract (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = max(dst - src, 0.0) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSubtract", "throws": null, "funcname": "void forEachSubtract (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = max(dst - src, 0.0) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSubtract", "throws": null, "funcname": "void forEachSubtract (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = max(dst - src, 0.0) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachSubtract", "throws": null, "funcname": "void forEachSubtract (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = max(dst - src, 0.0) ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachXor", "throws": null, "funcname": "void forEachXor (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = {src.r ^ dst.r, src.g ^ dst.g, src.b ^ dst.b, src.a ^ dst.a} ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachXor", "throws": null, "funcname": "void forEachXor (Allocation ain,                 Allocation aout)", "descri": "  Sets dst = {src.r ^ dst.r, src.g ^ dst.g, src.b ^ dst.b, src.a ^ dst.a} ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachXor", "throws": null, "funcname": "void forEachXor (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = {src.r ^ dst.r, src.g ^ dst.g, src.b ^ dst.b, src.a ^ dst.a} Note: this is NOT the Porter/Duff XOR mode; this is a bitwise xor. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicConvolve5x5\n", "type": "void", "name": "forEachXor", "throws": null, "funcname": "void forEachXor (Allocation ain,                 Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Sets dst = {src.r ^ dst.r, src.g ^ dst.g, src.b ^ dst.b, src.a ^ dst.a} Note: this is NOT the Porter/Duff XOR mode; this is a bitwise xor. ", "parameters": [{"scri": "Allocation: The source buffer", "name": "ain"}, {"scri": "Allocation: The destination buffer", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicLUT\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation aout)", "descri": "  Apply the filter to the input and save to the specified allocation. ", "parameters": [{"scri": "Allocation: Output allocation. Must match creation element             type.", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicLUT\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Apply the filter to the input and save to the specified allocation. ", "parameters": [{"scri": "Allocation: Output allocation. Must match creation element             type.", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.ScriptIntrinsicLUT\n", "type": "void", "name": "setInput", "throws": null, "funcname": "void setInput (Allocation ain)", "descri": "  Set the input of the 3x3 convolve. Must match the element type supplied during create. ", "parameters": [{"scri": "Allocation: The input allocation.", "name": "ain"}]}, {"returns": null, "class": "android.renderscript.Short2\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation ain)", "descri": "  Process an input buffer and place the histogram into the output allocation. The output allocation may be a narrower vector size than the input. In this case the vector size of the output is used to determine how many of the input channels are used in the computation. This is useful if you have an RGBA input buffer but only want the histogram for RGB. 1D and 2D input allocations are supported. ", "parameters": [{"scri": "Allocation: The input image", "name": "ain"}]}, {"returns": null, "class": "android.renderscript.Short2\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation ain,                 Script.LaunchOptions opt)", "descri": "  Process an input buffer and place the histogram into the output allocation. The output allocation may be a narrower vector size than the input. In this case the vector size of the output is used to determine how many of the input channels are used in the computation. This is useful if you have an RGBA input buffer but only want the histogram for RGB. 1D and 2D input allocations are supported. ", "parameters": [{"scri": "Allocation: The input image", "name": "ain"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.Short2\n", "type": "void", "name": "forEach_Dot", "throws": null, "funcname": "void forEach_Dot (Allocation ain,                 Script.LaunchOptions opt)", "descri": "  Process an input buffer and place the histogram into the output allocation. The dot product of the input channel and the coefficients from 'setDotCoefficients' are used to calculate the output values. 1D and 2D input allocations are supported. ", "parameters": [{"scri": "Allocation: The input image", "name": "ain"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.Short2\n", "type": "void", "name": "forEach_Dot", "throws": null, "funcname": "void forEach_Dot (Allocation ain)", "descri": "  Process an input buffer and place the histogram into the output allocation. The dot product of the input channel and the coefficients from 'setDotCoefficients' are used to calculate the output values. 1D and 2D input allocations are supported. ", "parameters": [{"scri": "Allocation: The input image", "name": "ain"}]}, {"returns": null, "class": "android.renderscript.Short2\n", "type": "void", "name": "setOutput", "throws": null, "funcname": "void setOutput (Allocation aout)", "descri": "  Set the output of the histogram.  32 bit integer types are supported. ", "parameters": [{"scri": "Allocation: The output allocation", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.Short4\n", "type": "void", "name": "forEach_bicubic", "throws": null, "funcname": "void forEach_bicubic (Allocation aout,                 Script.LaunchOptions opt)", "descri": "  Resize copy the input allocation to the output specified. The Allocation is rescaled if necessary using bi-cubic interpolation. ", "parameters": [{"scri": "Allocation: Output allocation. Element type must match             current input.", "name": "aout"}, {"scri": "Script.LaunchOptions: LaunchOptions for clipping", "name": "opt"}]}, {"returns": null, "class": "android.renderscript.Short4\n", "type": "void", "name": "forEach_bicubic", "throws": null, "funcname": "void forEach_bicubic (Allocation aout)", "descri": "  Resize copy the input allocation to the output specified. The Allocation is rescaled if necessary using bi-cubic interpolation. ", "parameters": [{"scri": "Allocation: Output allocation. Element type must match             current input.  Must not be same as input.", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.Short4\n", "type": "void", "name": "setInput", "throws": null, "funcname": "void setInput (Allocation ain)", "descri": "  Set the input of the resize. Must match the element type supplied during create. ", "parameters": [{"scri": "Allocation: The input allocation.", "name": "ain"}]}, {"returns": null, "class": "android.renderscript.Type\n", "type": "void", "name": "forEach", "throws": null, "funcname": "void forEach (Allocation aout)", "descri": "  Convert the image to RGB. ", "parameters": [{"scri": "Allocation: Output allocation. Must match creation element             type.", "name": "aout"}]}, {"returns": null, "class": "android.renderscript.Type\n", "type": "void", "name": "setInput", "throws": null, "funcname": "void setInput (Allocation ain)", "descri": "  Set the input yuv allocation, must be U8(RenderScript). ", "parameters": [{"scri": "Allocation: The input allocation.", "name": "ain"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.security.keystore.KeyExpiredException\n", "type": "boolean", "name": "isInvalidatedByBiometricEnrollment", "throws": null, "funcname": "boolean isInvalidatedByBiometricEnrollment ()", "descri": "  Returns true if the key is irreversibly invalidated when a new fingerprint is enrolled or all enrolled fingerprints are removed. This has effect only for keys that require fingerprint user authentication for every use.   See also: isUserAuthenticationRequired()getUserAuthenticationValidityDurationSeconds()setInvalidatedByBiometricEnrollment(boolean)", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.security.keystore.KeyProtection\n", "type": "boolean", "name": "isInvalidatedByBiometricEnrollment", "throws": null, "funcname": "boolean isInvalidatedByBiometricEnrollment ()", "descri": "  Returns true if the key is irreversibly invalidated when a new fingerprint is enrolled or all enrolled fingerprints are removed. This has effect only for keys that require fingerprint user authentication for every use.   See also: isUserAuthenticationRequired()getUserAuthenticationValidityDurationSeconds()setInvalidatedByBiometricEnrollment(boolean)", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.security.keystore.KeyProtection.Builder\n", "type": "boolean", "name": "isInvalidatedByBiometricEnrollment", "throws": null, "funcname": "boolean isInvalidatedByBiometricEnrollment ()", "descri": "  Returns true if the key will be invalidated by enrollment of a new fingerprint or removal of all fingerprints. ", "parameters": null}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onDownloadMms", "throws": null, "funcname": "void onDownloadMms (Uri contentUri,                 int subId,                 Uri location,                 ResultCallback<Integer> callback)", "descri": "  Override this method to download MMSs received. ", "parameters": [{"scri": "Uri: the content provider URI of the PDU to be downloaded.This value must never be null.", "name": "contentUri"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "Uri: the URI of the message to be downloaded.This value must never be null.", "name": "location"}, {"scri": "ResultCallback: result callback. Call with a status code which is one of        DOWNLOAD_STATUS_OK,        DOWNLOAD_STATUS_RETRY_ON_CARRIER_NETWORK, or DOWNLOAD_STATUS_ERROR.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onFilterSms", "throws": null, "funcname": "void onFilterSms (MessagePdu pdu,                 String format,                 int destPort,                 int subId,                 ResultCallback<Boolean> callback)", "descri": "   This method was deprecated      in API level 24.    Use onReceiveTextSms(MessagePdu, String, int, int, CarrierMessagingService.ResultCallback) instead.  Override this method to filter inbound SMS messages. ", "parameters": [{"scri": "MessagePdu: the PDUs of the messageThis value must never be null.", "name": "pdu"}, {"scri": "String: the format of the PDUs, typically \"3gpp\" or \"3gpp2\"This value must never be null.", "name": "format"}, {"scri": "int: the destination port of a binary SMS, this will be -1 for text SMS", "name": "destPort"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "ResultCallback: result callback. Call with true to keep an inbound SMS message and        deliver to SMS apps, and false to drop the message.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onFilterSms", "throws": null, "funcname": "void onFilterSms (MessagePdu pdu,                 String format,                 int destPort,                 int subId,                 ResultCallback<Boolean> callback)", "descri": "   This method was deprecated      in API level 24.    Use onReceiveTextSms(MessagePdu, String, int, int, CarrierMessagingService.ResultCallback) instead.  Override this method to filter inbound SMS messages. ", "parameters": [{"scri": "MessagePdu: the PDUs of the messageThis value must never be null.", "name": "pdu"}, {"scri": "String: the format of the PDUs, typically \"3gpp\" or \"3gpp2\"This value must never be null.", "name": "format"}, {"scri": "int: the destination port of a binary SMS, this will be -1 for text SMS", "name": "destPort"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "ResultCallback: result callback. Call with true to keep an inbound SMS message and        deliver to SMS apps, and false to drop the message.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onFilterSms", "throws": null, "funcname": "void onFilterSms (MessagePdu pdu,                 String format,                 int destPort,                 int subId,                 ResultCallback<Boolean> callback)", "descri": "   This method was deprecated      in API level 24.    Use onReceiveTextSms(MessagePdu, String, int, int, CarrierMessagingService.ResultCallback) instead.  Override this method to filter inbound SMS messages. ", "parameters": [{"scri": "MessagePdu: the PDUs of the messageThis value must never be null.", "name": "pdu"}, {"scri": "String: the format of the PDUs, typically \"3gpp\" or \"3gpp2\"This value must never be null.", "name": "format"}, {"scri": "int: the destination port of a binary SMS, this will be -1 for text SMS", "name": "destPort"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "ResultCallback: result callback. Call with true to keep an inbound SMS message and        deliver to SMS apps, and false to drop the message.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onReceiveTextSms", "throws": null, "funcname": "void onReceiveTextSms (MessagePdu pdu,                 String format,                 int destPort,                 int subId,                 ResultCallback<Integer> callback)", "descri": "  Override this method to filter inbound SMS messages. This method will be called once for every incoming text SMS. You can invoke the callback with a bitmask to tell the platform how to handle the SMS. For a SMS received on a file-based encryption capable device while the credential-encrypted storage is not available, this method will be called for the second time when the credential-encrypted storage becomes available after the user unlocks the phone, if the bit RECEIVE_OPTIONS_DROP is not set when invoking the callback. ", "parameters": [{"scri": "MessagePdu: the PDUs of the messageThis value must never be null.", "name": "pdu"}, {"scri": "String: the format of the PDUs, typically \"3gpp\" or \"3gpp2\"This value must never be null.", "name": "format"}, {"scri": "int: the destination port of a binary SMS, this will be -1 for text SMS", "name": "destPort"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "ResultCallback: result callback. Call with a bitmask integer to indicate how the incoming        text SMS should be handled by the platform. Use RECEIVE_OPTIONS_DROP and        RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE        to set the flags in the bitmask.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onReceiveTextSms", "throws": null, "funcname": "void onReceiveTextSms (MessagePdu pdu,                 String format,                 int destPort,                 int subId,                 ResultCallback<Integer> callback)", "descri": "  Override this method to filter inbound SMS messages. This method will be called once for every incoming text SMS. You can invoke the callback with a bitmask to tell the platform how to handle the SMS. For a SMS received on a file-based encryption capable device while the credential-encrypted storage is not available, this method will be called for the second time when the credential-encrypted storage becomes available after the user unlocks the phone, if the bit RECEIVE_OPTIONS_DROP is not set when invoking the callback. ", "parameters": [{"scri": "MessagePdu: the PDUs of the messageThis value must never be null.", "name": "pdu"}, {"scri": "String: the format of the PDUs, typically \"3gpp\" or \"3gpp2\"This value must never be null.", "name": "format"}, {"scri": "int: the destination port of a binary SMS, this will be -1 for text SMS", "name": "destPort"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "ResultCallback: result callback. Call with a bitmask integer to indicate how the incoming        text SMS should be handled by the platform. Use RECEIVE_OPTIONS_DROP and        RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE        to set the flags in the bitmask.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onReceiveTextSms", "throws": null, "funcname": "void onReceiveTextSms (MessagePdu pdu,                 String format,                 int destPort,                 int subId,                 ResultCallback<Integer> callback)", "descri": "  Override this method to filter inbound SMS messages. This method will be called once for every incoming text SMS. You can invoke the callback with a bitmask to tell the platform how to handle the SMS. For a SMS received on a file-based encryption capable device while the credential-encrypted storage is not available, this method will be called for the second time when the credential-encrypted storage becomes available after the user unlocks the phone, if the bit RECEIVE_OPTIONS_DROP is not set when invoking the callback. ", "parameters": [{"scri": "MessagePdu: the PDUs of the messageThis value must never be null.", "name": "pdu"}, {"scri": "String: the format of the PDUs, typically \"3gpp\" or \"3gpp2\"This value must never be null.", "name": "format"}, {"scri": "int: the destination port of a binary SMS, this will be -1 for text SMS", "name": "destPort"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "ResultCallback: result callback. Call with a bitmask integer to indicate how the incoming        text SMS should be handled by the platform. Use RECEIVE_OPTIONS_DROP and        RECEIVE_OPTIONS_SKIP_NOTIFY_WHEN_CREDENTIAL_PROTECTED_STORAGE_UNAVAILABLE        to set the flags in the bitmask.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendDataSms", "throws": null, "funcname": "void onSendDataSms (byte[] data,                 int subId,                 String destAddress,                 int destPort,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "   This method was deprecated      in API level 23.    Override onSendDataSms(byte[], int, String, int, CarrierMessagingService.ResultCallback) below instead.  Override this method to intercept binary SMSs sent from the device. ", "parameters": [{"scri": "byte: the binary contentThis value must never be null.", "name": "data"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: the destination port", "name": "destPort"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendDataSms", "throws": null, "funcname": "void onSendDataSms (byte[] data,                 int subId,                 String destAddress,                 int destPort,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "   This method was deprecated      in API level 23.    Override onSendDataSms(byte[], int, String, int, CarrierMessagingService.ResultCallback) below instead.  Override this method to intercept binary SMSs sent from the device. ", "parameters": [{"scri": "byte: the binary contentThis value must never be null.", "name": "data"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: the destination port", "name": "destPort"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendDataSms", "throws": null, "funcname": "void onSendDataSms (byte[] data,                 int subId,                 String destAddress,                 int destPort,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "  Override this method to intercept binary SMSs sent from the device. ", "parameters": [{"scri": "byte: the binary contentThis value must never be null.", "name": "data"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: the destination port", "name": "destPort"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendDataSms", "throws": null, "funcname": "void onSendDataSms (byte[] data,                 int subId,                 String destAddress,                 int destPort,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "  Override this method to intercept binary SMSs sent from the device. ", "parameters": [{"scri": "byte: the binary contentThis value must never be null.", "name": "data"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: the destination port", "name": "destPort"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendDataSms", "throws": null, "funcname": "void onSendDataSms (byte[] data,                 int subId,                 String destAddress,                 int destPort,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "  Override this method to intercept binary SMSs sent from the device. ", "parameters": [{"scri": "byte: the binary contentThis value must never be null.", "name": "data"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: the destination port", "name": "destPort"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendMms", "throws": null, "funcname": "void onSendMms (Uri pduUri,                 int subId,                 Uri location,                 ResultCallback<CarrierMessagingService.SendMmsResult> callback)", "descri": "  Override this method to intercept MMSs sent from the device. ", "parameters": [{"scri": "Uri: the content provider URI of the PDU to sendThis value must never be null.", "name": "pduUri"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "Uri: the optional URI to send this MMS PDU. If this is {code null},        the PDU should be sent to the default MMSC URL.", "name": "location"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendMmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendMms", "throws": null, "funcname": "void onSendMms (Uri pduUri,                 int subId,                 Uri location,                 ResultCallback<CarrierMessagingService.SendMmsResult> callback)", "descri": "  Override this method to intercept MMSs sent from the device. ", "parameters": [{"scri": "Uri: the content provider URI of the PDU to sendThis value must never be null.", "name": "pduUri"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "Uri: the optional URI to send this MMS PDU. If this is {code null},        the PDU should be sent to the default MMSC URL.", "name": "location"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendMmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendMultipartTextSms", "throws": null, "funcname": "void onSendMultipartTextSms (List<String> parts,                 int subId,                 String destAddress,                 ResultCallback<CarrierMessagingService.SendMultipartSmsResult> callback)", "descri": "   This method was deprecated      in API level 23.    Override onSendMultipartTextSms(List, int, String, CarrierMessagingService.ResultCallback) below instead.  Override this method to intercept long SMSs sent from the device. ", "parameters": [{"scri": "List: a List of the message partsThis value must never be null.", "name": "parts"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendMultipartSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendMultipartTextSms", "throws": null, "funcname": "void onSendMultipartTextSms (List<String> parts,                 int subId,                 String destAddress,                 ResultCallback<CarrierMessagingService.SendMultipartSmsResult> callback)", "descri": "   This method was deprecated      in API level 23.    Override onSendMultipartTextSms(List, int, String, CarrierMessagingService.ResultCallback) below instead.  Override this method to intercept long SMSs sent from the device. ", "parameters": [{"scri": "List: a List of the message partsThis value must never be null.", "name": "parts"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendMultipartSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendMultipartTextSms", "throws": null, "funcname": "void onSendMultipartTextSms (List<String> parts,                 int subId,                 String destAddress,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendMultipartSmsResult> callback)", "descri": "  Override this method to intercept long SMSs sent from the device. ", "parameters": [{"scri": "List: a List of the message partsThis value must never be null.", "name": "parts"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendMultipartSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendMultipartTextSms", "throws": null, "funcname": "void onSendMultipartTextSms (List<String> parts,                 int subId,                 String destAddress,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendMultipartSmsResult> callback)", "descri": "  Override this method to intercept long SMSs sent from the device. ", "parameters": [{"scri": "List: a List of the message partsThis value must never be null.", "name": "parts"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendMultipartSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendMultipartTextSms", "throws": null, "funcname": "void onSendMultipartTextSms (List<String> parts,                 int subId,                 String destAddress,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendMultipartSmsResult> callback)", "descri": "  Override this method to intercept long SMSs sent from the device. ", "parameters": [{"scri": "List: a List of the message partsThis value must never be null.", "name": "parts"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendMultipartSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendTextSms", "throws": null, "funcname": "void onSendTextSms (String text,                 int subId,                 String destAddress,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "  Override this method to intercept text SMSs sent from the device. ", "parameters": [{"scri": "String: the text to sendThis value must never be null.", "name": "text"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendTextSms", "throws": null, "funcname": "void onSendTextSms (String text,                 int subId,                 String destAddress,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "  Override this method to intercept text SMSs sent from the device. ", "parameters": [{"scri": "String: the text to sendThis value must never be null.", "name": "text"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendTextSms", "throws": null, "funcname": "void onSendTextSms (String text,                 int subId,                 String destAddress,                 int sendSmsFlag,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "  Override this method to intercept text SMSs sent from the device. ", "parameters": [{"scri": "String: the text to sendThis value must never be null.", "name": "text"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "int: Flag for sending SMS. Acceptable values are 0 and        SEND_FLAG_REQUEST_DELIVERY_STATUS.", "name": "sendSmsFlag"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendTextSms", "throws": null, "funcname": "void onSendTextSms (String text,                 int subId,                 String destAddress,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "   This method was deprecated      in API level 23.    Override onSendTextSms(String, int, String, CarrierMessagingService.ResultCallback) below instead.  Override this method to intercept text SMSs sent from the device. ", "parameters": [{"scri": "String: the text to sendThis value must never be null.", "name": "text"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": null, "class": "android.service.carrier.MessagePdu\n", "type": "void", "name": "onSendTextSms", "throws": null, "funcname": "void onSendTextSms (String text,                 int subId,                 String destAddress,                 ResultCallback<CarrierMessagingService.SendSmsResult> callback)", "descri": "   This method was deprecated      in API level 23.    Override onSendTextSms(String, int, String, CarrierMessagingService.ResultCallback) below instead.  Override this method to intercept text SMSs sent from the device. ", "parameters": [{"scri": "String: the text to sendThis value must never be null.", "name": "text"}, {"scri": "int: SMS subscription ID of the SIM", "name": "subId"}, {"scri": "String: phone number of the recipient of the messageThis value must never be null.", "name": "destAddress"}, {"scri": "ResultCallback: result callback. Call with a CarrierMessagingService.SendSmsResult.This value must never be null.", "name": "callback"}]}, {"returns": [{"scri": "the message reference", "type": "int"}], "class": "android.service.chooser.ChooserTarget\n", "type": "int", "name": "getMessageRef", "throws": null, "funcname": "int getMessageRef ()", "descri": "  Returns the message reference of the just-sent SMS. ", "parameters": null}, {"returns": [{"scri": "the send status", "type": "int"}], "class": "android.service.chooser.ChooserTarget\n", "type": "int", "name": "getSendStatus", "throws": null, "funcname": "int getSendStatus ()", "descri": "  Returns the send status of the just-sent SMS. ", "parameters": null}, {"returns": null, "class": "android.service.chooser.ChooserTarget\n", "name": "CarrierMessagingService.SendSmsResult", "throws": null, "funcname": "CarrierMessagingService.SendSmsResult (int sendStatus,                 int messageRef)", "parameters": [{"scri": "int: send status, one of SEND_STATUS_OK,        SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and SEND_STATUS_ERROR.", "name": "sendStatus"}, {"scri": "int: message reference of the just-sent SMS. This field is applicable only        if send status is SEND_STATUS_OK.", "name": "messageRef"}], "descri": "  Constructs a SendSmsResult with the send status and message reference for the just-sent SMS. "}, {"returns": null, "class": "android.service.chooser.ChooserTarget\n", "name": "CarrierMessagingService.SendSmsResult", "throws": null, "funcname": "CarrierMessagingService.SendSmsResult (int sendStatus,                 int messageRef)", "parameters": [{"scri": "int: send status, one of SEND_STATUS_OK,        SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and SEND_STATUS_ERROR.", "name": "sendStatus"}, {"scri": "int: message reference of the just-sent SMS. This field is applicable only        if send status is SEND_STATUS_OK.", "name": "messageRef"}], "descri": "  Constructs a SendSmsResult with the send status and message reference for the just-sent SMS. "}, {"returns": [{"scri": "the send status which is one of SEND_STATUS_OK,         SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and SEND_STATUS_ERROR", "type": "int"}], "class": "android.service.chooser.ChooserTargetService\n", "type": "int", "name": "getSendStatus", "throws": null, "funcname": "int getSendStatus ()", "descri": "  Returns the send status of the just-sent MMS. ", "parameters": null}, {"returns": null, "class": "android.service.chooser.ChooserTargetService\n", "name": "CarrierMessagingService.SendMmsResult", "throws": null, "funcname": "CarrierMessagingService.SendMmsResult (int sendStatus,                 byte[] sendConfPdu)", "parameters": [{"scri": "int: send status, one of SEND_STATUS_OK,        SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and        SEND_STATUS_ERROR", "name": "sendStatus"}, {"scri": "byte: a possibly {code null} SendConf PDU, which confirms that the message        was sent. sendConfPdu is ignored if the result is not        SEND_STATUS_OK.", "name": "sendConfPdu"}], "descri": "  Constructs a SendMmsResult with the MMS send result, and the SendConf PDU. "}, {"returns": null, "class": "android.service.chooser.ChooserTargetService\n", "name": "CarrierMessagingService.SendMmsResult", "throws": null, "funcname": "CarrierMessagingService.SendMmsResult (int sendStatus,                 byte[] sendConfPdu)", "parameters": [{"scri": "int: send status, one of SEND_STATUS_OK,        SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and        SEND_STATUS_ERROR", "name": "sendStatus"}, {"scri": "byte: a possibly {code null} SendConf PDU, which confirms that the message        was sent. sendConfPdu is ignored if the result is not        SEND_STATUS_OK.", "name": "sendConfPdu"}], "descri": "  Constructs a SendMmsResult with the MMS send result, and the SendConf PDU. "}, {"returns": [{"scri": "the message references, one for each part of the multipart SMSThis value may be null.", "type": "int[]"}], "class": "android.service.dreams.DreamService\n", "type": "int[]", "name": "getMessageRefs", "throws": null, "funcname": "int[] getMessageRefs ()", "descri": "  Returns the message references of the just-sent multipart SMS. ", "parameters": null}, {"returns": [{"scri": "the send status", "type": "int"}], "class": "android.service.dreams.DreamService\n", "type": "int", "name": "getSendStatus", "throws": null, "funcname": "int getSendStatus ()", "descri": "  Returns the send status of the just-sent SMS. ", "parameters": null}, {"returns": null, "class": "android.service.dreams.DreamService\n", "name": "CarrierMessagingService.SendMultipartSmsResult", "throws": null, "funcname": "CarrierMessagingService.SendMultipartSmsResult (int sendStatus,                 int[] messageRefs)", "parameters": [{"scri": "int: send status, one of SEND_STATUS_OK,        SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and SEND_STATUS_ERROR.", "name": "sendStatus"}, {"scri": "int: an array of message references, one for each part of the        multipart SMS. This field is applicable only if send status is        SEND_STATUS_OK.This value may be null.", "name": "messageRefs"}], "descri": "  Constructs a SendMultipartSmsResult with the send status and message references for the just-sent multipart SMS. "}, {"returns": null, "class": "android.service.dreams.DreamService\n", "name": "CarrierMessagingService.SendMultipartSmsResult", "throws": null, "funcname": "CarrierMessagingService.SendMultipartSmsResult (int sendStatus,                 int[] messageRefs)", "parameters": [{"scri": "int: send status, one of SEND_STATUS_OK,        SEND_STATUS_RETRY_ON_CARRIER_NETWORK, and SEND_STATUS_ERROR.", "name": "sendStatus"}, {"scri": "int: an array of message references, one for each part of the        multipart SMS. This field is applicable only if send status is        SEND_STATUS_OK.This value may be null.", "name": "messageRefs"}], "descri": "  Constructs a SendMultipartSmsResult with the send status and message references for the just-sent multipart SMS. "}, {"returns": null, "class": "android.service.media.MediaBrowserService.Result\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onCooldown", "throws": null, "funcname": "void onCooldown (boolean cameraIntentFired)", "descri": "  Called when prewarm phase is done, either because the camera launch intent has been fired at this point or prewarm is no longer needed. A client should close the camera immediately in the latter case. In case the camera launch intent has been fired, there is no guarantee about the ordering of these two events. Cooldown might happen either before or after the activity has been created that handles the camera intent. ", "parameters": [{"scri": "boolean: Indicates whether the intent to launch the camera has been                          fired.", "name": "cameraIntentFired"}]}, {"returns": null, "class": "android.service.media.MediaBrowserService.Result\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onPrewarm", "throws": null, "funcname": "void onPrewarm ()", "descri": "  Called when the camera should be prewarmed.", "parameters": null}, {"returns": null, "class": "android.service.notification.Condition\n", "type": "void", "name": "notifyChildrenChanged", "throws": null, "funcname": "void notifyChildrenChanged (String parentId)", "descri": "  Notifies all connected media browsers that the children of the specified parent id have changed in some way. This will cause browsers to fetch subscribed content again. ", "parameters": [{"scri": "String: The id of the parent media item whose children changed.This value must never be null.", "name": "parentId"}]}, {"returns": null, "class": "android.service.notification.Condition\n", "type": "void", "name": "notifyChildrenChanged", "throws": null, "funcname": "void notifyChildrenChanged (String parentId,                 Bundle options)", "descri": "  Notifies all connected media browsers that the children of the specified parent id have changed in some way. This will cause browsers to fetch subscribed content again. ", "parameters": [{"scri": "String: The id of the parent media item whose            children changed.This value must never be null.", "name": "parentId"}, {"scri": "Bundle: The bundle of service-specific arguments to send            to the media browser. The contents of this bundle may            contain the information about the change.This value must never be null.", "name": "options"}]}, {"returns": null, "class": "android.service.notification.Condition\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "onLoadChildren", "throws": null, "funcname": "void onLoadChildren (String parentId,                 Result<List<MediaBrowser.MediaItem>> result,                 Bundle options)", "descri": "  Called to get information about the children of a media item. Implementations must call result.sendResult with the list of children. If loading the children will be an expensive operation that should be performed on another thread, result.detach may be called before returning from this function, and then result.sendResult called when the loading is complete. In case the media item does not have any children, call sendResult(T) with an empty list. When the given parentId is invalid, implementations must call result.sendResult with null, which will invoke onError(String). ", "parameters": [{"scri": "String: The id of the parent media item whose children are to be            queried.This value must never be null.", "name": "parentId"}, {"scri": "Result: The Result to send the list of children to.This value must never be null.", "name": "result"}, {"scri": "Bundle: The bundle of service-specific arguments sent from the media            browser. The information returned through the result should be            affected by the contents of this bundle.This value must never be null.", "name": "options"}]}, {"returns": null, "class": "android.service.notification.Condition\n", "type": "void", "name": "onLoadItem", "throws": null, "funcname": "void onLoadItem (String itemId,                 Result<MediaBrowser.MediaItem> result)", "descri": "  Called to get information about a specific media item. Implementations must call result.sendResult. If loading the item will be an expensive operation result.detach may be called before returning from this function, and then result.sendResult called when the item has been loaded. When the given itemId is invalid, implementations must call result.sendResult with null. The default implementation will invoke onError(String). ", "parameters": [{"scri": "String: The id for the specific            MediaBrowser.MediaItem.", "name": "itemId"}, {"scri": "Result: The Result to send the item to.", "name": "result"}]}, {"returns": null, "class": "android.service.notification.ConditionProviderService\n", "name": "MediaBrowserService.BrowserRoot", "throws": null, "funcname": "MediaBrowserService.BrowserRoot (String rootId,                 Bundle extras)", "parameters": [{"scri": "String: The root id for browsing.This value must never be null.", "name": "rootId"}, {"scri": "Bundle: Any extras about the browser service.This value may be null.", "name": "extras"}], "descri": "  Constructs a browser root. "}, {"returns": null, "class": "android.service.notification.ConditionProviderService\n", "name": "MediaBrowserService.BrowserRoot", "throws": null, "funcname": "MediaBrowserService.BrowserRoot (String rootId,                 Bundle extras)", "parameters": [{"scri": "String: The root id for browsing.This value must never be null.", "name": "rootId"}, {"scri": "Bundle: Any extras about the browser service.This value may be null.", "name": "extras"}], "descri": "  Constructs a browser root. "}, {"returns": null, "class": "android.telecom.CallScreeningService\n", "type": "void", "name": "postDialContinue", "throws": null, "funcname": "void postDialContinue (boolean proceed)", "descri": "  Instructs this Call to continue playing a post-dial DTMF string. A post-dial DTMF string is a string of digits entered after a phone number, when dialed, that are immediately sent as DTMF tones to the recipient as soon as the connection is made. If the DTMF string contains a DTMF_CHARACTER_PAUSE symbol, this Call will temporarily pause playing the tones for a pre-defined period of time. If the DTMF string contains a DTMF_CHARACTER_WAIT symbol, this Call will pause playing the tones and notify callbacks via onPostDialWait(Call, String). At this point, the in-call app should display to the user an indication of this state and an affordance to continue the postdial sequence. When the user decides to continue the postdial sequence, the in-call app should invoke the postDialContinue(boolean) method. ", "parameters": [{"scri": "boolean: Whether or not to continue with the post-dial sequence.", "name": "proceed"}]}, {"returns": null, "class": "android.telecom.Connection.RttTextStream\n", "type": "final\n        \n        void", "name": "setConnectionTime", "throws": null, "funcname": "void setConnectionTime (long connectionTimeMillis)", "descri": "  Sets the connection start time of the Conference.  This is used in the call log to indicate the date and time when the conference took place. Should be specified in wall-clock time returned by currentTimeMillis(). When setting the connection time, you should always set the connection elapsed time via setConnectionStartElapsedRealTime(long) to ensure the duration is reflected. ", "parameters": [{"scri": "long: The connection time, in milliseconds, as returned by                             currentTimeMillis().", "name": "connectionTimeMillis"}]}, {"returns": null, "class": "android.telecom.ConnectionRequest\n", "type": "void", "name": "onAnswer", "throws": null, "funcname": "void onAnswer (int videoState)", "descri": "  Notifies this Connection, which is in STATE_RINGING, of a request to accept. For managed ConnectionServices, this will be called when the user answers a call via the default dialer's InCallService. Although a self-managed ConnectionService provides its own incoming call UI, the Telecom framework may request that the call is answered in the following circumstances: The user chooses to answer an incoming call via a Bluetooth device. A car mode InCallService is in use which has declared     METADATA_INCLUDE_SELF_MANAGED_CALLS in its manifest.  Such an     InCallService will be able to see calls from self-managed     ConnectionServices, and will be able to display an incoming call UI on their     behalf. ", "parameters": [{"scri": "int: The video state in which to answer the connection.", "name": "videoState"}]}, {"returns": null, "class": "android.telecom.ConnectionRequest\n", "type": "void", "name": "onAnswer", "throws": null, "funcname": "void onAnswer ()", "descri": "  Notifies this Connection, which is in STATE_RINGING, of a request to accept. For managed ConnectionServices, this will be called when the user answers a call via the default dialer's InCallService. Although a self-managed ConnectionService provides its own incoming call UI, the Telecom framework may request that the call is answered in the following circumstances: The user chooses to answer an incoming call via a Bluetooth device. A car mode InCallService is in use which has declared     METADATA_INCLUDE_SELF_MANAGED_CALLS in its manifest.  Such an     InCallService will be able to see calls from self-managed     ConnectionServices, and will be able to display an incoming call UI on their     behalf.", "parameters": null}, {"returns": null, "class": "android.telecom.ConnectionRequest\n", "type": "void", "name": "onReject", "throws": null, "funcname": "void onReject ()", "descri": "  Notifies this Connection, which is in STATE_RINGING, of a request to reject. For managed ConnectionServices, this will be called when the user rejects a call via the default dialer's InCallService. Although a self-managed ConnectionService provides its own incoming call UI, the Telecom framework may request that the call is rejected in the following circumstances: The user chooses to reject an incoming call via a Bluetooth device. A car mode InCallService is in use which has declared     METADATA_INCLUDE_SELF_MANAGED_CALLS in its manifest.  Such an     InCallService will be able to see calls from self-managed     ConnectionServices, and will be able to display an incoming call UI on their     behalf.", "parameters": null}, {"returns": null, "class": "android.telecom.ConnectionRequest\n", "type": "void", "name": "requestBluetoothAudio", "throws": null, "funcname": "void requestBluetoothAudio (BluetoothDevice bluetoothDevice)", "descri": "  Request audio routing to a specific bluetooth device. Calling this method may result in the device routing audio to a different bluetooth device than the one specified if the bluetooth stack is unable to route audio to the requested device. A list of available devices can be obtained via getSupportedBluetoothDevices() Used by self-managed ConnectionServices which wish to use bluetooth audio for a self-managed Connection (see CAPABILITY_SELF_MANAGED.) See also requestBluetoothAudio(BluetoothDevice) ", "parameters": [{"scri": "BluetoothDevice: The bluetooth device to connect to.This value must never be null.", "name": "bluetoothDevice"}]}, {"returns": null, "class": "android.telecom.ConnectionRequest\n", "type": "void", "name": "sendConnectionEvent", "throws": null, "funcname": "void sendConnectionEvent (String event,                 Bundle extras)", "descri": "  Sends an event associated with this Connection with associated event extras to the InCallService. Connection events are used to communicate point in time information from a ConnectionService to a InCallService implementations.  An example of a custom connection event includes notifying the UI when a WIFI call has been handed over to LTE, which the InCall UI might use to inform the user that billing charges may apply.  The Android Telephony framework will send the EVENT_CALL_MERGE_FAILED connection event when a call to mergeConference() has failed to complete successfully.  A connection event could also be used to trigger UI in the InCallService which prompts the user to make a choice (e.g. whether they want to incur roaming costs for making a call), which is communicated back via sendCallEvent(String, Bundle). Events are exposed to InCallService implementations via onConnectionEvent(Call, String, Bundle). No assumptions should be made as to how an In-Call UI or service will handle these events. The ConnectionService must assume that the In-Call UI could even chose to ignore some events altogether. Events should be fully qualified (e.g. com.example.event.MY_EVENT) to avoid conflicts between ConnectionService implementations.  Further, custom ConnectionService implementations shall not re-purpose events in the android.* namespace, nor shall they define new event types in this namespace.  When defining a custom event type, ensure the contents of the extras Bundle is clearly defined.  Extra keys for this bundle should be named similar to the event type (e.g. com.example.extra.MY_EXTRA). When defining events and the associated extras, it is important to keep their behavior consistent when the associated ConnectionService is updated.  Support for deprecated events/extras should me maintained to ensure backwards compatibility with older InCallService implementations which were built to support the older behavior. ", "parameters": [{"scri": "String: The connection event.", "name": "event"}, {"scri": "Bundle: Optional bundle containing extra information associated with the event.", "name": "extras"}]}, {"returns": null, "class": "android.telecom.ConnectionRequest\n", "type": "final\n        \n        void", "name": "setAudioRoute", "throws": null, "funcname": "void setAudioRoute (int route)", "descri": "  Sets the audio route (speaker, bluetooth, etc...).  When this request is honored, there will be change to the getCallAudioState(). Used by self-managed ConnectionServices which wish to change the audio route for a self-managed Connection (see CAPABILITY_SELF_MANAGED.) See also setAudioRoute(int). ", "parameters": [{"scri": "int: The audio route to use (one of ROUTE_BLUETOOTH,              ROUTE_EARPIECE, ROUTE_SPEAKER, or              ROUTE_WIRED_HEADSET).", "name": "route"}]}, {"returns": null, "class": "android.telecom.InCallService\n", "name": "ConnectionRequest", "throws": null, "funcname": "ConnectionRequest (PhoneAccountHandle accountHandle,                 Uri handle,                 Bundle extras)", "parameters": [{"scri": "PhoneAccountHandle: The accountHandle which should be used to place the call.", "name": "accountHandle"}, {"scri": "Uri: The handle (e.g., phone number) to which the Connection is to connect.", "name": "handle"}, {"scri": "Bundle: Application-specific extra data.", "name": "extras"}], "descri": "   "}, {"returns": null, "class": "android.telecom.InCallService\n", "name": "ConnectionRequest", "throws": null, "funcname": "ConnectionRequest (PhoneAccountHandle accountHandle,                 Uri handle,                 Bundle extras,                 int videoState)", "parameters": [{"scri": "PhoneAccountHandle: The accountHandle which should be used to place the call.", "name": "accountHandle"}, {"scri": "Uri: The handle (e.g., phone number) to which the Connection is to connect.", "name": "handle"}, {"scri": "Bundle: Application-specific extra data.", "name": "extras"}, {"scri": "int: Determines the video state for the connection.", "name": "videoState"}], "descri": "   "}, {"returns": null, "class": "android.telecom.InCallService\n", "name": "ConnectionRequest", "throws": null, "funcname": "ConnectionRequest (PhoneAccountHandle accountHandle,                 Uri handle,                 Bundle extras)", "parameters": [{"scri": "PhoneAccountHandle: The accountHandle which should be used to place the call.", "name": "accountHandle"}, {"scri": "Uri: The handle (e.g., phone number) to which the Connection is to connect.", "name": "handle"}, {"scri": "Bundle: Application-specific extra data.", "name": "extras"}], "descri": "   "}, {"returns": null, "class": "android.telecom.InCallService\n", "name": "ConnectionRequest", "throws": null, "funcname": "ConnectionRequest (PhoneAccountHandle accountHandle,                 Uri handle,                 Bundle extras,                 int videoState)", "parameters": [{"scri": "PhoneAccountHandle: The accountHandle which should be used to place the call.", "name": "accountHandle"}, {"scri": "Uri: The handle (e.g., phone number) to which the Connection is to connect.", "name": "handle"}, {"scri": "Bundle: Application-specific extra data.", "name": "extras"}, {"scri": "int: Determines the video state for the connection.", "name": "videoState"}], "descri": "   "}, {"returns": null, "class": "android.telecom.InCallService.VideoCall\n", "type": "final\n        \n        void", "name": "connectionServiceFocusReleased", "throws": null, "funcname": "void connectionServiceFocusReleased ()", "descri": "  Call to inform Telecom that your ConnectionService has released call resources (e.g microphone, camera).  See also: onConnectionServiceFocusLost()", "parameters": null}, {"returns": null, "class": "android.telecom.PhoneAccount.Builder\n", "type": "final\n        \n        void", "name": "requestBluetoothAudio", "throws": null, "funcname": "void requestBluetoothAudio (BluetoothDevice bluetoothDevice)", "descri": "  Request audio routing to a specific bluetooth device. Calling this method may result in the device routing audio to a different bluetooth device than the one specified if the bluetooth stack is unable to route audio to the requested device. A list of available devices can be obtained via getSupportedBluetoothDevices() ", "parameters": [{"scri": "BluetoothDevice: The bluetooth device to connect to.This value must never be null.", "name": "bluetoothDevice"}]}, {"returns": null, "class": "android.telecom.PhoneAccount.Builder\n", "type": "final\n        \n        void", "name": "setAudioRoute", "throws": null, "funcname": "void setAudioRoute (int route)", "descri": "  Sets the audio route (speaker, bluetooth, etc...).  When this request is honored, there will be change to the getCallAudioState(). ", "parameters": [{"scri": "int: The audio route to use.", "name": "route"}]}, {"returns": null, "class": "android.telecom.PhoneAccount.Builder\n", "type": "final\n        \n        void", "name": "setMuted", "throws": null, "funcname": "void setMuted (boolean state)", "descri": "  Sets the microphone mute state. When this request is honored, there will be change to the getCallAudioState(). ", "parameters": [{"scri": "boolean: true if the microphone should be muted; false otherwise.", "name": "state"}]}, {"returns": null, "class": "android.telecom.PhoneAccountHandle\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "requestCameraCapabilities", "throws": null, "funcname": "void requestCameraCapabilities ()", "descri": "  Issues a request to the Connection.VideoProvider to retrieve the capabilities of the current camera.  The current camera is selected using setCamera(String). Camera capabilities are reported to the caller via onCameraCapabilitiesChanged(VideoProfile.CameraCapabilities). Handled by onRequestCameraCapabilities().", "parameters": null}, {"returns": null, "class": "android.telecom.PhoneAccountHandle\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "sendSessionModifyRequest", "throws": null, "funcname": "void sendSessionModifyRequest (VideoProfile requestProfile)", "descri": "  Issues a request to modify the properties of the current video session. Example scenarios include: requesting an audio-only call to be upgraded to a bi-directional video call, turning on or off the user's camera, sending a pause signal when the InCallService is no longer the foreground application. Handled by onSendSessionModifyRequest(VideoProfile, VideoProfile). ", "parameters": [{"scri": "VideoProfile: The requested call video properties.", "name": "requestProfile"}]}, {"returns": null, "class": "android.telecom.PhoneAccountHandle\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setCamera", "throws": null, "funcname": "void setCamera (String cameraId)", "descri": "  Sets the camera to be used for the outgoing video. Handled by onSetCamera(String). ", "parameters": [{"scri": "String: The id of the camera (use ids as reported by getCameraIdList()).", "name": "cameraId"}]}, {"returns": null, "class": "android.telecom.PhoneAccountHandle\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setPreviewSurface", "throws": null, "funcname": "void setPreviewSurface (Surface surface)", "descri": "  Sets the surface to be used for displaying a preview of what the user's camera is currently capturing.  When video transmission is enabled, this is the video signal which is sent to the remote device. Handled by onSetPreviewSurface(Surface). ", "parameters": [{"scri": "Surface: The Surface.", "name": "surface"}]}, {"returns": null, "class": "android.telecom.PhoneAccountHandle\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setZoom", "throws": null, "funcname": "void setZoom (float value)", "descri": "  Sets camera zoom ratio. Handled by onSetZoom(float). ", "parameters": [{"scri": "float: The camera zoom ratio.", "name": "value"}]}, {"returns": null, "class": "android.telecom.RemoteConnection\n", "type": "void", "name": "setCallAudioState", "throws": null, "funcname": "void setCallAudioState (CallAudioState state)", "descri": "  Request to change the conference's audio routing to the specified state. The specified state can include audio routing (Bluetooth, Speaker, etc) and muting state. ", "parameters": [{"scri": "CallAudioState", "name": "state"}]}, {"returns": null, "class": "android.telecom.TelecomManager\n", "type": "void", "name": "requestCameraCapabilities", "throws": null, "funcname": "void requestCameraCapabilities ()", "descri": "  Issues a request to retrieve the capabilities of the current camera for the RemoteConnection.VideoProvider.  See also: onRequestCameraCapabilities()", "parameters": null}, {"returns": null, "class": "android.telecom.TelecomManager\n", "type": "void", "name": "setCamera", "throws": null, "funcname": "void setCamera (String cameraId)", "descri": "  Sets the camera to be used for the outgoing video for the RemoteConnection.VideoProvider.   See also: onSetCamera(String)", "parameters": [{"scri": "String: The id of the camera (use ids as reported by getCameraIdList()).", "name": "cameraId"}]}, {"returns": null, "class": "android.telecom.TelecomManager\n", "type": "void", "name": "setPreviewSurface", "throws": null, "funcname": "void setPreviewSurface (Surface surface)", "descri": "  Sets the surface to be used for displaying a preview of what the user's camera is currently capturing for the RemoteConnection.VideoProvider.   See also: onSetPreviewSurface(Surface)", "parameters": [{"scri": "Surface: The Surface.", "name": "surface"}]}, {"returns": null, "class": "android.telecom.TelecomManager\n", "type": "void", "name": "setZoom", "throws": null, "funcname": "void setZoom (float value)", "descri": "  Sets camera zoom ratio for the RemoteConnection.VideoProvider.   See also: onSetZoom(float)", "parameters": [{"scri": "float: The camera zoom ratio.", "name": "value"}]}, {"returns": null, "class": "android.telecom.VideoProfile\n", "type": "void", "name": "onCameraCapabilitiesChanged", "throws": null, "funcname": "void onCameraCapabilitiesChanged (RemoteConnection.VideoProvider videoProvider,                 VideoProfile.CameraCapabilities cameraCapabilities)", "descri": "  Reports a change in the capabilities of the current camera, received from the Connection.VideoProvider associated with a RemoteConnection.   See also: onCameraCapabilitiesChanged(VideoProfile.CameraCapabilities)changeCameraCapabilities(VideoProfile.CameraCapabilities)", "parameters": [{"scri": "RemoteConnection.VideoProvider: The RemoteConnection.VideoProvider invoking this method.", "name": "videoProvider"}, {"scri": "VideoProfile.CameraCapabilities: The changed camera capabilities.", "name": "cameraCapabilities"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.telephony.AccessNetworkConstants\n", "type": "boolean", "name": "isVoiceMailNumber", "throws": null, "funcname": "boolean isVoiceMailNumber (PhoneAccountHandle accountHandle,                 String number)", "descri": "  Return whether a given phone number is the configured voicemail number for a particular phone account. Requires permission: READ_PHONE_STATE  ", "parameters": [{"scri": "PhoneAccountHandle: The handle for the account to check the voicemail number against", "name": "accountHandle"}, {"scri": "String: The number to look up.", "name": "number"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.telephony.AccessNetworkConstants.GeranBand\n", "type": "int", "name": "getHeight", "throws": null, "funcname": "int getHeight ()", "descri": "  The height of the camera video in pixels. ", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.telephony.AccessNetworkConstants.GeranBand\n", "type": "int", "name": "getWidth", "throws": null, "funcname": "int getWidth ()", "descri": "  The width of the camera video in pixels. ", "parameters": null}, {"returns": null, "class": "android.telephony.AccessNetworkConstants.GeranBand\n", "name": "VideoProfile.CameraCapabilities", "throws": null, "funcname": "VideoProfile.CameraCapabilities (int width,                 int height)", "parameters": [{"scri": "int: The width of the camera video (in pixels).", "name": "width"}, {"scri": "int: The height of the camera video (in pixels).", "name": "height"}], "descri": "  Create a call camera capabilities instance. "}, {"returns": null, "class": "android.telephony.AccessNetworkConstants.GeranBand\n", "name": "VideoProfile.CameraCapabilities", "throws": null, "funcname": "VideoProfile.CameraCapabilities (int width,                 int height)", "parameters": [{"scri": "int: The width of the camera video (in pixels).", "name": "width"}, {"scri": "int: The height of the camera video (in pixels).", "name": "height"}], "descri": "  Create a call camera capabilities instance. "}, {"returns": null, "class": "android.telephony.AccessNetworkConstants.GeranBand\n", "name": "VideoProfile.CameraCapabilities", "throws": null, "funcname": "VideoProfile.CameraCapabilities (int width,                 int height)", "parameters": [{"scri": "int: The width of the camera video (in pixels).", "name": "width"}, {"scri": "int: The height of the camera video (in pixels).", "name": "height"}], "descri": "  Create a call camera capabilities instance. "}, {"returns": null, "class": "android.telephony.AccessNetworkConstants.GeranBand\n", "name": "VideoProfile.CameraCapabilities", "throws": null, "funcname": "VideoProfile.CameraCapabilities (int width,                 int height)", "parameters": [{"scri": "int: The width of the camera video (in pixels).", "name": "width"}, {"scri": "int: The height of the camera video (in pixels).", "name": "height"}], "descri": "  Create a call camera capabilities instance. "}, {"returns": [{"scri": "16-bit Location Area Code, 0..65535, Integer.MAX_VALUE if unknown", "type": "int"}], "class": "android.telephony.CellInfoGsm\n", "type": "int", "name": "getLac", "throws": null, "funcname": "int getLac ()", "descri": "   ", "parameters": null}, {"returns": null, "class": "android.telephony.CellSignalStrengthWcdma\n", "type": "static\n        \n        \n        void", "name": "requestLocationUpdate", "throws": null, "funcname": "void requestLocationUpdate ()", "descri": "  Request an update of the current location.  If the location has changed, a broadcast will be sent to everyone registered with LISTEN_CELL_LOCATION.", "parameters": null}, {"returns": null, "class": "android.telephony.mbms.DownloadRequest\n", "type": "void", "name": "sendDataMessage", "throws": [{"scri": "if destinationAddress or data are empty", "type": "IllegalArgumentException"}], "funcname": "void sendDataMessage (String destinationAddress,                 String scAddress,                 short destinationPort,                 byte[] data,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsManager.  Send a data based SMS to a specific application port.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use  the current default SMSC", "name": "scAddress"}, {"scri": "short: the port to deliver the message to", "name": "destinationPort"}, {"scri": "byte: the body of the message to send", "name": "data"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is sucessfully sent, or failed.  The result code will be Activity.RESULT_OK for success,  or one of these errors:  RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU.  The per-application based SMS control checks sentIntent. If sentIntent  is NULL the caller will be checked against all unknown applicaitons,  which cause smaller number of SMS to be sent in checking period.", "name": "sentIntent"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is delivered to the recipient.  The  raw pdu of the status report is in the extended data (\"pdu\").", "name": "deliveryIntent"}]}, {"returns": null, "class": "android.telephony.mbms.DownloadRequest\n", "type": "void", "name": "sendDataMessage", "throws": [{"scri": "if destinationAddress or data are empty", "type": "IllegalArgumentException"}], "funcname": "void sendDataMessage (String destinationAddress,                 String scAddress,                 short destinationPort,                 byte[] data,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsManager.  Send a data based SMS to a specific application port.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use  the current default SMSC", "name": "scAddress"}, {"scri": "short: the port to deliver the message to", "name": "destinationPort"}, {"scri": "byte: the body of the message to send", "name": "data"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is sucessfully sent, or failed.  The result code will be Activity.RESULT_OK for success,  or one of these errors:  RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU.  The per-application based SMS control checks sentIntent. If sentIntent  is NULL the caller will be checked against all unknown applicaitons,  which cause smaller number of SMS to be sent in checking period.", "name": "sentIntent"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is delivered to the recipient.  The  raw pdu of the status report is in the extended data (\"pdu\").", "name": "deliveryIntent"}]}, {"returns": null, "class": "android.telephony.mbms.DownloadRequest\n", "type": "void", "name": "sendMultipartTextMessage", "throws": [{"scri": "if destinationAddress or data are empty", "type": "IllegalArgumentException"}], "funcname": "void sendMultipartTextMessage (String destinationAddress,                 String scAddress,                 ArrayList<String> parts,                 ArrayList<PendingIntent> sentIntents,                 ArrayList<PendingIntent> deliveryIntents)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsManager.  Send a multi-part text based SMS.  The callee should have already divided the message into correctly sized parts by calling divideMessage.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use   the current default SMSC", "name": "scAddress"}, {"scri": "ArrayList: an ArrayList of strings that, in order,   comprise the original message", "name": "parts"}, {"scri": "ArrayList: if not null, an ArrayList of   PendingIntents (one for each message part) that is   broadcast when the corresponding message part has been sent.   The result code will be Activity.RESULT_OK for success,   or one of these errors:   RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU.   The per-application based SMS control checks sentIntent. If sentIntent   is NULL the caller will be checked against all unknown applicaitons,   which cause smaller number of SMS to be sent in checking period.", "name": "sentIntents"}, {"scri": "ArrayList: if not null, an ArrayList of   PendingIntents (one for each message part) that is   broadcast when the corresponding message part has been delivered   to the recipient.  The raw pdu of the status report is in the   extended data (\"pdu\").", "name": "deliveryIntents"}]}, {"returns": null, "class": "android.telephony.mbms.DownloadRequest\n", "type": "void", "name": "sendMultipartTextMessage", "throws": [{"scri": "if destinationAddress or data are empty", "type": "IllegalArgumentException"}], "funcname": "void sendMultipartTextMessage (String destinationAddress,                 String scAddress,                 ArrayList<String> parts,                 ArrayList<PendingIntent> sentIntents,                 ArrayList<PendingIntent> deliveryIntents)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsManager.  Send a multi-part text based SMS.  The callee should have already divided the message into correctly sized parts by calling divideMessage.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use   the current default SMSC", "name": "scAddress"}, {"scri": "ArrayList: an ArrayList of strings that, in order,   comprise the original message", "name": "parts"}, {"scri": "ArrayList: if not null, an ArrayList of   PendingIntents (one for each message part) that is   broadcast when the corresponding message part has been sent.   The result code will be Activity.RESULT_OK for success,   or one of these errors:   RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU.   The per-application based SMS control checks sentIntent. If sentIntent   is NULL the caller will be checked against all unknown applicaitons,   which cause smaller number of SMS to be sent in checking period.", "name": "sentIntents"}, {"scri": "ArrayList: if not null, an ArrayList of   PendingIntents (one for each message part) that is   broadcast when the corresponding message part has been delivered   to the recipient.  The raw pdu of the status report is in the   extended data (\"pdu\").", "name": "deliveryIntents"}]}, {"returns": null, "class": "android.telephony.mbms.DownloadRequest\n", "type": "void", "name": "sendTextMessage", "throws": [{"scri": "if destinationAddress or text are empty", "type": "IllegalArgumentException"}], "funcname": "void sendTextMessage (String destinationAddress,                 String scAddress,                 String text,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsManager.  Send a text based SMS.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use  the current default SMSC", "name": "scAddress"}, {"scri": "String: the body of the message to send", "name": "text"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully sent, or failed.  The result code will be Activity.RESULT_OK for success,  or one of these errors:  RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU.  The per-application based SMS control checks sentIntent. If sentIntent  is NULL the caller will be checked against all unknown applications,  which cause smaller number of SMS to be sent in checking period.", "name": "sentIntent"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is delivered to the recipient.  The  raw pdu of the status report is in the extended data (\"pdu\").", "name": "deliveryIntent"}]}, {"returns": null, "class": "android.telephony.mbms.DownloadRequest\n", "type": "void", "name": "sendTextMessage", "throws": [{"scri": "if destinationAddress or text are empty", "type": "IllegalArgumentException"}], "funcname": "void sendTextMessage (String destinationAddress,                 String scAddress,                 String text,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsManager.  Send a text based SMS.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use  the current default SMSC", "name": "scAddress"}, {"scri": "String: the body of the message to send", "name": "text"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully sent, or failed.  The result code will be Activity.RESULT_OK for success,  or one of these errors:  RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU.  The per-application based SMS control checks sentIntent. If sentIntent  is NULL the caller will be checked against all unknown applications,  which cause smaller number of SMS to be sent in checking period.", "name": "sentIntent"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is delivered to the recipient.  The  raw pdu of the status report is in the extended data (\"pdu\").", "name": "deliveryIntent"}]}, {"returns": [{"scri": "an int[4] with int[0] being the number of SMS's required, int[1]         the number of code units used, and int[2] is the number of code         units remaining until the next message. int[3] is the encoding         type that should be used for the message.", "type": "int[]"}], "class": "android.telephony.mbms.DownloadStateCallback\n", "type": "static\n        \n        \n        int[]", "name": "calculateLength", "throws": null, "funcname": "int[] calculateLength (CharSequence messageBody,                 boolean use7bitOnly)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsMessage.  Calculates the number of SMS's required to encode the message body and the number of characters remaining until the next message, given the current encoding.  ", "parameters": [{"scri": "CharSequence: the message to encode", "name": "messageBody"}, {"scri": "boolean: if true, characters that are not part of the GSM         alphabet are counted as a single space char.  If false, a         messageBody containing non-GSM alphabet characters is calculated         for 16-bit encoding.", "name": "use7bitOnly"}]}, {"returns": [{"scri": "an int[4] with int[0] being the number of SMS's required, int[1]         the number of code units used, and int[2] is the number of code         units remaining until the next message. int[3] is the encoding         type that should be used for the message.", "type": "int[]"}], "class": "android.telephony.mbms.DownloadStateCallback\n", "type": "static\n        \n        \n        int[]", "name": "calculateLength", "throws": null, "funcname": "int[] calculateLength (String messageBody,                 boolean use7bitOnly)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsMessage.  Calculates the number of SMS's required to encode the message body and the number of characters remaining until the next message, given the current encoding.  ", "parameters": [{"scri": "String: the message to encode", "name": "messageBody"}, {"scri": "boolean: if true, characters that are not part of the GSM         alphabet are counted as a single space char.  If false, a         messageBody containing non-GSM alphabet characters is calculated         for 16-bit encoding.", "name": "use7bitOnly"}]}, {"returns": [{"scri": "the record index of the message on the SIM, or -1 if this         SmsMessage was not created from a SIM SMS EF record.", "type": "int"}], "class": "android.telephony.mbms.DownloadStateCallback\n", "type": "int", "name": "getIndexOnSim", "throws": null, "funcname": "int getIndexOnSim ()", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsMessage and getIndexOnIcc instead.  Returns the record index of the message on the SIM (1-based index). ", "parameters": null}, {"returns": [{"scri": "0 indicates the previously sent message was received.         See TS 23.040, 9.9.2.3.15 and C.S0015-B, v2.0, 4.5.21         for a description of other possible values.", "type": "int"}], "class": "android.telephony.mbms.DownloadStateCallback\n", "type": "int", "name": "getStatus", "throws": null, "funcname": "int getStatus ()", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsMessage.  GSM: For an SMS-STATUS-REPORT message, this returns the status field from the status report.  This field indicates the status of a previously submitted SMS, if requested.  See TS 23.040, 9.2.3.15 TP-Status for a description of values. CDMA: For not interfering with status codes from GSM, the value is shifted to the bits 31-16. The value is composed of an error class (bits 25-24) and a status code (bits 23-16). Possible codes are described in C.S0015-B, v2.0, 4.5.21. ", "parameters": null}, {"returns": [{"scri": "the status of the message on the SIM.  These are:         SmsManager.STATUS_ON_SIM_FREE         SmsManager.STATUS_ON_SIM_READ         SmsManager.STATUS_ON_SIM_UNREAD         SmsManager.STATUS_ON_SIM_SEND         SmsManager.STATUS_ON_SIM_UNSENT", "type": "int"}], "class": "android.telephony.mbms.DownloadStateCallback\n", "type": "int", "name": "getStatusOnSim", "throws": null, "funcname": "int getStatusOnSim ()", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsMessage and getStatusOnIcc instead.  Returns the status of the message on the SIM (read, unread, sent, unsent). ", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.telephony.mbms.DownloadStateCallback\n", "type": "static\n        \n        \n        int", "name": "getTPLayerLengthForPDU", "throws": null, "funcname": "int getTPLayerLengthForPDU (String pdu)", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsMessage.  Get the TP-Layer-Length for the given SMS-SUBMIT PDU Basically, the length in bytes (not hex chars) less the SMSC header  ", "parameters": [{"scri": "String", "name": "pdu"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.telephony.mbms.DownloadStateCallback\n", "type": "boolean", "name": "isReplace", "throws": null, "funcname": "boolean isReplace ()", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsMessage.  See TS 23.040 9.2.3.9 returns true if this is a \"replace short message\" SMS ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.telephony.mbms.DownloadStateCallback\n", "type": "boolean", "name": "isStatusReportMessage", "throws": null, "funcname": "boolean isStatusReportMessage ()", "descri": "   This method was deprecated      in API level 4.    Use android.telephony.SmsMessage.  Return true iff the message is a SMS-STATUS-REPORT message. ", "parameters": null}, {"returns": null, "class": "android.telephony.mbms.MbmsDownloadReceiver\n", "type": "static\n        \n        \n        DownloadRequest.Builder", "name": "DownloadRequest.Builder", "throws": null, "funcname": "DownloadRequest.Builder (Uri sourceUri,                 Uri destinationUri)", "descri": "  Builds a new DownloadRequest. ", "parameters": [{"scri": "Uri: the source URI for the DownloadRequest to be built. This URI should     never be null.", "name": "sourceUri"}, {"scri": "Uri: The final location for the file(s) that are to be downloaded. It     must be on the same filesystem as the temp file directory set via     setTempFileRootDirectory(File).     The provided path must be a directory that exists. An     IllegalArgumentException will be thrown otherwise.This value must never be null.", "name": "destinationUri"}]}, {"returns": null, "class": "android.telephony.mbms.MbmsDownloadReceiver\n", "name": "DownloadRequest.Builder", "throws": null, "funcname": "DownloadRequest.Builder (Uri sourceUri,                 Uri destinationUri)", "parameters": [{"scri": "Uri: the source URI for the DownloadRequest to be built. This URI should     never be null.", "name": "sourceUri"}, {"scri": "Uri: The final location for the file(s) that are to be downloaded. It     must be on the same filesystem as the temp file directory set via     setTempFileRootDirectory(File).     The provided path must be a directory that exists. An     IllegalArgumentException will be thrown otherwise.This value must never be null.", "name": "destinationUri"}], "descri": "  Builds a new DownloadRequest. "}, {"returns": null, "class": "android.telephony.mbms.MbmsDownloadReceiver\n", "name": "DownloadRequest.Builder", "throws": null, "funcname": "DownloadRequest.Builder (Uri sourceUri,                 Uri destinationUri)", "parameters": [{"scri": "Uri: the source URI for the DownloadRequest to be built. This URI should     never be null.", "name": "sourceUri"}, {"scri": "Uri: The final location for the file(s) that are to be downloaded. It     must be on the same filesystem as the temp file directory set via     setTempFileRootDirectory(File).     The provided path must be a directory that exists. An     IllegalArgumentException will be thrown otherwise.This value must never be null.", "name": "destinationUri"}], "descri": "  Builds a new DownloadRequest. "}, {"returns": null, "class": "android.telephony.NetworkScanRequest\n", "type": "void", "name": "download", "throws": null, "funcname": "void download (DownloadRequest request)", "descri": "  Requests the download of a file or set of files that the carrier has indicated to be available. May throw an IllegalArgumentException If setTempFileRootDirectory(File) has not called after the app has been installed, this method will create a directory at the default location defined at DEFAULT_TOP_LEVEL_TEMP_DIRECTORY and store that as the temp file root directory. If the DownloadRequest has a destination that is not on the same filesystem as the temp file directory provided via getTempFileRootDirectory(), an IllegalArgumentException will be thrown. Asynchronous errors through the callback may include any error not specific to the streaming use-case. If no error is delivered via the callback after calling this method, that means that the middleware has successfully started the download or scheduled the download, if the download is at a future time. ", "parameters": [{"scri": "DownloadRequest: The request that specifies what should be downloaded.This value must never be null.", "name": "request"}]}, {"returns": null, "class": "android.telephony.NetworkScanRequest\n", "type": "void", "name": "setTempFileRootDirectory", "throws": null, "funcname": "void setTempFileRootDirectory (File tempFileRootDirectory)", "descri": "  Sets the temp file root for downloads. All temp files created for the middleware to write to will be contained in the specified directory. Applications that wish to specify a location only need to call this method once as long their data is persisted in storage -- the argument will be stored both in a local instance of SharedPreferences and by the middleware. If this method is not called at least once before calling download(DownloadRequest), the framework will default to a directory formed by the concatenation of the app's files directory and DEFAULT_TOP_LEVEL_TEMP_DIRECTORY. Before calling this method, the app must cancel all of its pending DownloadRequests via cancelDownload(DownloadRequest). If this is not done, you will receive an asynchronous error with code ERROR_CANNOT_CHANGE_TEMP_FILE_ROOT unless the provided directory is the same as what has been previously configured. The File supplied as a root temp file directory must already exist. If not, an IllegalArgumentException will be thrown. In addition, as an additional sanity check, an IllegalArgumentException will be thrown if you attempt to set the temp file root directory to one of your data roots (the value of getDataDir(), getFilesDir(), or getCacheDir()). ", "parameters": [{"scri": "File: A directory to place temp files in.This value must never be null.", "name": "tempFileRootDirectory"}]}, {"returns": [{"scri": "Radio network type while neighboring cell location is stored. Return TelephonyManager.NETWORK_TYPE_UNKNOWN means that the location information is unavailable. Return TelephonyManager.NETWORK_TYPE_GPRS or TelephonyManager.NETWORK_TYPE_EDGE means that Neighboring Cell information is stored for GSM network, in which NeighboringCellInfo.getLac and NeighboringCellInfo.getCid should be called to access location. Return TelephonyManager.NETWORK_TYPE_UMTS, TelephonyManager.NETWORK_TYPE_HSDPA, TelephonyManager.NETWORK_TYPE_HSUPA, or TelephonyManager.NETWORK_TYPE_HSPA means that Neighboring Cell information is stored for UMTS network, in which NeighboringCellInfo.getPsc should be called to access location.", "type": "int"}], "class": "android.telephony.PhoneNumberUtils\n", "type": "int", "name": "getNetworkType", "throws": null, "funcname": "int getNetworkType ()", "descri": "   ", "parameters": null}, {"returns": null, "class": "android.telephony.PhoneNumberUtils\n", "type": "void", "name": "setCid", "throws": null, "funcname": "void setCid (int cid)", "descri": "   This method was deprecated      in API level 5.    cid value passed as in location parameter passed to constructor              NeighboringCellInfo(int, String, int)  Set the cell id. NeighboringCellInfo is a one time shot for the neighboring cells based on the radio network type at that moment. It shouldn't be changed after creation. ", "parameters": [{"scri": "int", "name": "cid"}]}, {"returns": null, "class": "android.telephony.PhoneNumberUtils\n", "name": "NeighboringCellInfo", "throws": null, "funcname": "NeighboringCellInfo (int rssi,                 String location,                 int radioType)", "parameters": [{"scri": "int", "name": "rssi"}, {"scri": "String", "name": "location"}, {"scri": "int", "name": "radioType"}], "descri": "  Initialize the object from rssi, location string, and radioType radioType is one of following TelephonyManager.NETWORK_TYPE_GPRS, TelephonyManager.NETWORK_TYPE_EDGE, TelephonyManager.NETWORK_TYPE_UMTS, TelephonyManager.NETWORK_TYPE_HSDPA, TelephonyManager.NETWORK_TYPE_HSUPA, and TelephonyManager.NETWORK_TYPE_HSPA. "}, {"returns": null, "class": "android.telephony.PhoneNumberUtils\n", "name": "NeighboringCellInfo", "throws": null, "funcname": "NeighboringCellInfo (int rssi,                 String location,                 int radioType)", "parameters": [{"scri": "int", "name": "rssi"}, {"scri": "String", "name": "location"}, {"scri": "int", "name": "radioType"}], "descri": "  Initialize the object from rssi, location string, and radioType radioType is one of following TelephonyManager.NETWORK_TYPE_GPRS, TelephonyManager.NETWORK_TYPE_EDGE, TelephonyManager.NETWORK_TYPE_UMTS, TelephonyManager.NETWORK_TYPE_HSDPA, TelephonyManager.NETWORK_TYPE_HSUPA, and TelephonyManager.NETWORK_TYPE_HSPA. "}, {"returns": null, "class": "android.telephony.ServiceState\n", "name": "PhoneNumberFormattingTextWatcher", "throws": null, "funcname": "PhoneNumberFormattingTextWatcher (String countryCode)", "parameters": [{"scri": "String: the ISO 3166-1 two-letter country code that indicates the country/region where the phone number is being entered.", "name": "countryCode"}], "descri": "  The formatting is based on the given countryCode. "}, {"returns": null, "class": "android.telephony.ServiceState\n", "name": "PhoneNumberFormattingTextWatcher", "throws": null, "funcname": "PhoneNumberFormattingTextWatcher (String countryCode)", "parameters": [{"scri": "String: the ISO 3166-1 two-letter country code that indicates the country/region where the phone number is being entered.", "name": "countryCode"}], "descri": "  The formatting is based on the given countryCode. "}, {"returns": null, "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        void", "name": "addTtsSpan", "throws": null, "funcname": "void addTtsSpan (Spannable s,                 int start,                 int endExclusive)", "descri": "  Attach a TtsSpan to the supplied Spannable at the indicated location, annotating that location as containing a phone number. ", "parameters": [{"scri": "Spannable: A Spannable to annotate.", "name": "s"}, {"scri": "int: The starting character position of the phone number in s.", "name": "start"}, {"scri": "int: The position after the ending character in the phone number s.", "name": "endExclusive"}]}, {"returns": null, "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        void", "name": "addTtsSpan", "throws": null, "funcname": "void addTtsSpan (Spannable s,                 int start,                 int endExclusive)", "descri": "  Attach a TtsSpan to the supplied Spannable at the indicated location, annotating that location as containing a phone number. ", "parameters": [{"scri": "Spannable: A Spannable to annotate.", "name": "s"}, {"scri": "int: The starting character position of the phone number in s.", "name": "start"}, {"scri": "int: The position after the ending character in the phone number s.", "name": "endExclusive"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        boolean", "name": "compare", "throws": null, "funcname": "boolean compare (Context context,                 String a,                 String b)", "descri": "  Compare phone numbers a and b, and return true if they're identical enough for caller ID purposes. Checks a resource to determine whether to use a strict or loose comparison algorithm.  ", "parameters": [{"scri": "Context", "name": "context"}, {"scri": "String", "name": "a"}, {"scri": "String", "name": "b"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        boolean", "name": "compare", "throws": null, "funcname": "boolean compare (String a,                 String b)", "descri": "  Compare phone numbers a and b, return true if they're identical enough for caller ID purposes.  ", "parameters": [{"scri": "String", "name": "a"}, {"scri": "String", "name": "b"}]}, {"returns": null, "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        void", "name": "formatJapaneseNumber", "throws": null, "funcname": "void formatJapaneseNumber (Editable text)", "descri": "   This method was deprecated      in API level 21.    Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead  Formats a phone number in-place using the Japanese formatting rules. Numbers will be formatted as: 03-xxxx-xxxx 090-xxxx-xxxx 0120-xxx-xxx +81-3-xxxx-xxxx +81-90-xxxx-xxxx ", "parameters": [{"scri": "Editable: the number to be formatted, will be modified with the formatting", "name": "text"}]}, {"returns": null, "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        void", "name": "formatNanpNumber", "throws": null, "funcname": "void formatNanpNumber (Editable text)", "descri": "   This method was deprecated      in API level 21.    Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead  Formats a phone number in-place using the NANP formatting rules. Numbers will be formatted as: xxxxx xxx-xxxx xxx-xxx-xxxx 1-xxx-xxx-xxxx +1-xxx-xxx-xxxx ", "parameters": [{"scri": "Editable: the number to be formatted, will be modified with the formatting", "name": "text"}]}, {"returns": [{"scri": "the formatted number if the given number has been formatted,            otherwise, return the given number.", "type": "String"}], "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        void", "name": "formatNumber", "throws": null, "funcname": "String formatNumber (String phoneNumber,                 String phoneNumberE164,                 String defaultCountryIso)", "descri": "  Format the phone number only if the given number hasn't been formatted. The number which has only dailable character is treated as not being formatted.  ", "parameters": [{"scri": "String: the number to be formatted.", "name": "phoneNumber"}, {"scri": "String: the E164 format number whose country code is used if the given            phoneNumber doesn't have the country code.", "name": "phoneNumberE164"}, {"scri": "String: the ISO 3166-1 two letters country code whose convention will            be used if the phoneNumberE164 is null or invalid, or if phoneNumber            contains IDD.", "name": "defaultCountryIso"}]}, {"returns": null, "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        void", "name": "formatNumber", "throws": null, "funcname": "void formatNumber (Editable text,                 int defaultFormattingType)", "descri": "   This method was deprecated      in API level 21.    Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead  Formats a phone number in-place. Currently FORMAT_JAPAN and FORMAT_NANP is supported as a second argument. ", "parameters": [{"scri": "Editable: The number to be formatted, will be modified with the formatting", "name": "text"}, {"scri": "int: The default formatting rules to apply if the number does not begin with +[country_code]", "name": "defaultFormattingType"}]}, {"returns": [{"scri": "A locally acceptable formatting of the input, or the raw input if  formatting rules aren't known for the number", "type": "String"}], "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        void", "name": "formatNumber", "throws": null, "funcname": "String formatNumber (String source)", "descri": "   This method was deprecated      in API level 21.    Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead  Breaks the given number down and formats it according to the rules for the country the number is from.  ", "parameters": [{"scri": "String: The phone number to format", "name": "source"}]}, {"returns": [{"scri": "the formatted number, or null if the given number is not valid.", "type": "String"}], "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        void", "name": "formatNumber", "throws": null, "funcname": "String formatNumber (String phoneNumber,                 String defaultCountryIso)", "descri": "  Format a phone number. If the given number doesn't have the country code, the phone will be formatted to the default country's convention.  ", "parameters": [{"scri": "String: the number to be formatted.", "name": "phoneNumber"}, {"scri": "String: the ISO 3166-1 two letters country code whose convention will            be used if the given number doesn't have the country code.", "name": "defaultCountryIso"}]}, {"returns": [{"scri": "The formatting type for the given locale, or FORMAT_UNKNOWN if the formatting rules are not known for the given locale", "type": "int"}], "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        int", "name": "getFormatTypeForLocale", "throws": null, "funcname": "int getFormatTypeForLocale (Locale locale)", "descri": "   This method was deprecated      in API level 21.    Use link #formatNumber(String phoneNumber, String defaultCountryIso) instead  Returns the phone number formatting type for the given locale.  ", "parameters": [{"scri": "Locale: The locale of interest, usually getDefault()", "name": "locale"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.telephony.SignalStrength\n", "type": "static\n        \n        \n        boolean", "name": "isWellFormedSmsAddress", "throws": null, "funcname": "boolean isWellFormedSmsAddress (String address)", "descri": "  Return true iff the network portion of address is, as far as we can tell on the device, suitable for use as an SMS destination address.  ", "parameters": [{"scri": "String", "name": "address"}]}, {"returns": null, "class": "android.telephony.SmsManager\n", "type": "void", "name": "onCallStateChanged", "throws": null, "funcname": "void onCallStateChanged (int state,                 String phoneNumber)", "descri": "  Callback invoked when device call state changes.   See also: CALL_STATE_IDLECALL_STATE_RINGINGCALL_STATE_OFFHOOK", "parameters": [{"scri": "int: call state", "name": "state"}, {"scri": "String: call phone number. If application does not have READ_PHONE_STATE permission or carrier privileges (see hasCarrierPrivileges()), an empty string will be passed as an argument.", "name": "phoneNumber"}]}, {"returns": null, "class": "android.telephony.SmsManager\n", "type": "void", "name": "onCellLocationChanged", "throws": null, "funcname": "void onCellLocationChanged (CellLocation location)", "descri": "  Callback invoked when device cell location changes. ", "parameters": [{"scri": "CellLocation", "name": "location"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "downloadMultimediaMessage", "throws": [{"scri": "if locationUrl or contentUri is empty", "type": "IllegalArgumentException"}], "funcname": "void downloadMultimediaMessage (Context context,                 String locationUrl,                 Uri contentUri,                 Bundle configOverrides,                 PendingIntent downloadedIntent)", "descri": "  Download an MMS message from carrier by a given location URL   ", "parameters": [{"scri": "Context: application context", "name": "context"}, {"scri": "String: the location URL of the MMS message to be downloaded, usually obtained  from the MMS WAP push notification", "name": "locationUrl"}, {"scri": "Uri: the content uri to which the downloaded pdu will be written", "name": "contentUri"}, {"scri": "Bundle: the carrier-specific messaging configuration values to override for  downloading the message.", "name": "configOverrides"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is downloaded, or the download is failed", "name": "downloadedIntent"}]}, {"returns": [{"scri": "the default SMS subscription id", "type": "int"}], "class": "android.telephony.SubscriptionManager\n", "type": "static\n        \n        \n        int", "name": "getDefaultSmsSubscriptionId", "throws": null, "funcname": "int getDefaultSmsSubscriptionId ()", "descri": "  Get default sms subscription id ", "parameters": null}, {"returns": [{"scri": "associated subscription id", "type": "int"}], "class": "android.telephony.SubscriptionManager\n", "type": "int", "name": "getSubscriptionId", "throws": null, "funcname": "int getSubscriptionId ()", "descri": "  Get the associated subscription id. If the instance was returned by getDefault(), then this method may return different values at different points in time (if the user changes the default subscription id). It will return < 0 if the default subscription id cannot be determined. Additionally, to support legacy applications that are not multi-SIM aware, if the following are true:     - We are using a multi-SIM device     - A default SMS SIM has not been selected     - At least one SIM subscription is available then ask the user to set the default SMS SIM. ", "parameters": null}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "injectSmsPdu", "throws": [{"scri": "if the format is invalid.", "type": "IllegalArgumentException"}], "funcname": "void injectSmsPdu (byte[] pdu,                 String format,                 PendingIntent receivedIntent)", "descri": "  Inject an SMS PDU into the android application framework. Requires permission: MODIFY_PHONE_STATE or carrier privileges per hasCarrierPrivileges().   ", "parameters": [{"scri": "byte: is the byte array of pdu to be injected into android application framework", "name": "pdu"}, {"scri": "String: is the format of SMS pdu (FORMAT_3GPP or  FORMAT_3GPP2)Value is FORMAT_3GPP or FORMAT_3GPP2.", "name": "format"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully received by the  android application framework, or failed. This intent is broadcasted at  the same time an SMS received from radio is acknowledged back.  The result code will be RESULT_SMS_HANDLED  for success, or RESULT_SMS_GENERIC_ERROR for  error.", "name": "receivedIntent"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "injectSmsPdu", "throws": [{"scri": "if the format is invalid.", "type": "IllegalArgumentException"}], "funcname": "void injectSmsPdu (byte[] pdu,                 String format,                 PendingIntent receivedIntent)", "descri": "  Inject an SMS PDU into the android application framework. Requires permission: MODIFY_PHONE_STATE or carrier privileges per hasCarrierPrivileges().   ", "parameters": [{"scri": "byte: is the byte array of pdu to be injected into android application framework", "name": "pdu"}, {"scri": "String: is the format of SMS pdu (FORMAT_3GPP or  FORMAT_3GPP2)Value is FORMAT_3GPP or FORMAT_3GPP2.", "name": "format"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully received by the  android application framework, or failed. This intent is broadcasted at  the same time an SMS received from radio is acknowledged back.  The result code will be RESULT_SMS_HANDLED  for success, or RESULT_SMS_GENERIC_ERROR for  error.", "name": "receivedIntent"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "sendDataMessage", "throws": [{"scri": "if destinationAddress or data are empty", "type": "IllegalArgumentException"}], "funcname": "void sendDataMessage (String destinationAddress,                 String scAddress,                 short destinationPort,                 byte[] data,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "  Send a data based SMS to a specific application port. Note: Using this method requires that your app has the SEND_SMS permission.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use  the current default SMSC", "name": "scAddress"}, {"scri": "short: the port to deliver the message to", "name": "destinationPort"}, {"scri": "byte: the body of the message to send", "name": "data"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully sent, or failed.  The result code will be Activity.RESULT_OK for success,  or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU  For RESULT_ERROR_GENERIC_FAILURE the sentIntent may include  the extra \"errorCode\" containing a radio technology specific value,  generally only useful for troubleshooting.  The per-application based SMS control checks sentIntent. If sentIntent  is NULL the caller will be checked against all unknown applications,  which cause smaller number of SMS to be sent in checking period.", "name": "sentIntent"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is delivered to the recipient.  The  raw pdu of the status report is in the extended data (\"pdu\").", "name": "deliveryIntent"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "sendDataMessage", "throws": [{"scri": "if destinationAddress or data are empty", "type": "IllegalArgumentException"}], "funcname": "void sendDataMessage (String destinationAddress,                 String scAddress,                 short destinationPort,                 byte[] data,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "  Send a data based SMS to a specific application port. Note: Using this method requires that your app has the SEND_SMS permission.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use  the current default SMSC", "name": "scAddress"}, {"scri": "short: the port to deliver the message to", "name": "destinationPort"}, {"scri": "byte: the body of the message to send", "name": "data"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully sent, or failed.  The result code will be Activity.RESULT_OK for success,  or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU  For RESULT_ERROR_GENERIC_FAILURE the sentIntent may include  the extra \"errorCode\" containing a radio technology specific value,  generally only useful for troubleshooting.  The per-application based SMS control checks sentIntent. If sentIntent  is NULL the caller will be checked against all unknown applications,  which cause smaller number of SMS to be sent in checking period.", "name": "sentIntent"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is delivered to the recipient.  The  raw pdu of the status report is in the extended data (\"pdu\").", "name": "deliveryIntent"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "sendMultimediaMessage", "throws": [{"scri": "if contentUri is empty", "type": "IllegalArgumentException"}], "funcname": "void sendMultimediaMessage (Context context,                 Uri contentUri,                 String locationUrl,                 Bundle configOverrides,                 PendingIntent sentIntent)", "descri": "  Send an MMS message   ", "parameters": [{"scri": "Context: application context", "name": "context"}, {"scri": "Uri: the content Uri from which the message pdu will be read", "name": "contentUri"}, {"scri": "String: the optional location url where message should be sent to", "name": "locationUrl"}, {"scri": "Bundle: the carrier-specific messaging configuration values to override for  sending the message.", "name": "configOverrides"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully sent, or failed", "name": "sentIntent"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "sendMultipartTextMessage", "throws": [{"scri": "if destinationAddress or data are empty", "type": "IllegalArgumentException"}], "funcname": "void sendMultipartTextMessage (String destinationAddress,                 String scAddress,                 ArrayList<String> parts,                 ArrayList<PendingIntent> sentIntents,                 ArrayList<PendingIntent> deliveryIntents)", "descri": "  Send a multi-part text based SMS.  The callee should have already divided the message into correctly sized parts by calling divideMessage. Note: Using this method requires that your app has the SEND_SMS permission.  Note: Beginning with Android 4.4 (API level 19), if and only if an app is not selected as the default SMS app, the system automatically writes messages sent using this method to the SMS Provider (the default SMS app is always responsible for writing its sent messages to the SMS Provider). For information about how to behave as the default SMS app, see Telephony.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use   the current default SMSC", "name": "scAddress"}, {"scri": "ArrayList: an ArrayList of strings that, in order,   comprise the original message", "name": "parts"}, {"scri": "ArrayList: if not null, an ArrayList of   PendingIntents (one for each message part) that is   broadcast when the corresponding message part has been sent.   The result code will be Activity.RESULT_OK for success,   or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU   For RESULT_ERROR_GENERIC_FAILURE each sentIntent may include   the extra \"errorCode\" containing a radio technology specific value,   generally only useful for troubleshooting.   The per-application based SMS control checks sentIntent. If sentIntent   is NULL the caller will be checked against all unknown applications,   which cause smaller number of SMS to be sent in checking period.", "name": "sentIntents"}, {"scri": "ArrayList: if not null, an ArrayList of   PendingIntents (one for each message part) that is   broadcast when the corresponding message part has been delivered   to the recipient.  The raw pdu of the status report is in the   extended data (\"pdu\").", "name": "deliveryIntents"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "sendMultipartTextMessage", "throws": [{"scri": "if destinationAddress or data are empty", "type": "IllegalArgumentException"}], "funcname": "void sendMultipartTextMessage (String destinationAddress,                 String scAddress,                 ArrayList<String> parts,                 ArrayList<PendingIntent> sentIntents,                 ArrayList<PendingIntent> deliveryIntents)", "descri": "  Send a multi-part text based SMS.  The callee should have already divided the message into correctly sized parts by calling divideMessage. Note: Using this method requires that your app has the SEND_SMS permission.  Note: Beginning with Android 4.4 (API level 19), if and only if an app is not selected as the default SMS app, the system automatically writes messages sent using this method to the SMS Provider (the default SMS app is always responsible for writing its sent messages to the SMS Provider). For information about how to behave as the default SMS app, see Telephony.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use   the current default SMSC", "name": "scAddress"}, {"scri": "ArrayList: an ArrayList of strings that, in order,   comprise the original message", "name": "parts"}, {"scri": "ArrayList: if not null, an ArrayList of   PendingIntents (one for each message part) that is   broadcast when the corresponding message part has been sent.   The result code will be Activity.RESULT_OK for success,   or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU   For RESULT_ERROR_GENERIC_FAILURE each sentIntent may include   the extra \"errorCode\" containing a radio technology specific value,   generally only useful for troubleshooting.   The per-application based SMS control checks sentIntent. If sentIntent   is NULL the caller will be checked against all unknown applications,   which cause smaller number of SMS to be sent in checking period.", "name": "sentIntents"}, {"scri": "ArrayList: if not null, an ArrayList of   PendingIntents (one for each message part) that is   broadcast when the corresponding message part has been delivered   to the recipient.  The raw pdu of the status report is in the   extended data (\"pdu\").", "name": "deliveryIntents"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "sendTextMessage", "throws": [{"scri": "if destinationAddress or text are empty", "type": "IllegalArgumentException"}], "funcname": "void sendTextMessage (String destinationAddress,                 String scAddress,                 String text,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "  Send a text based SMS. Note: Using this method requires that your app has the SEND_SMS permission.  Note: Beginning with Android 4.4 (API level 19), if and only if an app is not selected as the default SMS app, the system automatically writes messages sent using this method to the SMS Provider (the default SMS app is always responsible for writing its sent messages to the SMS Provider). For information about how to behave as the default SMS app, see Telephony.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use  the current default SMSC", "name": "scAddress"}, {"scri": "String: the body of the message to send", "name": "text"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully sent, or failed.  The result code will be Activity.RESULT_OK for success,  or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU  For RESULT_ERROR_GENERIC_FAILURE the sentIntent may include  the extra \"errorCode\" containing a radio technology specific value,  generally only useful for troubleshooting.  The per-application based SMS control checks sentIntent. If sentIntent  is NULL the caller will be checked against all unknown applications,  which cause smaller number of SMS to be sent in checking period.", "name": "sentIntent"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is delivered to the recipient.  The  raw pdu of the status report is in the extended data (\"pdu\").", "name": "deliveryIntent"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "sendTextMessage", "throws": [{"scri": "if destinationAddress or text are empty", "type": "IllegalArgumentException"}], "funcname": "void sendTextMessage (String destinationAddress,                 String scAddress,                 String text,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "  Send a text based SMS. Note: Using this method requires that your app has the SEND_SMS permission.  Note: Beginning with Android 4.4 (API level 19), if and only if an app is not selected as the default SMS app, the system automatically writes messages sent using this method to the SMS Provider (the default SMS app is always responsible for writing its sent messages to the SMS Provider). For information about how to behave as the default SMS app, see Telephony.   ", "parameters": [{"scri": "String: the address to send the message to", "name": "destinationAddress"}, {"scri": "String: is the service center address or null to use  the current default SMSC", "name": "scAddress"}, {"scri": "String: the body of the message to send", "name": "text"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is successfully sent, or failed.  The result code will be Activity.RESULT_OK for success,  or one of these errors: RESULT_ERROR_GENERIC_FAILURE RESULT_ERROR_RADIO_OFF RESULT_ERROR_NULL_PDU  For RESULT_ERROR_GENERIC_FAILURE the sentIntent may include  the extra \"errorCode\" containing a radio technology specific value,  generally only useful for troubleshooting.  The per-application based SMS control checks sentIntent. If sentIntent  is NULL the caller will be checked against all unknown applications,  which cause smaller number of SMS to be sent in checking period.", "name": "sentIntent"}, {"scri": "PendingIntent: if not NULL this PendingIntent is  broadcast when the message is delivered to the recipient.  The  raw pdu of the status report is in the extended data (\"pdu\").", "name": "deliveryIntent"}]}, {"returns": null, "class": "android.telephony.SubscriptionManager\n", "type": "void", "name": "sendTextMessageWithoutPersisting", "throws": null, "funcname": "void sendTextMessageWithoutPersisting (String destinationAddress,                 String scAddress,                 String text,                 PendingIntent sentIntent,                 PendingIntent deliveryIntent)", "descri": "  Send a text based SMS without writing it into the SMS Provider. The message will be sent directly over the network and will not be visible in SMS applications. Intended for internal carrier use only.  Requires Permission: Both SEND_SMS and MODIFY_PHONE_STATE, or that the calling app has carrier privileges (see hasCarrierPrivileges()), or that the calling app is the default IMS app (see KEY_CONFIG_IMS_PACKAGE_OVERRIDE_STRING).   See also: sendTextMessage(String, String, String, PendingIntent, PendingIntent)", "parameters": [{"scri": "String", "name": "destinationAddress"}, {"scri": "String", "name": "scAddress"}, {"scri": "String", "name": "text"}, {"scri": "PendingIntent", "name": "sentIntent"}, {"scri": "PendingIntent", "name": "deliveryIntent"}]}, {"returns": [{"scri": "an int[4] with int[0] being the number of SMS's         required, int[1] the number of code units used, and         int[2] is the number of code units remaining until the         next message. int[3] is an indicator of the encoding         code unit size (see the ENCODING_* definitions in SmsConstants)", "type": "int[]"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "static\n        \n        \n        int[]", "name": "calculateLength", "throws": null, "funcname": "int[] calculateLength (CharSequence msgBody,                 boolean use7bitOnly)", "descri": "  Calculates the number of SMS's required to encode the message body and the number of characters remaining until the next message.  ", "parameters": [{"scri": "CharSequence: the message to encode", "name": "msgBody"}, {"scri": "boolean: if true, characters that are not part of the         radio-specific 7-bit encoding are counted as single         space chars.  If false, and if the messageBody contains         non-7-bit encodable characters, length is calculated         using a 16-bit encoding.", "name": "use7bitOnly"}]}, {"returns": [{"scri": "an int[4] with int[0] being the number of SMS's required, int[1]         the number of code units used, and int[2] is the number of code         units remaining until the next message. int[3] is the encoding         type that should be used for the message.", "type": "int[]"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "static\n        \n        \n        int[]", "name": "calculateLength", "throws": null, "funcname": "int[] calculateLength (String messageBody,                 boolean use7bitOnly)", "descri": "  Calculates the number of SMS's required to encode the message body and the number of characters remaining until the next message, given the current encoding.  ", "parameters": [{"scri": "String: the message to encode", "name": "messageBody"}, {"scri": "boolean: if true, characters that are not part of the radio         specific (GSM / CDMA) alphabet encoding are converted to as a         single space characters. If false, a messageBody containing         non-GSM or non-CDMA alphabet characters are encoded using         16-bit encoding.", "name": "use7bitOnly"}]}, {"returns": [{"scri": "the record index of the message on the ICC, or -1 if this         SmsMessage was not created from a ICC SMS EF record.", "type": "int"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "int", "name": "getIndexOnIcc", "throws": null, "funcname": "int getIndexOnIcc ()", "descri": "  Returns the record index of the message on the ICC (1-based index). ", "parameters": null}, {"returns": [{"scri": "the record index of the message on the SIM, or -1 if this         SmsMessage was not created from a SIM SMS EF record.", "type": "int"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "int", "name": "getIndexOnSim", "throws": null, "funcname": "int getIndexOnSim ()", "descri": "   This method was deprecated      in API level 4.    Use getIndexOnIcc instead.  Returns the record index of the message on the SIM (1-based index). ", "parameters": null}, {"returns": [{"scri": "0 indicates the previously sent message was received.         See TS 23.040, 9.9.2.3.15 and C.S0015-B, v2.0, 4.5.21         for a description of other possible values.", "type": "int"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "int", "name": "getStatus", "throws": null, "funcname": "int getStatus ()", "descri": "  GSM: For an SMS-STATUS-REPORT message, this returns the status field from the status report.  This field indicates the status of a previously submitted SMS, if requested.  See TS 23.040, 9.2.3.15 TP-Status for a description of values. CDMA: For not interfering with status codes from GSM, the value is shifted to the bits 31-16. The value is composed of an error class (bits 25-24) and a status code (bits 23-16). Possible codes are described in C.S0015-B, v2.0, 4.5.21. ", "parameters": null}, {"returns": [{"scri": "the status of the message on the ICC.  These are:         SmsManager.STATUS_ON_ICC_FREE         SmsManager.STATUS_ON_ICC_READ         SmsManager.STATUS_ON_ICC_UNREAD         SmsManager.STATUS_ON_ICC_SEND         SmsManager.STATUS_ON_ICC_UNSENT", "type": "int"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "int", "name": "getStatusOnIcc", "throws": null, "funcname": "int getStatusOnIcc ()", "descri": "  Returns the status of the message on the ICC (read, unread, sent, unsent). ", "parameters": null}, {"returns": [{"scri": "the status of the message on the SIM.  These are:         SmsManager.STATUS_ON_SIM_FREE         SmsManager.STATUS_ON_SIM_READ         SmsManager.STATUS_ON_SIM_UNREAD         SmsManager.STATUS_ON_SIM_SEND         SmsManager.STATUS_ON_SIM_UNSENT", "type": "int"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "int", "name": "getStatusOnSim", "throws": null, "funcname": "int getStatusOnSim ()", "descri": "   This method was deprecated      in API level 4.    Use getStatusOnIcc instead.  Returns the status of the message on the SIM (read, unread, sent, unsent). ", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "static\n        \n        \n        int", "name": "getTPLayerLengthForPDU", "throws": null, "funcname": "int getTPLayerLengthForPDU (String pdu)", "descri": "  Get the TP-Layer-Length for the given SMS-SUBMIT PDU Basically, the length in bytes (not hex chars) less the SMSC header FIXME: This method is only used by a CTS test case that isn't run on CDMA devices. We should probably deprecate it and remove the obsolete test case.  ", "parameters": [{"scri": "String", "name": "pdu"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "boolean", "name": "isReplace", "throws": null, "funcname": "boolean isReplace ()", "descri": "  See TS 23.040 9.2.3.9 returns true if this is a \"replace short message\" SMS ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.telephony.SubscriptionManager.OnSubscriptionsChangedListener\n", "type": "boolean", "name": "isStatusReportMessage", "throws": null, "funcname": "boolean isStatusReportMessage ()", "descri": "  Return true iff the message is a SMS-STATUS-REPORT message. ", "parameters": null}, {"returns": [{"scri": "the default SMS subscription Id.", "type": "int"}], "class": "android.telephony.TelephonyManager\n", "type": "static\n        \n        \n        int", "name": "getDefaultSmsSubscriptionId", "throws": null, "funcname": "int getDefaultSmsSubscriptionId ()", "descri": "  Returns the system's default SMS subscription id. On a data only device or on error, will return INVALID_SUBSCRIPTION_ID. ", "parameters": null}, {"returns": null, "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        void", "name": "drag", "throws": null, "funcname": "void drag (InstrumentationTestCase test,                 float fromX,                 float toX,                 float fromY,                 float toY,                 int stepCount)", "descri": "  Simulate touching a specific location and dragging to a new location. ", "parameters": [{"scri": "InstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "float: X coordinate of the initial touch, in screen coordinates", "name": "fromX"}, {"scri": "float: Xcoordinate of the drag destination, in screen coordinates", "name": "toX"}, {"scri": "float: X coordinate of the initial touch, in screen coordinates", "name": "fromY"}, {"scri": "float: Y coordinate of the drag destination, in screen coordinates", "name": "toY"}, {"scri": "int: How many move steps to include in the drag", "name": "stepCount"}]}, {"returns": null, "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        void", "name": "drag", "throws": null, "funcname": "void drag (ActivityInstrumentationTestCase test,                 float fromX,                 float toX,                 float fromY,                 float toY,                 int stepCount)", "descri": "   This method was deprecated      in API level 3. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2, which provides more options for configuring the Activity under test  Simulate touching a specific location and dragging to a new location. ", "parameters": [{"scri": "ActivityInstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "float: X coordinate of the initial touch, in screen coordinates", "name": "fromX"}, {"scri": "float: Xcoordinate of the drag destination, in screen coordinates", "name": "toX"}, {"scri": "float: X coordinate of the initial touch, in screen coordinates", "name": "fromY"}, {"scri": "float: Y coordinate of the drag destination, in screen coordinates", "name": "toY"}, {"scri": "int: How many move steps to include in the drag", "name": "stepCount"}]}, {"returns": [{"scri": "distance in pixels covered by the drag", "type": "int"}], "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        int", "name": "dragViewTo", "throws": null, "funcname": "int dragViewTo (ActivityInstrumentationTestCase test,                 View v,                 int gravity,                 int toX,                 int toY)", "descri": "   This method was deprecated      in API level 3. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2, which provides more options for configuring the Activity under test  Simulate touching a view and dragging it to a specified location.  ", "parameters": [{"scri": "ActivityInstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "View: The view that should be dragged", "name": "v"}, {"scri": "int: Which part of the view to use for the initial down event. A combination of        (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)", "name": "gravity"}, {"scri": "int: Final location of the view after dragging", "name": "toX"}, {"scri": "int: Final location of the view after dragging", "name": "toY"}]}, {"returns": [{"scri": "distance in pixels covered by the drag", "type": "int"}], "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        int", "name": "dragViewTo", "throws": null, "funcname": "int dragViewTo (ActivityInstrumentationTestCase test,                 View v,                 int gravity,                 int toX,                 int toY)", "descri": "   This method was deprecated      in API level 3. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2, which provides more options for configuring the Activity under test  Simulate touching a view and dragging it to a specified location.  ", "parameters": [{"scri": "ActivityInstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "View: The view that should be dragged", "name": "v"}, {"scri": "int: Which part of the view to use for the initial down event. A combination of        (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)", "name": "gravity"}, {"scri": "int: Final location of the view after dragging", "name": "toX"}, {"scri": "int: Final location of the view after dragging", "name": "toY"}]}, {"returns": [{"scri": "distance in pixels covered by the drag", "type": "int"}], "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        int", "name": "dragViewTo", "throws": null, "funcname": "int dragViewTo (InstrumentationTestCase test,                 View v,                 int gravity,                 int toX,                 int toY)", "descri": "  Simulate touching a view and dragging it to a specified location.  ", "parameters": [{"scri": "InstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "View: The view that should be dragged", "name": "v"}, {"scri": "int: Which part of the view to use for the initial down event. A combination of        (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)", "name": "gravity"}, {"scri": "int: Final location of the view after dragging", "name": "toX"}, {"scri": "int: Final location of the view after dragging", "name": "toY"}]}, {"returns": [{"scri": "distance in pixels covered by the drag", "type": "int"}], "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        int", "name": "dragViewTo", "throws": null, "funcname": "int dragViewTo (InstrumentationTestCase test,                 View v,                 int gravity,                 int toX,                 int toY)", "descri": "  Simulate touching a view and dragging it to a specified location.  ", "parameters": [{"scri": "InstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "View: The view that should be dragged", "name": "v"}, {"scri": "int: Which part of the view to use for the initial down event. A combination of        (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)", "name": "gravity"}, {"scri": "int: Final location of the view after dragging", "name": "toX"}, {"scri": "int: Final location of the view after dragging", "name": "toY"}]}, {"returns": [{"scri": "distance in pixels covered by the drag", "type": "int"}], "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        int", "name": "dragViewToX", "throws": null, "funcname": "int dragViewToX (InstrumentationTestCase test,                 View v,                 int gravity,                 int toX)", "descri": "  Simulate touching a view and dragging it to a specified location. Only moves horizontally.  ", "parameters": [{"scri": "InstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "View: The view that should be dragged", "name": "v"}, {"scri": "int: Which part of the view to use for the initial down event. A combination of        (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)", "name": "gravity"}, {"scri": "int: Final location of the view after dragging", "name": "toX"}]}, {"returns": [{"scri": "distance in pixels covered by the drag", "type": "int"}], "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        int", "name": "dragViewToX", "throws": null, "funcname": "int dragViewToX (ActivityInstrumentationTestCase test,                 View v,                 int gravity,                 int toX)", "descri": "   This method was deprecated      in API level 3. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2, which provides more options for configuring the Activity under test  Simulate touching a view and dragging it to a specified location. Only moves horizontally.  ", "parameters": [{"scri": "ActivityInstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "View: The view that should be dragged", "name": "v"}, {"scri": "int: Which part of the view to use for the initial down event. A combination of        (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)", "name": "gravity"}, {"scri": "int: Final location of the view after dragging", "name": "toX"}]}, {"returns": [{"scri": "distance in pixels covered by the drag", "type": "int"}], "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        int", "name": "dragViewToY", "throws": null, "funcname": "int dragViewToY (ActivityInstrumentationTestCase test,                 View v,                 int gravity,                 int toY)", "descri": "   This method was deprecated      in API level 3. ActivityInstrumentationTestCase is deprecated in favor of ActivityInstrumentationTestCase2, which provides more options for configuring the Activity under test  Simulate touching a view and dragging it to a specified location. Only moves vertically.  ", "parameters": [{"scri": "ActivityInstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "View: The view that should be dragged", "name": "v"}, {"scri": "int: Which part of the view to use for the initial down event. A combination of        (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)", "name": "gravity"}, {"scri": "int: Final location of the view after dragging", "name": "toY"}]}, {"returns": [{"scri": "distance in pixels covered by the drag", "type": "int"}], "class": "android.test.ComparisonFailure\n", "type": "static\n        \n        \n        int", "name": "dragViewToY", "throws": null, "funcname": "int dragViewToY (InstrumentationTestCase test,                 View v,                 int gravity,                 int toY)", "descri": "  Simulate touching a view and dragging it to a specified location. Only moves vertically.  ", "parameters": [{"scri": "InstrumentationTestCase: The test case that is being run", "name": "test"}, {"scri": "View: The view that should be dragged", "name": "v"}, {"scri": "int: Which part of the view to use for the initial down event. A combination of        (TOP, CENTER_VERTICAL, BOTTOM) and (LEFT, CENTER_HORIZONTAL, RIGHT)", "name": "gravity"}, {"scri": "int: Final location of the view after dragging", "name": "toY"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertBaselineAligned", "throws": null, "funcname": "void assertBaselineAligned (View first,                 View second)", "descri": "  Assert that two views are aligned on their baseline, that is that their baselines are on the same y location. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertBottomAligned", "throws": null, "funcname": "void assertBottomAligned (View first,                 View second,                 int margin)", "descri": "  Assert that two views are bottom aligned, that is that their bottom edges are on the same y location, with respect to the specified margin. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}, {"scri": "int: The margin between the first view and the second view", "name": "margin"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertBottomAligned", "throws": null, "funcname": "void assertBottomAligned (View first,                 View second)", "descri": "  Assert that two views are bottom aligned, that is that their bottom edges are on the same y location. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertLeftAligned", "throws": null, "funcname": "void assertLeftAligned (View first,                 View second)", "descri": "  Assert that two views are left aligned, that is that their left edges are on the same x location. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertLeftAligned", "throws": null, "funcname": "void assertLeftAligned (View first,                 View second,                 int margin)", "descri": "  Assert that two views are left aligned, that is that their left edges are on the same x location, with respect to the specified margin. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}, {"scri": "int: The margin between the first view and the second view", "name": "margin"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertRightAligned", "throws": null, "funcname": "void assertRightAligned (View first,                 View second,                 int margin)", "descri": "  Assert that two views are right aligned, that is that their right edges are on the same x location, with respect to the specified margin. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}, {"scri": "int: The margin between the first view and the second view", "name": "margin"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertRightAligned", "throws": null, "funcname": "void assertRightAligned (View first,                 View second)", "descri": "  Assert that two views are right aligned, that is that their right edges are on the same x location. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertTopAligned", "throws": null, "funcname": "void assertTopAligned (View first,                 View second,                 int margin)", "descri": "  Assert that two views are top aligned, that is that their top edges are on the same y location, with respect to the specified margin. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}, {"scri": "int: The margin between the first view and the second view", "name": "margin"}]}, {"returns": null, "class": "android.test.mock.MockAccountManager\n", "type": "static\n        \n        \n        void", "name": "assertTopAligned", "throws": null, "funcname": "void assertTopAligned (View first,                 View second)", "descri": "  Assert that two views are top aligned, that is that their top edges are on the same y location. ", "parameters": [{"scri": "View: The first view", "name": "first"}, {"scri": "View: The second view", "name": "second"}]}, {"returns": [{"scri": "The number of rows affected.", "type": "int"}], "class": "android.test.mock.MockPackageManager\n", "type": "int", "name": "delete", "throws": null, "funcname": "int delete (Uri uri,                 String selection,                 String[] selectionArgs)", "descri": "  Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call notifyChange() after deleting. This method can be called from multiple threads, as described in Processes and Threads. The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in content://contacts/people/22 and the implementation is responsible for parsing the record number (22) when creating a SQL statement.  ", "parameters": [{"scri": "Uri: The full URI to query, including a row ID (if a specific record is requested).", "name": "uri"}, {"scri": "String: An optional restriction to apply to rows when deleting.", "name": "selection"}, {"scri": "String", "name": "selectionArgs"}]}, {"returns": [{"scri": "gsm location area code, -1 if unknown, 0xffff max legal value", "type": "int"}], "class": "android.test.UiThreadTest\n", "type": "int", "name": "getLac", "throws": null, "funcname": "int getLac ()", "descri": "   ", "parameters": null}, {"returns": null, "class": "android.test.UiThreadTest\n", "type": "void", "name": "setLacAndCid", "throws": null, "funcname": "void setLacAndCid (int lac,                 int cid)", "descri": "  Set the location area code and the cell id. ", "parameters": [{"scri": "int", "name": "lac"}, {"scri": "int", "name": "cid"}]}, {"returns": null, "class": "android.test.UiThreadTest\n", "type": "void", "name": "setStateInvalid", "throws": null, "funcname": "void setStateInvalid ()", "descri": "  Invalidate this object.  The location area code and the cell id are set to -1.", "parameters": null}, {"returns": null, "class": "android.text.InputFilter.AllCaps\n", "name": "DynamicLayout", "throws": null, "funcname": "DynamicLayout (CharSequence base,                 TextPaint paint,                 int width,                 Layout.Alignment align,                 float spacingmult,                 float spacingadd,                 boolean includepad)", "parameters": [{"scri": "CharSequence This value must never be null.", "name": "base"}, {"scri": "TextPaint This value must never be null.", "name": "paint"}, {"scri": "int", "name": "width"}, {"scri": "Layout.Alignment This value must never be null.", "name": "align"}, {"scri": "float Value is 0.0 or greater.", "name": "spacingmult"}, {"scri": "float", "name": "spacingadd"}, {"scri": "boolean", "name": "includepad"}], "descri": "   This constructor was deprecated      in API level P.    Use DynamicLayout.Builder instead.   "}, {"returns": null, "class": "android.text.InputFilter.AllCaps\n", "name": "DynamicLayout", "throws": null, "funcname": "DynamicLayout (CharSequence base,                 CharSequence display,                 TextPaint paint,                 int width,                 Layout.Alignment align,                 float spacingmult,                 float spacingadd,                 boolean includepad)", "parameters": [{"scri": "CharSequence This value must never be null.", "name": "base"}, {"scri": "CharSequence This value must never be null.", "name": "display"}, {"scri": "TextPaint This value must never be null.", "name": "paint"}, {"scri": "int", "name": "width"}, {"scri": "Layout.Alignment This value must never be null.", "name": "align"}, {"scri": "float Value is 0.0 or greater.", "name": "spacingmult"}, {"scri": "float", "name": "spacingadd"}, {"scri": "boolean", "name": "includepad"}], "descri": "   This constructor was deprecated      in API level P.    Use DynamicLayout.Builder instead.   "}, {"returns": null, "class": "android.text.InputFilter.AllCaps\n", "name": "DynamicLayout", "throws": null, "funcname": "DynamicLayout (CharSequence base,                 CharSequence display,                 TextPaint paint,                 int width,                 Layout.Alignment align,                 float spacingmult,                 float spacingadd,                 boolean includepad,                 TextUtils.TruncateAt ellipsize,                 int ellipsizedWidth)", "parameters": [{"scri": "CharSequence This value must never be null.", "name": "base"}, {"scri": "CharSequence This value must never be null.", "name": "display"}, {"scri": "TextPaint This value must never be null.", "name": "paint"}, {"scri": "int", "name": "width"}, {"scri": "Layout.Alignment This value must never be null.", "name": "align"}, {"scri": "float Value is 0.0 or greater.", "name": "spacingmult"}, {"scri": "float", "name": "spacingadd"}, {"scri": "boolean", "name": "includepad"}, {"scri": "TextUtils.TruncateAt This value may be null.", "name": "ellipsize"}, {"scri": "int", "name": "ellipsizedWidth"}], "descri": "   This constructor was deprecated      in API level P.    Use DynamicLayout.Builder instead.   "}, {"returns": null, "class": "android.text.InputFilter.AllCaps\n", "name": "DynamicLayout", "throws": null, "funcname": "DynamicLayout (CharSequence base,                 TextPaint paint,                 int width,                 Layout.Alignment align,                 float spacingmult,                 float spacingadd,                 boolean includepad)", "parameters": [{"scri": "CharSequence This value must never be null.", "name": "base"}, {"scri": "TextPaint This value must never be null.", "name": "paint"}, {"scri": "int", "name": "width"}, {"scri": "Layout.Alignment This value must never be null.", "name": "align"}, {"scri": "float Value is 0.0 or greater.", "name": "spacingmult"}, {"scri": "float", "name": "spacingadd"}, {"scri": "boolean", "name": "includepad"}], "descri": "   This constructor was deprecated      in API level P.    Use DynamicLayout.Builder instead.   "}, {"returns": null, "class": "android.text.InputFilter.AllCaps\n", "name": "DynamicLayout", "throws": null, "funcname": "DynamicLayout (CharSequence base,                 CharSequence display,                 TextPaint paint,                 int width,                 Layout.Alignment align,                 float spacingmult,                 float spacingadd,                 boolean includepad)", "parameters": [{"scri": "CharSequence This value must never be null.", "name": "base"}, {"scri": "CharSequence This value must never be null.", "name": "display"}, {"scri": "TextPaint This value must never be null.", "name": "paint"}, {"scri": "int", "name": "width"}, {"scri": "Layout.Alignment This value must never be null.", "name": "align"}, {"scri": "float Value is 0.0 or greater.", "name": "spacingmult"}, {"scri": "float", "name": "spacingadd"}, {"scri": "boolean", "name": "includepad"}], "descri": "   This constructor was deprecated      in API level P.    Use DynamicLayout.Builder instead.   "}, {"returns": null, "class": "android.text.InputFilter.AllCaps\n", "name": "DynamicLayout", "throws": null, "funcname": "DynamicLayout (CharSequence base,                 CharSequence display,                 TextPaint paint,                 int width,                 Layout.Alignment align,                 float spacingmult,                 float spacingadd,                 boolean includepad,                 TextUtils.TruncateAt ellipsize,                 int ellipsizedWidth)", "parameters": [{"scri": "CharSequence This value must never be null.", "name": "base"}, {"scri": "CharSequence This value must never be null.", "name": "display"}, {"scri": "TextPaint This value must never be null.", "name": "paint"}, {"scri": "int", "name": "width"}, {"scri": "Layout.Alignment This value must never be null.", "name": "align"}, {"scri": "float Value is 0.0 or greater.", "name": "spacingmult"}, {"scri": "float", "name": "spacingadd"}, {"scri": "boolean", "name": "includepad"}, {"scri": "TextUtils.TruncateAt This value may be null.", "name": "ellipsize"}, {"scri": "int", "name": "ellipsizedWidth"}], "descri": "   This constructor was deprecated      in API level P.    Use DynamicLayout.Builder instead.   "}, {"returns": [{"scri": "", "type": "float"}], "class": "android.text.LoginFilter.UsernameFilterGeneric\n", "type": "float", "name": "getPrimaryHorizontal", "throws": null, "funcname": "float getPrimaryHorizontal (int offset)", "descri": "  Get the primary horizontal position for the specified text offset. This is the location where a new character would be inserted in the paragraph's primary direction.  ", "parameters": [{"scri": "int", "name": "offset"}]}, {"returns": [{"scri": "", "type": "float"}], "class": "android.text.LoginFilter.UsernameFilterGeneric\n", "type": "float", "name": "getSecondaryHorizontal", "throws": null, "funcname": "float getSecondaryHorizontal (int offset)", "descri": "  Get the secondary horizontal position for the specified text offset. This is the location where a new character would be inserted in the direction other than the paragraph's primary direction.  ", "parameters": [{"scri": "int", "name": "offset"}]}, {"returns": null, "class": "android.text.method.TextKeyListener\n", "type": "static\n        \n        \n        void", "name": "markAsReplaced", "throws": null, "funcname": "void markAsReplaced (Spannable content,                 int start,                 int end,                 String original)", "descri": "  Marks the specified region of content as having contained original prior to AutoText replacement. Call this method when you have done or are about to do an AutoText-style replacement on a region of text and want to let the same mechanism (the user pressing DEL immediately after the change) undo the replacement. ", "parameters": [{"scri": "Spannable: the Editable text where the replacement was made", "name": "content"}, {"scri": "int: the start of the replaced region", "name": "start"}, {"scri": "int: the end of the replaced region; the location of the cursor", "name": "end"}, {"scri": "String: the text to be restored if the user presses DEL", "name": "original"}]}, {"returns": null, "class": "android.transition.Transition\n", "type": "static\n        \n        \n        Scene", "name": "Scene", "throws": null, "funcname": "Scene (ViewGroup sceneRoot)", "descri": "  Constructs a Scene with no information about how values will change when this scene is applied. This constructor might be used when a Scene is created with the intention of being dynamically configured, through setting setEnterAction(Runnable) and possibly setExitAction(Runnable). ", "parameters": [{"scri": "ViewGroup: The root of the hierarchy in which scene changes and transitions will take place.", "name": "sceneRoot"}]}, {"returns": null, "class": "android.transition.Transition\n", "name": "Scene", "throws": null, "funcname": "Scene (ViewGroup sceneRoot)", "parameters": [{"scri": "ViewGroup: The root of the hierarchy in which scene changes and transitions will take place.", "name": "sceneRoot"}], "descri": "  Constructs a Scene with no information about how values will change when this scene is applied. This constructor might be used when a Scene is created with the intention of being dynamically configured, through setting setEnterAction(Runnable) and possibly setExitAction(Runnable). "}, {"returns": null, "class": "android.transition.Transition\n", "name": "Scene", "throws": null, "funcname": "Scene (ViewGroup sceneRoot)", "parameters": [{"scri": "ViewGroup: The root of the hierarchy in which scene changes and transitions will take place.", "name": "sceneRoot"}], "descri": "  Constructs a Scene with no information about how values will change when this scene is applied. This constructor might be used when a Scene is created with the intention of being dynamically configured, through setting setEnterAction(Runnable) and possibly setExitAction(Runnable). "}, {"returns": null, "class": "android.util.Base64OutputStream\n", "type": "void", "name": "delete", "throws": null, "funcname": "void delete ()", "descri": "  Delete the atomic file.  This deletes both the base and backup files.", "parameters": null}, {"returns": null, "class": "android.util.Base64OutputStream\n", "type": "void", "name": "finishWrite", "throws": null, "funcname": "void finishWrite (FileOutputStream str)", "descri": "  Call when you have successfully finished writing to the stream returned by startWrite().  This will close, sync, and commit the new data.  The next attempt to read the atomic file will return the new file stream. ", "parameters": [{"scri": "FileOutputStream", "name": "str"}]}, {"returns": null, "class": "android.util.Base64OutputStream\n", "name": "AtomicFile", "throws": null, "funcname": "AtomicFile (File baseName)", "parameters": [{"scri": "File", "name": "baseName"}], "descri": "  Create a new AtomicFile for a file located at the given File path. The secondary backup file will be the same file path with \".bak\" appended. "}, {"returns": null, "class": "android.util.Base64OutputStream\n", "name": "AtomicFile", "throws": null, "funcname": "AtomicFile (File baseName)", "parameters": [{"scri": "File", "name": "baseName"}], "descri": "  Create a new AtomicFile for a file located at the given File path. The secondary backup file will be the same file path with \".bak\" appended. "}, {"returns": null, "class": "android.util.SparseLongArray\n", "type": "SparseArray<E>", "name": "SparseArray", "throws": null, "funcname": "SparseArray (int initialCapacity)", "descri": "  Creates a new SparseArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. ", "parameters": [{"scri": "int", "name": "initialCapacity"}]}, {"returns": null, "class": "android.util.SparseLongArray\n", "name": "SparseArray", "throws": null, "funcname": "SparseArray (int initialCapacity)", "parameters": [{"scri": "int", "name": "initialCapacity"}], "descri": "  Creates a new SparseArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. "}, {"returns": null, "class": "android.util.SparseLongArray\n", "name": "SparseArray", "throws": null, "funcname": "SparseArray (int initialCapacity)", "parameters": [{"scri": "int", "name": "initialCapacity"}], "descri": "  Creates a new SparseArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. "}, {"returns": null, "class": "android.util.StateSet\n", "type": "SparseBooleanArray", "name": "SparseBooleanArray", "throws": null, "funcname": "SparseBooleanArray (int initialCapacity)", "descri": "  Creates a new SparseBooleanArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. ", "parameters": [{"scri": "int", "name": "initialCapacity"}]}, {"returns": null, "class": "android.util.StateSet\n", "name": "SparseBooleanArray", "throws": null, "funcname": "SparseBooleanArray (int initialCapacity)", "parameters": [{"scri": "int", "name": "initialCapacity"}], "descri": "  Creates a new SparseBooleanArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. "}, {"returns": null, "class": "android.util.StateSet\n", "name": "SparseBooleanArray", "throws": null, "funcname": "SparseBooleanArray (int initialCapacity)", "parameters": [{"scri": "int", "name": "initialCapacity"}], "descri": "  Creates a new SparseBooleanArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. "}, {"returns": null, "class": "android.util.StatsLog\n", "type": "SparseIntArray", "name": "SparseIntArray", "throws": null, "funcname": "SparseIntArray (int initialCapacity)", "descri": "  Creates a new SparseIntArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. ", "parameters": [{"scri": "int", "name": "initialCapacity"}]}, {"returns": null, "class": "android.util.StatsLog\n", "name": "SparseIntArray", "throws": null, "funcname": "SparseIntArray (int initialCapacity)", "parameters": [{"scri": "int", "name": "initialCapacity"}], "descri": "  Creates a new SparseIntArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. "}, {"returns": null, "class": "android.util.StatsLog\n", "name": "SparseIntArray", "throws": null, "funcname": "SparseIntArray (int initialCapacity)", "parameters": [{"scri": "int", "name": "initialCapacity"}], "descri": "  Creates a new SparseIntArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. "}, {"returns": null, "class": "android.util.StringBuilderPrinter\n", "type": "SparseLongArray", "name": "SparseLongArray", "throws": null, "funcname": "SparseLongArray (int initialCapacity)", "descri": "  Creates a new SparseLongArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. ", "parameters": [{"scri": "int", "name": "initialCapacity"}]}, {"returns": null, "class": "android.util.StringBuilderPrinter\n", "name": "SparseLongArray", "throws": null, "funcname": "SparseLongArray (int initialCapacity)", "parameters": [{"scri": "int", "name": "initialCapacity"}], "descri": "  Creates a new SparseLongArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. "}, {"returns": null, "class": "android.util.StringBuilderPrinter\n", "name": "SparseLongArray", "throws": null, "funcname": "SparseLongArray (int initialCapacity)", "parameters": [{"scri": "int", "name": "initialCapacity"}], "descri": "  Creates a new SparseLongArray containing no mappings that will not require any additional memory allocation to store the specified number of mappings.  If you supply an initial capacity of 0, the sparse array will be initialized with a light-weight representation not requiring any additional array allocations. "}, {"returns": [{"scri": "The text selection end, the cursor location if there is no selection, or -1 if         there is no text selection and no cursor.", "type": "int"}], "class": "android.view.accessibility.AccessibilityNodeInfo.RangeInfo\n", "type": "int", "name": "getTextSelectionEnd", "throws": null, "funcname": "int getTextSelectionEnd ()", "descri": "  Gets the text selection end if text is selected. If no text is selected, both this method and getTextSelectionStart() return the same value: the current location of the cursor. ", "parameters": null}, {"returns": [{"scri": "The text selection start, the cursor location if there is no selection, or -1 if         there is no text selection and no cursor.", "type": "int"}], "class": "android.view.accessibility.AccessibilityNodeInfo.RangeInfo\n", "type": "int", "name": "getTextSelectionStart", "throws": null, "funcname": "int getTextSelectionStart ()", "descri": "  Gets the text selection start or the cursor position. If no text is selected, both this method and getTextSelectionEnd() return the same value: the current location of the cursor. ", "parameters": null}, {"returns": [{"scri": "true on success, false if the input connection is no longer valid.", "type": "boolean"}], "class": "android.view.inputmethod.CursorAnchorInfo\n", "type": "boolean", "name": "commitText", "throws": null, "funcname": "boolean commitText (CharSequence text,                 int newCursorPosition)", "descri": "  Default implementation replaces any existing composing text with the given text.  In addition, only if dummy mode, a key event is sent for the new text and the current editable buffer cleared.  ", "parameters": [{"scri": "CharSequence: The text to commit. This may include styles.", "name": "text"}, {"scri": "int: The new cursor position around the text,        in Java characters. If > 0, this is relative to the end        of the text - 1; if <= 0, this is relative to the start        of the text. So a value of 1 will always advance the cursor        to the position after the full text being inserted. Note that        this means you can't position the cursor within the text,        because the editor can make modifications to the text        you are providing so it is not possible to correctly specify        locations there.", "name": "newCursorPosition"}]}, {"returns": [{"scri": "true on success, false if the input connection is no longer valid.", "type": "boolean"}], "class": "android.view.inputmethod.CursorAnchorInfo\n", "type": "boolean", "name": "setComposingText", "throws": null, "funcname": "boolean setComposingText (CharSequence text,                 int newCursorPosition)", "descri": "  The default implementation places the given text into the editable, replacing any existing composing text.  The new text is marked as in a composing state with the composing style.  ", "parameters": [{"scri": "CharSequence: The composing text with styles if necessary. If no style        object attached to the text, the default style for composing text        is used. See Spanned for how to attach style        object to the text. SpannableString and        SpannableStringBuilder are two        implementations of the interface Spanned.", "name": "text"}, {"scri": "int: The new cursor position around the text. If        > 0, this is relative to the end of the text - 1; if <= 0, this        is relative to the start of the text. So a value of 1 will        always advance you to the position after the full text being        inserted. Note that this means you can't position the cursor        within the text, because the editor can make modifications to        the text you are providing so it is not possible to correctly        specify locations there.", "name": "newCursorPosition"}]}, {"returns": null, "class": "android.view.inputmethod.InputMethod\n", "type": "void", "name": "notifyViewEntered", "throws": null, "funcname": "void notifyViewEntered (View view,                 int virtualId,                 Rect absBounds)", "descri": "  Called when a virtual view that supports autofill is entered. The virtual view boundaries must be absolute screen coordinates. For example, if the parent, non-virtual view uses bounds to draw the virtual view inside its Canvas, the absolute bounds could be calculated by: int offset[] = new int[2];   getLocationOnScreen(offset);   Rect absBounds = new Rect(bounds.left + offset[0],       bounds.top + offset[1],       bounds.right + offset[0], bounds.bottom + offset[1]); ", "parameters": [{"scri": "View: the virtual view parent.This value must never be null.", "name": "view"}, {"scri": "int: id identifying the virtual child inside the parent view.", "name": "virtualId"}, {"scri": "Rect: absolute boundaries of the virtual view in the screen.This value must never be null.", "name": "absBounds"}]}, {"returns": null, "class": "android.view.inputmethod.InputMethod\n", "type": "void", "name": "requestAutofill", "throws": null, "funcname": "void requestAutofill (View view,                 int virtualId,                 Rect absBounds)", "descri": "  Explicitly requests a new autofill context for virtual views. Normally, the autofill context is automatically started if necessary when notifyViewEntered(View, int, Rect) is called, but this method should be used in the cases where it must be explicitly started. For example, when the virtual view offers an AUTOFILL option on its contextual overflow menu, and the user selects it. The virtual view boundaries must be absolute screen coordinates. For example, if the parent view uses bounds to draw the virtual view inside its Canvas, the absolute bounds could be calculated by: int offset[] = new int[2];   getLocationOnScreen(offset);   Rect absBounds = new Rect(bounds.left + offset[0],       bounds.top + offset[1],       bounds.right + offset[0], bounds.bottom + offset[1]); ", "parameters": [{"scri": "View: the virtual view parent.This value must never be null.", "name": "view"}, {"scri": "int: id identifying the virtual child inside the parent view.", "name": "virtualId"}, {"scri": "Rect: absolute boundaries of the virtual view in the screen.This value must never be null.", "name": "absBounds"}]}, {"returns": [{"scri": "true on success, false if the input connection is no longer valid.", "type": "boolean"}], "class": "android.view.inputmethod.InputMethodSession.EventCallback\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "commitText", "throws": null, "funcname": "boolean commitText (CharSequence text,                 int newCursorPosition)", "descri": "  Commit text to the text box and set the new cursor position. This method removes the contents of the currently composing text and replaces it with the passed CharSequence, and then moves the cursor according to newCursorPosition. If there is no composing text when this method is called, the new text is inserted at the cursor position, removing text inside the selection if any. This behaves like calling setComposingText(text, newCursorPosition) then finishComposingText().  Calling this method will cause the editor to call onUpdateSelection(int, int, int, int, int, int) on the current IME after the batch input is over. Editor authors, for this to happen you need to make the changes known to the input method by calling updateSelection(View, int, int, int, int), but be careful to wait until the batch edit is over if one is in progress.  ", "parameters": [{"scri": "CharSequence: The text to commit. This may include styles.", "name": "text"}, {"scri": "int: The new cursor position around the text,        in Java characters. If > 0, this is relative to the end        of the text - 1; if <= 0, this is relative to the start        of the text. So a value of 1 will always advance the cursor        to the position after the full text being inserted. Note that        this means you can't position the cursor within the text,        because the editor can make modifications to the text        you are providing so it is not possible to correctly specify        locations there.", "name": "newCursorPosition"}]}, {"returns": [{"scri": "true if the request is scheduled. false to indicate that when the application will not call updateCursorAnchorInfo(android.view.View, CursorAnchorInfo). In N and later, returns false also when the target application does not implement this method.", "type": "boolean"}], "class": "android.view.inputmethod.InputMethodSession.EventCallback\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "requestCursorUpdates", "throws": null, "funcname": "boolean requestCursorUpdates (int cursorUpdateMode)", "descri": "  Called by the input method to ask the editor for calling back updateCursorAnchorInfo(android.view.View, CursorAnchorInfo) to notify cursor/anchor locations.  ", "parameters": [{"scri": "int: CURSOR_UPDATE_IMMEDIATE and/or CURSOR_UPDATE_MONITOR. Pass 0 to disable the effect of CURSOR_UPDATE_MONITOR.", "name": "cursorUpdateMode"}]}, {"returns": [{"scri": "true on success, false if the input connection is no longer valid.", "type": "boolean"}], "class": "android.view.inputmethod.InputMethodSession.EventCallback\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "setComposingText", "throws": null, "funcname": "boolean setComposingText (CharSequence text,                 int newCursorPosition)", "descri": "  Replace the currently composing text with the given text, and set the new cursor position. Any composing text set previously will be removed automatically. If there is any composing span currently active, all characters that it comprises are removed. The passed text is added in its place, and a composing span is added to this text. If there is no composing span active, the passed text is added at the cursor position (removing selected characters first if any), and a composing span is added on the new text. Finally, the cursor is moved to the location specified by newCursorPosition.  This is usually called by IMEs to add or remove or change characters in the composing span. Calling this method will cause the editor to call onUpdateSelection(int, int, int, int, int, int) on the current IME after the batch input is over.  Editor authors: please keep in mind the text may be very similar or completely different than what was in the composing span at call time, or there may not be a composing span at all. Please note that although it's not typical use, the string may be empty. Treat this normally, replacing the currently composing text with an empty string. Also, be careful with the cursor position. IMEs rely on this working exactly as described above. Since this changes the contents of the editor, you need to make the changes known to the input method by calling updateSelection(View, int, int, int, int), but be careful to wait until the batch edit is over if one is in progress. Note that this method can set the cursor position on either edge of the composing text or entirely outside it, but the IME may also go on to move the cursor position to within the composing text in a subsequent call so you should make no assumption at all: the composing text and the selection are entirely independent.  ", "parameters": [{"scri": "CharSequence: The composing text with styles if necessary. If no style        object attached to the text, the default style for composing text        is used. See Spanned for how to attach style        object to the text. SpannableString and        SpannableStringBuilder are two        implementations of the interface Spanned.", "name": "text"}, {"scri": "int: The new cursor position around the text. If        > 0, this is relative to the end of the text - 1; if <= 0, this        is relative to the start of the text. So a value of 1 will        always advance you to the position after the full text being        inserted. Note that this means you can't position the cursor        within the text, because the editor can make modifications to        the text you are providing so it is not possible to correctly        specify locations there.", "name": "newCursorPosition"}]}, {"returns": [{"scri": "Whether the device has a built-in microphone.", "type": "boolean"}], "class": "android.view.KeyboardShortcutGroup\n", "type": "boolean", "name": "hasMicrophone", "throws": null, "funcname": "boolean hasMicrophone ()", "descri": "  Reports whether the device has a built-in microphone. ", "parameters": null}, {"returns": null, "class": "android.view.OrientationListener\n", "type": "void", "name": "addBatch", "throws": null, "funcname": "void addBatch (long eventTime,                 PointerCoords[] pointerCoords,                 int metaState)", "descri": "  Add a new movement to the batch of movements in this event.  The event's current location, position and size is updated to the new values. The current values in the event are added to a list of historical values. Only applies to ACTION_MOVE or ACTION_HOVER_MOVE events. ", "parameters": [{"scri": "long: The time stamp (in ms) for this data.", "name": "eventTime"}, {"scri": "PointerCoords: The new pointer coordinates.", "name": "pointerCoords"}, {"scri": "int: Meta key state.", "name": "metaState"}]}, {"returns": null, "class": "android.view.OrientationListener\n", "type": "void", "name": "addBatch", "throws": null, "funcname": "void addBatch (long eventTime,                 float x,                 float y,                 float pressure,                 float size,                 int metaState)", "descri": "  Add a new movement to the batch of movements in this event.  The event's current location, position and size is updated to the new values. The current values in the event are added to a list of historical values. Only applies to ACTION_MOVE or ACTION_HOVER_MOVE events. ", "parameters": [{"scri": "long: The time stamp (in ms) for this data.", "name": "eventTime"}, {"scri": "float: The new X position.", "name": "x"}, {"scri": "float: The new Y position.", "name": "y"}, {"scri": "float: The new pressure.", "name": "pressure"}, {"scri": "float: The new size.", "name": "size"}, {"scri": "int: Meta key state.", "name": "metaState"}]}, {"returns": [{"scri": "", "type": "float"}], "class": "android.view.OrientationListener\n", "type": "float", "name": "getRawX", "throws": null, "funcname": "float getRawX ()", "descri": "  Returns the original raw X coordinate of this event.  For touch events on the screen, this is the original location of the event on the screen, before it had been adjusted for the containing window and views.   See also: getX(int)AXIS_X", "parameters": null}, {"returns": [{"scri": "", "type": "float"}], "class": "android.view.OrientationListener\n", "type": "float", "name": "getRawY", "throws": null, "funcname": "float getRawY ()", "descri": "  Returns the original raw Y coordinate of this event.  For touch events on the screen, this is the original location of the event on the screen, before it had been adjusted for the containing window and views.   See also: getY(int)AXIS_Y", "parameters": null}, {"returns": null, "class": "android.view.OrientationListener\n", "type": "void", "name": "offsetLocation", "throws": null, "funcname": "void offsetLocation (float deltaX,                 float deltaY)", "descri": "  Adjust this event's location. ", "parameters": [{"scri": "float: Amount to add to the current X coordinate of the event.", "name": "deltaX"}, {"scri": "float: Amount to add to the current Y coordinate of the event.", "name": "deltaY"}]}, {"returns": null, "class": "android.view.OrientationListener\n", "type": "void", "name": "setLocation", "throws": null, "funcname": "void setLocation (float x,                 float y)", "descri": "  Set this event's location.  Applies offsetLocation(float, float) with a delta from the current location to the given new location. ", "parameters": [{"scri": "float: New absolute X location.", "name": "x"}, {"scri": "float: New absolute Y location.", "name": "y"}]}, {"returns": null, "class": "android.view.OrientationListener\n", "type": "void", "name": "setLocation", "throws": null, "funcname": "void setLocation (float x,                 float y)", "descri": "  Set this event's location.  Applies offsetLocation(float, float) with a delta from the current location to the given new location. ", "parameters": [{"scri": "float: New absolute X location.", "name": "x"}, {"scri": "float: New absolute Y location.", "name": "y"}]}, {"returns": null, "class": "android.view.ScaleGestureDetector.SimpleOnScaleGestureListener\n", "type": "void", "name": "onSensorChanged", "throws": null, "funcname": "void onSensorChanged (int sensor,                 float[] values)", "descri": "   Called when sensor values have changed. The length and contents of the values array vary depending on which sensor is being monitored. See SensorManager for details on possible sensor types. Definition of the coordinate system used below.  The X axis refers to the screen's horizontal axis (the small edge in portrait mode, the long edge in landscape mode) and points to the right. The Y axis refers to the screen's vertical axis and points towards the top of the screen (the origin is in the lower-left corner). The Z axis points toward the sky when the device is lying on its back on a table. IMPORTANT NOTE: The axis are swapped when the device's screen orientation changes. To access the unswapped values, use indices 3, 4 and 5 in values[]. SENSOR_ORIENTATION, SENSOR_ORIENTATION_RAW: All values are angles in degrees. values[0]: Azimuth, rotation around the Z axis (0<=azimuth<360). 0 = North, 90 = East, 180 = South, 270 = West values[1]: Pitch, rotation around X axis (-180<=pitch<=180), with positive values when the z-axis moves toward the y-axis. values[2]: Roll, rotation around Y axis (-90<=roll<=90), with positive values when the z-axis moves toward the x-axis. Note that this definition of yaw, pitch and roll is different from the traditional definition used in aviation where the X axis is along the long side of the plane (tail to nose). SENSOR_ACCELEROMETER: All values are in SI units (m/s^2) and measure contact forces. values[0]: force applied by the device on the x-axis values[1]: force applied by the device on the y-axis values[2]: force applied by the device on the z-axis Examples: When the device is pushed on its left side toward the right, the    x acceleration value is negative (the device applies a reaction force    to the push toward the left)  When the device lies flat on a table, the acceleration value is    -STANDARD_GRAVITY,    which correspond to the force the device applies on the table in reaction    to gravity.  SENSOR_MAGNETIC_FIELD: All values are in micro-Tesla (uT) and measure the ambient magnetic  field in the X, Y and -Z axis. Note: the magnetic field's Z axis is inverted. ", "parameters": [{"scri": "int: The ID of the sensor being monitored", "name": "sensor"}, {"scri": "float: The new values for the sensor.", "name": "values"}]}, {"returns": null, "class": "android.view.ViewDebug\n", "type": "void", "name": "onProvideShadowMetrics", "throws": null, "funcname": "void onProvideShadowMetrics (Point outShadowSize,                 Point outShadowTouchPoint)", "descri": "  Provides the metrics for the shadow image. These include the dimensions of the shadow image, and the point within that shadow that should be centered under the touch location while dragging. The default implementation sets the dimensions of the shadow to be the same as the dimensions of the View itself and centers the shadow under the touch point. ", "parameters": [{"scri": "Point: A Point containing the width and height of the shadow image. Your application must set x to the desired width and must set y to the desired height of the image.", "name": "outShadowSize"}, {"scri": "Point: A Point for the position within the shadow image that should be underneath the touch point during the drag and drop operation. Your application must set x to the X coordinate and y to the Y coordinate of this position.", "name": "outShadowTouchPoint"}]}, {"returns": null, "class": "android.view.ViewPropertyAnimator\n", "type": "void", "name": "add", "throws": null, "funcname": "void add (View view)", "descri": "  Adds a View to the overlay. The bounds of the added view should be relative to the host view. Any view added to the overlay should be removed when it is no longer needed or no longer visible. Views in the overlay are visual-only; they do not receive input events and do not participate in focus traversal. Overlay views are intended to be transient, such as might be needed by a temporary animation effect.  If the view has a parent, the view will be removed from that parent before being added to the overlay. Also, if that parent is attached in the current view hierarchy, the view will be repositioned such that it is in the same relative location inside the activity. For example, if the view's current parent lies 100 pixels to the right and 200 pixels down from the origin of the overlay's host view, then the view will be offset by (100, 200).  Views added with this API will be drawn in the order they were added. Drawing of the overlay views will happen before drawing of any of the Drawables added with add(Drawable) API even if a call to this API happened after the call to add(Drawable).  Passing null parameter will result in an IllegalArgumentException being thrown.   See also: remove(View)add(Drawable)", "parameters": [{"scri": "View: The View to be added to the overlay. The added view will be drawn when the overlay is drawn.This value must never be null.", "name": "view"}]}, {"returns": null, "class": "android.webkit.PermissionRequest\n", "type": "void", "name": "allow", "throws": null, "funcname": "void allow (String origin)", "descri": "  Allows the specified origin to use the Geolocation API. ", "parameters": [{"scri": "String: the origin for which Geolocation API use is allowed", "name": "origin"}]}, {"returns": null, "class": "android.webkit.PermissionRequest\n", "type": "void", "name": "clear", "throws": null, "funcname": "void clear (String origin)", "descri": "  Clears the Geolocation permission state for the specified origin. ", "parameters": [{"scri": "String: the origin for which Geolocation permissions are cleared", "name": "origin"}]}, {"returns": null, "class": "android.webkit.PermissionRequest\n", "type": "void", "name": "clearAll", "throws": null, "funcname": "void clearAll ()", "descri": "  Clears the Geolocation permission state for all origins.", "parameters": null}, {"returns": null, "class": "android.webkit.PermissionRequest\n", "type": "void", "name": "getAllowed", "throws": null, "funcname": "void getAllowed (String origin,                 ValueCallback<Boolean> callback)", "descri": "  Gets the Geolocation permission state for the specified origin. ", "parameters": [{"scri": "String: the origin for which Geolocation permission is requested", "name": "origin"}, {"scri": "ValueCallback: a ValueCallback to receive the result of this                 request. This object's                 onReceiveValue()                 method will be invoked asynchronously with a boolean                 indicating whether or not the origin can use the                 Geolocation API.", "name": "callback"}]}, {"returns": null, "class": "android.webkit.PermissionRequest\n", "type": "void", "name": "getAllowed", "throws": null, "funcname": "void getAllowed (String origin,                 ValueCallback<Boolean> callback)", "descri": "  Gets the Geolocation permission state for the specified origin. ", "parameters": [{"scri": "String: the origin for which Geolocation permission is requested", "name": "origin"}, {"scri": "ValueCallback: a ValueCallback to receive the result of this                 request. This object's                 onReceiveValue()                 method will be invoked asynchronously with a boolean                 indicating whether or not the origin can use the                 Geolocation API.", "name": "callback"}]}, {"returns": null, "class": "android.webkit.PermissionRequest\n", "type": "void", "name": "getOrigins", "throws": null, "funcname": "void getOrigins (ValueCallback<Set<String>> callback)", "descri": "  Gets the set of origins for which Geolocation permissions are stored. ", "parameters": [{"scri": "ValueCallback: a ValueCallback to receive the result of this                 request. This object's                 onReceiveValue()                 method will be invoked asynchronously with a set of                 Strings containing the origins for which Geolocation                 permissions are stored.", "name": "callback"}]}, {"returns": null, "class": "android.webkit.WebIconDatabase.IconListener\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "invoke", "throws": null, "funcname": "void invoke (String origin,                 boolean allow,                 boolean retain)", "descri": "  Sets the Geolocation permission state for the supplied origin. ", "parameters": [{"scri": "String: the origin for which permissions are set", "name": "origin"}, {"scri": "boolean: whether or not the origin should be allowed to use the              Geolocation API", "name": "allow"}, {"scri": "boolean: whether the permission should be retained beyond the               lifetime of a page currently being displayed by a               WebView", "name": "retain"}]}, {"returns": [{"scri": "The current index from 0...n or -1 if the list is empty.", "type": "int"}], "class": "android.webkit.WebMessage\n", "type": "abstract\n        \n        \n        \n        \n        int", "name": "getCurrentIndex", "throws": null, "funcname": "int getCurrentIndex ()", "descri": "  Get the index of the current history item. This index can be used to directly index into the array list. ", "parameters": null}, {"returns": [{"scri": "a clone of this instance.", "type": "WebHistoryItem"}], "class": "android.webkit.WebMessagePort.WebMessageCallback\n", "type": "abstract\n        \n        \n        \n        \n        WebHistoryItem", "name": "clone", "throws": null, "funcname": "WebHistoryItem clone ()", "descri": "  Clone the history item for use by clients of WebView. ", "parameters": null}, {"returns": null, "class": "android.widget.ActionMenuView\n", "name": "AbsoluteLayout.LayoutParams", "throws": null, "funcname": "AbsoluteLayout.LayoutParams (int width,                 int height,                 int x,                 int y)", "parameters": [{"scri": "int: the width, either MATCH_PARENT,                  WRAP_CONTENT or a fixed size in pixels", "name": "width"}, {"scri": "int: the height, either MATCH_PARENT,                  WRAP_CONTENT or a fixed size in pixels", "name": "height"}, {"scri": "int: the X location of the child", "name": "x"}, {"scri": "int: the Y location of the child", "name": "y"}], "descri": "  Creates a new set of layout parameters with the specified width, height and location. "}, {"returns": null, "class": "android.widget.ActionMenuView\n", "name": "AbsoluteLayout.LayoutParams", "throws": null, "funcname": "AbsoluteLayout.LayoutParams (int width,                 int height,                 int x,                 int y)", "parameters": [{"scri": "int: the width, either MATCH_PARENT,                  WRAP_CONTENT or a fixed size in pixels", "name": "width"}, {"scri": "int: the height, either MATCH_PARENT,                  WRAP_CONTENT or a fixed size in pixels", "name": "height"}, {"scri": "int: the X location of the child", "name": "x"}, {"scri": "int: the Y location of the child", "name": "y"}], "descri": "  Creates a new set of layout parameters with the specified width, height and location. "}, {"returns": null, "class": "android.widget.ActionMenuView\n", "name": "AbsoluteLayout.LayoutParams", "throws": null, "funcname": "AbsoluteLayout.LayoutParams (Context c,                 AttributeSet attrs)", "parameters": [{"scri": "Context: the application environment", "name": "c"}, {"scri": "AttributeSet: the set of attributes from which to extract the layout              parameters values", "name": "attrs"}], "descri": "  Creates a new set of layout parameters. The values are extracted from the supplied attributes set and context. The XML attributes mapped to this set of layout parameters are: layout_x: the X location of the child layout_y: the Y location of the child All the XML attributes from   ViewGroup.LayoutParams "}, {"returns": null, "class": "android.widget.ActionMenuView\n", "name": "AbsoluteLayout.LayoutParams", "throws": null, "funcname": "AbsoluteLayout.LayoutParams (int width,                 int height,                 int x,                 int y)", "parameters": [{"scri": "int: the width, either MATCH_PARENT,                  WRAP_CONTENT or a fixed size in pixels", "name": "width"}, {"scri": "int: the height, either MATCH_PARENT,                  WRAP_CONTENT or a fixed size in pixels", "name": "height"}, {"scri": "int: the X location of the child", "name": "x"}, {"scri": "int: the Y location of the child", "name": "y"}], "descri": "  Creates a new set of layout parameters with the specified width, height and location. "}, {"returns": null, "class": "android.widget.ActionMenuView\n", "name": "AbsoluteLayout.LayoutParams", "throws": null, "funcname": "AbsoluteLayout.LayoutParams (int width,                 int height,                 int x,                 int y)", "parameters": [{"scri": "int: the width, either MATCH_PARENT,                  WRAP_CONTENT or a fixed size in pixels", "name": "width"}, {"scri": "int: the height, either MATCH_PARENT,                  WRAP_CONTENT or a fixed size in pixels", "name": "height"}, {"scri": "int: the X location of the child", "name": "x"}, {"scri": "int: the Y location of the child", "name": "y"}], "descri": "  Creates a new set of layout parameters with the specified width, height and location. "}, {"returns": null, "class": "android.widget.ActionMenuView\n", "name": "AbsoluteLayout.LayoutParams", "throws": null, "funcname": "AbsoluteLayout.LayoutParams (Context c,                 AttributeSet attrs)", "parameters": [{"scri": "Context: the application environment", "name": "c"}, {"scri": "AttributeSet: the set of attributes from which to extract the layout              parameters values", "name": "attrs"}], "descri": "  Creates a new set of layout parameters. The values are extracted from the supplied attributes set and context. The XML attributes mapped to this set of layout parameters are: layout_x: the X location of the child layout_y: the Y location of the child All the XML attributes from   ViewGroup.LayoutParams "}, {"returns": [{"scri": "Returns a Parcelable object containing the view's current dynamic         state, or null if there is nothing interesting to save.", "type": "Parcelable"}], "class": "android.widget.ExpandableListView\n", "type": "Parcelable", "name": "onSaveInstanceState", "throws": null, "funcname": "Parcelable onSaveInstanceState ()", "descri": "  Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view. ", "parameters": null}, {"returns": [{"scri": "Returns a Parcelable object containing the view's current dynamic         state, or null if there is nothing interesting to save.", "type": "Parcelable"}], "class": "android.widget.LinearLayout\n", "type": "Parcelable", "name": "onSaveInstanceState", "throws": null, "funcname": "Parcelable onSaveInstanceState ()", "descri": "  Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view. ", "parameters": null}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.widget.QuickContactBadge\n", "type": "boolean", "name": "computeScrollOffset", "throws": null, "funcname": "boolean computeScrollOffset ()", "descri": "  Call this when you want to know the new location. If it returns true, the animation is not yet finished. ", "parameters": null}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "showAsDropDown", "throws": null, "funcname": "void showAsDropDown (View anchor,                 int xoff,                 int yoff,                 int gravity)", "descri": "  Displays the content view in a popup window anchored to the corner of another view. The window is positioned according to the specified gravity and offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent view can be scrolled, the specified vertical gravity will be ignored and the popup will anchor itself such that it is visible. If the view later scrolls to move anchor to a different location, the popup will be moved correspondingly.   See also: dismiss()", "parameters": [{"scri": "View: the view on which to pin the popup window", "name": "anchor"}, {"scri": "int: A horizontal offset from the anchor in pixels", "name": "xoff"}, {"scri": "int: A vertical offset from the anchor in pixels", "name": "yoff"}, {"scri": "int: Alignment of the popup relative to the anchor", "name": "gravity"}]}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "showAsDropDown", "throws": null, "funcname": "void showAsDropDown (View anchor,                 int xoff,                 int yoff)", "descri": "  Display the content view in a popup window anchored to the bottom-left corner of the anchor view offset by the specified x and y coordinates. If there is not enough room on screen to show the popup in its entirety, this method tries to find a parent scroll view to scroll. If no parent scroll view can be scrolled, the bottom-left corner of the popup is pinned at the top left corner of the anchor view. If the view later scrolls to move anchor to a different location, the popup will be moved correspondingly.   See also: dismiss()", "parameters": [{"scri": "View: the view on which to pin the popup window", "name": "anchor"}, {"scri": "int: A horizontal offset from the anchor in pixels", "name": "xoff"}, {"scri": "int: A vertical offset from the anchor in pixels", "name": "yoff"}]}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "showAtLocation", "throws": null, "funcname": "void showAtLocation (View parent,                 int gravity,                 int x,                 int y)", "descri": "   Display the content view in a popup window at the specified location. If the popup window cannot fit on screen, it will be clipped. See WindowManager.LayoutParams for more information on how gravity and the x and y parameters are related. Specifying a gravity of NO_GRAVITY is similar to specifying Gravity.LEFT | Gravity.TOP. ", "parameters": [{"scri": "View: a parent view to get the getWindowToken() token from", "name": "parent"}, {"scri": "int: the gravity which controls the placement of the popup window", "name": "gravity"}, {"scri": "int: the popup's x location offset", "name": "x"}, {"scri": "int: the popup's y location offset", "name": "y"}]}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "showAtLocation", "throws": null, "funcname": "void showAtLocation (View parent,                 int gravity,                 int x,                 int y)", "descri": "   Display the content view in a popup window at the specified location. If the popup window cannot fit on screen, it will be clipped. See WindowManager.LayoutParams for more information on how gravity and the x and y parameters are related. Specifying a gravity of NO_GRAVITY is similar to specifying Gravity.LEFT | Gravity.TOP. ", "parameters": [{"scri": "View: a parent view to get the getWindowToken() token from", "name": "parent"}, {"scri": "int: the gravity which controls the placement of the popup window", "name": "gravity"}, {"scri": "int: the popup's x location offset", "name": "x"}, {"scri": "int: the popup's y location offset", "name": "y"}]}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "update", "throws": null, "funcname": "void update (View anchor,                 int xoff,                 int yoff,                 int width,                 int height)", "descri": "  Updates the position and the dimension of the popup window. Width and height can be set to -1 to update location only. Calling this function also updates the window with the current popup state as described for update(). If the view later scrolls to move anchor to a different location, the popup will be moved correspondingly. ", "parameters": [{"scri": "View: the popup's anchor view", "name": "anchor"}, {"scri": "int: x offset from the view's left edge", "name": "xoff"}, {"scri": "int: y offset from the view's bottom edge", "name": "yoff"}, {"scri": "int: the new width in pixels, must be >= 0 or -1 to ignore", "name": "width"}, {"scri": "int: the new height in pixels, must be >= 0 or -1 to ignore", "name": "height"}]}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "update", "throws": null, "funcname": "void update (int x,                 int y,                 int width,                 int height,                 boolean force)", "descri": "  Updates the position and the dimension of the popup window. Width and height can be set to -1 to update location only. Calling this function also updates the window with the current popup state as described for update(). ", "parameters": [{"scri": "int: the new x location", "name": "x"}, {"scri": "int: the new y location", "name": "y"}, {"scri": "int: the new width in pixels, must be >= 0 or -1 to ignore", "name": "width"}, {"scri": "int: the new height in pixels, must be >= 0 or -1 to ignore", "name": "height"}, {"scri": "boolean: true to reposition the window even if the specified              position already seems to correspond to the LayoutParams,              false to only reposition if needed", "name": "force"}]}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "update", "throws": null, "funcname": "void update (int x,                 int y,                 int width,                 int height,                 boolean force)", "descri": "  Updates the position and the dimension of the popup window. Width and height can be set to -1 to update location only. Calling this function also updates the window with the current popup state as described for update(). ", "parameters": [{"scri": "int: the new x location", "name": "x"}, {"scri": "int: the new y location", "name": "y"}, {"scri": "int: the new width in pixels, must be >= 0 or -1 to ignore", "name": "width"}, {"scri": "int: the new height in pixels, must be >= 0 or -1 to ignore", "name": "height"}, {"scri": "boolean: true to reposition the window even if the specified              position already seems to correspond to the LayoutParams,              false to only reposition if needed", "name": "force"}]}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "update", "throws": null, "funcname": "void update (int x,                 int y,                 int width,                 int height)", "descri": "  Updates the position and the dimension of the popup window. Width and height can be set to -1 to update location only. Calling this function also updates the window with the current popup state as described for update(). ", "parameters": [{"scri": "int: the new x location", "name": "x"}, {"scri": "int: the new y location", "name": "y"}, {"scri": "int: the new width in pixels, must be >= 0 or -1 to ignore", "name": "width"}, {"scri": "int: the new height in pixels, must be >= 0 or -1 to ignore", "name": "height"}]}, {"returns": null, "class": "android.widget.RadioButton\n", "type": "void", "name": "update", "throws": null, "funcname": "void update (int x,                 int y,                 int width,                 int height)", "descri": "  Updates the position and the dimension of the popup window. Width and height can be set to -1 to update location only. Calling this function also updates the window with the current popup state as described for update(). ", "parameters": [{"scri": "int: the new x location", "name": "x"}, {"scri": "int: the new y location", "name": "y"}, {"scri": "int: the new width in pixels, must be >= 0 or -1 to ignore", "name": "width"}, {"scri": "int: the new height in pixels, must be >= 0 or -1 to ignore", "name": "height"}]}, {"returns": null, "class": "android.widget.RadioGroup\n", "type": "void", "name": "assignContactFromPhone", "throws": null, "funcname": "void assignContactFromPhone (String phoneNumber,                 boolean lazyLookup)", "descri": "  Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number. ", "parameters": [{"scri": "String: The phone number of the contact.", "name": "phoneNumber"}, {"scri": "boolean: If this is true, the lookup query will not be performed until this view is clicked.", "name": "lazyLookup"}]}, {"returns": null, "class": "android.widget.RadioGroup\n", "type": "void", "name": "assignContactFromPhone", "throws": null, "funcname": "void assignContactFromPhone (String phoneNumber,                 boolean lazyLookup,                 Bundle extras)", "descri": "  Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number. ", "parameters": [{"scri": "String: The phone number of the contact.", "name": "phoneNumber"}, {"scri": "boolean: If this is true, the lookup query will not be performed until this view is clicked.", "name": "lazyLookup"}, {"scri": "Bundle: A bundle of extras to populate the contact edit page with if the contact is not found and the user chooses to add the phone number to an existing contact or create a new contact. Uses the same string constants as those found in ContactsContract.Intents.Insert", "name": "extras"}]}, {"returns": null, "class": "android.widget.RadioGroup\n", "type": "void", "name": "assignContactFromPhone", "throws": null, "funcname": "void assignContactFromPhone (String phoneNumber,                 boolean lazyLookup,                 Bundle extras)", "descri": "  Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number. ", "parameters": [{"scri": "String: The phone number of the contact.", "name": "phoneNumber"}, {"scri": "boolean: If this is true, the lookup query will not be performed until this view is clicked.", "name": "lazyLookup"}, {"scri": "Bundle: A bundle of extras to populate the contact edit page with if the contact is not found and the user chooses to add the phone number to an existing contact or create a new contact. Uses the same string constants as those found in ContactsContract.Intents.Insert", "name": "extras"}]}, {"returns": [{"scri": "", "type": "boolean"}], "class": "android.widget.SearchView\n", "type": "boolean", "name": "computeScrollOffset", "throws": null, "funcname": "boolean computeScrollOffset ()", "descri": "  Call this when you want to know the new location.  If it returns true, the animation is not yet finished. ", "parameters": null}, {"returns": [{"scri": "Returns a Parcelable object containing the view's current dynamic         state, or null if there is nothing interesting to save.", "type": "Parcelable"}], "class": "android.widget.SimpleAdapter\n", "type": "Parcelable", "name": "onSaveInstanceState", "throws": null, "funcname": "Parcelable onSaveInstanceState ()", "descri": "  Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view. ", "parameters": null}, {"returns": null, "class": "android.widget.SimpleCursorTreeAdapter\n", "type": "void", "name": "setOnShareTargetSelectedListener", "throws": null, "funcname": "void setOnShareTargetSelectedListener (ShareActionProvider.OnShareTargetSelectedListener listener)", "descri": "  Sets a listener to be notified when a share target has been selected. The listener can optionally decide to handle the selection and not rely on the default behavior which is to launch the activity. Note: If you choose the backing share history file     you will still be notified in this callback. ", "parameters": [{"scri": "ShareActionProvider.OnShareTargetSelectedListener: The listener.", "name": "listener"}]}, {"returns": null, "class": "android.widget.SimpleCursorTreeAdapter\n", "type": "void", "name": "setShareHistoryFileName", "throws": null, "funcname": "void setShareHistoryFileName (String shareHistoryFile)", "descri": "  Sets the file name of a file for persisting the share history which history will be used for ordering share targets. This file will be used for all view created by onCreateActionView(). Defaults to DEFAULT_SHARE_HISTORY_FILE_NAME. Set to null if share history should not be persisted between sessions. Note: The history file name can be set any time, however only the action views created by onCreateActionView() after setting the file name will be backed by the provided file. Therefore, if you want to use different history files for sharing specific types of content, every time you change the history file setShareHistoryFileName(String) you must call invalidateOptionsMenu() to recreate the action view. You should not call invalidateOptionsMenu() from onCreateOptionsMenu(Menu).  private void doShare(Intent intent) {     if (IMAGE.equals(intent.getMimeType())) {         mShareActionProvider.setHistoryFileName(SHARE_IMAGE_HISTORY_FILE_NAME);     } else if (TEXT.equals(intent.getMimeType())) {         mShareActionProvider.setHistoryFileName(SHARE_TEXT_HISTORY_FILE_NAME);     }     mShareActionProvider.setIntent(intent);     invalidateOptionsMenu(); } ", "parameters": [{"scri": "String: The share history file name.", "name": "shareHistoryFile"}]}, {"returns": [{"scri": "", "type": "int"}], "class": "android.widget.Toolbar.LayoutParams\n", "type": "int", "name": "getGravity", "throws": null, "funcname": "int getGravity ()", "descri": "  Get the location at which the notification should appear on the screen.   See also: GravitygetGravity()", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.widget.Toolbar.LayoutParams\n", "type": "int", "name": "getXOffset", "throws": null, "funcname": "int getXOffset ()", "descri": "  Return the X offset in pixels to apply to the gravity's location. ", "parameters": null}, {"returns": [{"scri": "", "type": "int"}], "class": "android.widget.Toolbar.LayoutParams\n", "type": "int", "name": "getYOffset", "throws": null, "funcname": "int getYOffset ()", "descri": "  Return the Y offset in pixels to apply to the gravity's location. ", "parameters": null}, {"returns": null, "class": "android.widget.Toolbar.LayoutParams\n", "type": "void", "name": "setGravity", "throws": null, "funcname": "void setGravity (int gravity,                 int xOffset,                 int yOffset)", "descri": "  Set the location at which the notification should appear on the screen.   See also: GravitygetGravity()", "parameters": [{"scri": "int", "name": "gravity"}, {"scri": "int", "name": "xOffset"}, {"scri": "int", "name": "yOffset"}]}, {"returns": [{"scri": "Returns a Parcelable object containing the view's current dynamic         state, or null if there is nothing interesting to save.", "type": "Parcelable"}], "class": "android.widget.TwoLineListItem\n", "type": "Parcelable", "name": "onSaveInstanceState", "throws": null, "funcname": "Parcelable onSaveInstanceState ()", "descri": "  Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view. ", "parameters": null}, {"returns": [{"scri": "true if the named file does not exist and was          successfully created; false if the named file          already exists", "type": "boolean"}], "class": "java.io.FileOutputStream\n", "type": "boolean", "name": "createNewFile", "throws": [{"scri": "If an I/O error occurred", "type": "IOException"}, {"scri": "If a security manager exists and its checkWrite(java.lang.String)          method denies write access to the file", "type": "SecurityException"}], "funcname": "boolean createNewFile ()", "descri": "  Atomically creates a new, empty file named by this abstract pathname if and only if a file with this name does not yet exist.  The check for the existence of the file and the creation of the file if it does not exist are a single operation that is atomic with respect to all other filesystem activities that might affect the file. Note: this method should not be used for file-locking, as the resulting protocol cannot be made to work reliably. The FileLock facility should be used instead.   ", "parameters": null}, {"returns": [{"scri": "a proxy class for the specified interfaces", "type": "Class<?>"}], "class": "java.io.ObjectOutputStream.PutField\n", "type": "Class<?>", "name": "resolveProxyClass", "throws": [{"scri": "any exception thrown by the underlying                InputStream", "type": "IOException"}, {"scri": "if the proxy class or any of the                named interfaces could not be found", "type": "ClassNotFoundException"}], "funcname": "Class<?> resolveProxyClass (String[] interfaces)", "descri": "  Returns a proxy class that implements the interfaces named in a proxy class descriptor; subclasses may implement this method to read custom data from the stream along with the descriptors for dynamic proxy classes, allowing them to use an alternate loading mechanism for the interfaces and the proxy class. This method is called exactly once for each unique proxy class descriptor in the stream. The corresponding method in ObjectOutputStream is annotateProxyClass.  For a given subclass of ObjectInputStream that overrides this method, the annotateProxyClass method in the corresponding subclass of ObjectOutputStream must write any data or objects read by this method. The default implementation of this method in ObjectInputStream returns the result of calling Proxy.getProxyClass with the list of Class objects for the interfaces that are named in the interfaces parameter.  The Class object for each interface name i is the value returned by calling Class.forName(i, false, loader) where loader is that of the first non- null class loader up the execution stack, or null if no non- null class loaders are on the stack (the same class loader choice used by the resolveClass method).  Unless any of the resolved interfaces are non-public, this same value of loader is also the class loader passed to Proxy.getProxyClass ; if non-public interfaces are present, their class loader is passed instead (if more than one non-public interface class loader is encountered, an IllegalAccessError is thrown). If Proxy.getProxyClass throws an IllegalArgumentException , resolveProxyClass will throw a ClassNotFoundException containing the IllegalArgumentException .    See also: annotateProxyClass(Class)", "parameters": [{"scri": "String: the list of interface names that were                deserialized in the proxy class descriptor", "name": "interfaces"}]}, {"returns": null, "class": "java.io.ObjectStreamField\n", "type": "void", "name": "annotateProxyClass", "throws": [{"scri": "any exception thrown by the underlying          OutputStream", "type": "IOException"}], "funcname": "void annotateProxyClass (Class<?> cl)", "descri": "  Subclasses may implement this method to store custom data in the stream along with descriptors for dynamic proxy classes. This method is called exactly once for each unique proxy class descriptor in the stream.  The default implementation of this method in ObjectOutputStream does nothing. The corresponding method in ObjectInputStream is resolveProxyClass.  For a given subclass of ObjectOutputStream that overrides this method, the resolveProxyClass method in the corresponding subclass of ObjectInputStream must read any data or objects written by annotateProxyClass.    See also: resolveProxyClass(String[])", "parameters": [{"scri": "Class: the proxy class to annotate custom data for", "name": "cl"}]}, {"returns": [{"scri": "true if the class is a proxy class and          false otherwise", "type": "boolean"}], "class": "java.lang.reflect.InvocationTargetException\n", "type": "static\n        \n        \n        boolean", "name": "isProxyClass", "throws": [{"scri": "if cl is null", "type": "NullPointerException"}], "funcname": "boolean isProxyClass (Class<?> cl)", "descri": "  Returns true if and only if the specified class was dynamically generated to be a proxy class using the getProxyClass method or the newProxyInstance method. The reliability of this method is important for the ability to use it to make security decisions, so its implementation should not just test if the class in question extends Proxy.    ", "parameters": [{"scri": "Class: the class to test", "name": "cl"}]}, {"returns": null, "class": "java.lang.reflect.InvocationTargetException\n", "name": "Proxy", "throws": [{"scri": "if the given invocation handler, h,         is null.", "type": "NullPointerException"}], "funcname": "Proxy (InvocationHandler h)", "parameters": [{"scri": "InvocationHandler: the invocation handler for this proxy instance", "name": "h"}], "descri": "  Constructs a new Proxy instance from a subclass (typically, a dynamic proxy class) with the specified value for its invocation handler.   "}, {"returns": null, "class": "java.lang.StackTraceElement\n", "type": "void", "name": "load", "throws": [{"scri": "if a security manager exists and its             checkLink method doesn't allow             loading of the specified dynamic library", "type": "SecurityException"}, {"scri": "if either the filename is not an             absolute path name, the native library is not statically             linked with the VM, or the library cannot be mapped to             a native library image by the host system.", "type": "UnsatisfiedLinkError"}, {"scri": "if filename is             null", "type": "NullPointerException"}], "funcname": "void load (String filename)", "descri": "  Loads the native library specified by the filename argument.  The filename argument must be an absolute path name. (for example Runtime.getRuntime().load(\"/home/avh/lib/libX11.so\");). If the filename argument, when stripped of any platform-specific library prefix, path, and file extension, indicates a library whose name is, for example, L, and a native library called L is statically linked with the VM, then the JNI_OnLoad_L function exported by the library is invoked rather than attempting to load a dynamic library. A filename matching the argument does not have to exist in the file system. See the JNI Specification for more details. Otherwise, the filename argument is mapped to a native library image in an implementation-dependent manner. First, if there is a security manager, its checkLink method is called with the filename as its argument. This may result in a security exception. This is similar to the method loadLibrary(String), but it accepts a general file name as an argument rather than just a library name, allowing any file of native code to be loaded. The method load(String) is the conventional and convenient means of invoking this method.    See also: getRuntime()SecurityExceptioncheckLink(java.lang.String)", "parameters": [{"scri": "String: the file to load.", "name": "filename"}]}, {"returns": null, "class": "java.lang.StackTraceElement\n", "type": "void", "name": "loadLibrary", "throws": [{"scri": "if a security manager exists and its             checkLink method doesn't allow             loading of the specified dynamic library", "type": "SecurityException"}, {"scri": "if either the libname argument             contains a file path, the native library is not statically             linked with the VM,  or the library cannot be mapped to a             native library image by the host system.", "type": "UnsatisfiedLinkError"}, {"scri": "if libname is             null", "type": "NullPointerException"}], "funcname": "void loadLibrary (String libname)", "descri": "  Loads the native library specified by the libname argument.  The libname argument must not contain any platform specific prefix, file extension or path. If a native library called libname is statically linked with the VM, then the JNI_OnLoad_libname function exported by the library is invoked. See the JNI Specification for more details. Otherwise, the libname argument is loaded from a system library location and mapped to a native library image in an implementation- dependent manner. First, if there is a security manager, its checkLink method is called with the libname as its argument. This may result in a security exception. The method loadLibrary(String) is the conventional and convenient means of invoking this method. If native methods are to be used in the implementation of a class, a standard strategy is to put the native code in a library file (call it LibFile) and then to put a static initializer: static { System.loadLibrary(\"LibFile\"); } within the class declaration. When the class is loaded and initialized, the necessary native code implementation for the native methods will then be loaded as well. If this method is called more than once with the same library name, the second and subsequent calls are ignored.    See also: SecurityExceptioncheckLink(java.lang.String)", "parameters": [{"scri": "String: the name of the library.", "name": "libname"}]}, {"returns": null, "class": "java.lang.ThreadGroup\n", "type": "static\n        \n        \n        void", "name": "load", "throws": [{"scri": "if a security manager exists and its             checkLink method doesn't allow             loading of the specified dynamic library", "type": "SecurityException"}, {"scri": "if either the filename is not an             absolute path name, the native library is not statically             linked with the VM, or the library cannot be mapped to             a native library image by the host system.", "type": "UnsatisfiedLinkError"}, {"scri": "if filename is             null", "type": "NullPointerException"}], "funcname": "void load (String filename)", "descri": "  Loads the native library specified by the filename argument.  The filename argument must be an absolute path name. If the filename argument, when stripped of any platform-specific library prefix, path, and file extension, indicates a library whose name is, for example, L, and a native library called L is statically linked with the VM, then the JNI_OnLoad_L function exported by the library is invoked rather than attempting to load a dynamic library. A filename matching the argument does not have to exist in the file system. See the JNI Specification for more details. Otherwise, the filename argument is mapped to a native library image in an implementation-dependent manner. The call System.load(name) is effectively equivalent to the call: Runtime.getRuntime().load(name)    See also: load(java.lang.String)checkLink(java.lang.String)", "parameters": [{"scri": "String: the file to load.", "name": "filename"}]}, {"returns": null, "class": "java.lang.ThreadGroup\n", "type": "static\n        \n        \n        void", "name": "loadLibrary", "throws": [{"scri": "if a security manager exists and its             checkLink method doesn't allow             loading of the specified dynamic library", "type": "SecurityException"}, {"scri": "if either the libname argument             contains a file path, the native library is not statically             linked with the VM,  or the library cannot be mapped to a             native library image by the host system.", "type": "UnsatisfiedLinkError"}, {"scri": "if libname is             null", "type": "NullPointerException"}], "funcname": "void loadLibrary (String libname)", "descri": "  Loads the native library specified by the libname argument.  The libname argument must not contain any platform specific prefix, file extension or path. If a native library called libname is statically linked with the VM, then the JNI_OnLoad_libname function exported by the library is invoked. See the JNI Specification for more details. Otherwise, the libname argument is loaded from a system library location and mapped to a native library image in an implementation- dependent manner. The call System.loadLibrary(name) is effectively equivalent to the call Runtime.getRuntime().loadLibrary(name)    See also: loadLibrary(java.lang.String)checkLink(java.lang.String)", "parameters": [{"scri": "String: the name of the library.", "name": "libname"}]}, {"returns": [{"scri": "an estimate of the number of active threads in the current          thread's thread group and in any other thread group that          has the current thread's thread group as an ancestor", "type": "int"}], "class": "java.lang.Throwable\n", "type": "static\n        \n        \n        int", "name": "activeCount", "throws": null, "funcname": "int activeCount ()", "descri": "  Returns an estimate of the number of active threads in the current thread's thread group and its subgroups. Recursively iterates over all subgroups in the current thread's thread group. The value returned is only an estimate because the number of threads may change dynamically while this method traverses internal data structures, and might be affected by the presence of certain system threads. This method is intended primarily for debugging and monitoring purposes. ", "parameters": null}, {"returns": [{"scri": "an estimate of the number of active threads in this thread          group and in any other thread group that has this thread          group as an ancestor", "type": "int"}], "class": "java.lang.Void\n", "type": "int", "name": "activeCount", "throws": null, "funcname": "int activeCount ()", "descri": "  Returns an estimate of the number of active threads in this thread group and its subgroups. Recursively iterates over all subgroups in this thread group. The value returned is only an estimate because the number of threads may change dynamically while this method traverses internal data structures, and might be affected by the presence of certain system threads. This method is intended primarily for debugging and monitoring purposes. ", "parameters": null}, {"returns": [{"scri": "the number of active thread groups with this thread group as          an ancestor", "type": "int"}], "class": "java.lang.Void\n", "type": "int", "name": "activeGroupCount", "throws": null, "funcname": "int activeGroupCount ()", "descri": "  Returns an estimate of the number of active groups in this thread group and its subgroups. Recursively iterates over all subgroups in this thread group. The value returned is only an estimate because the number of thread groups may change dynamically while this method traverses internal data structures. This method is intended primarily for debugging and monitoring purposes. ", "parameters": null}, {"returns": null, "class": "java.net.Authenticator.RequestorType\n", "type": "void", "name": "setUseCaches", "throws": [{"scri": "if already connected", "type": "IllegalStateException"}], "funcname": "void setUseCaches (boolean usecaches)", "descri": "  Sets the value of the useCaches field of this URLConnection to the specified value. Some protocols do caching of documents.  Occasionally, it is important to be able to \"tunnel through\" and ignore the caches (e.g., the \"reload\" button in a browser).  If the UseCaches flag on a connection is true, the connection is allowed to use whatever caches it can.  If false, caches are to be ignored.  The default value comes from DefaultUseCaches, which defaults to true.    See also: getUseCaches()", "parameters": [{"scri": "boolean: a boolean indicating whether or not to allow caching", "name": "usecaches"}]}, {"returns": null, "class": "java.nio.file.attribute.FileStoreAttributeView\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setArchive", "throws": [{"scri": "if an I/O error occurs", "type": "IOException"}, {"scri": "In the case of the default, and a security manager is installed,          its  checkWrite method          is invoked to check write access to the file", "type": "SecurityException"}], "funcname": "void setArchive (boolean value)", "descri": "  Updates the value of the archive attribute. It is implementation specific if the attribute can be updated as an atomic operation with respect to other file system operations. An implementation may, for example, require to read the existing value of the DOS attribute in order to update this attribute.   ", "parameters": [{"scri": "boolean: the new value of the attribute", "name": "value"}]}, {"returns": null, "class": "java.nio.file.attribute.FileStoreAttributeView\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setHidden", "throws": [{"scri": "if an I/O error occurs", "type": "IOException"}, {"scri": "In the case of the default, and a security manager is installed,          its  checkWrite method          is invoked to check write access to the file", "type": "SecurityException"}], "funcname": "void setHidden (boolean value)", "descri": "  Updates the value of the hidden attribute. It is implementation specific if the attribute can be updated as an atomic operation with respect to other file system operations. An implementation may, for example, require to read the existing value of the DOS attribute in order to update this attribute.   ", "parameters": [{"scri": "boolean: the new value of the attribute", "name": "value"}]}, {"returns": null, "class": "java.nio.file.attribute.FileStoreAttributeView\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setReadOnly", "throws": [{"scri": "if an I/O error occurs", "type": "IOException"}, {"scri": "In the case of the default, and a security manager is installed,          its  checkWrite method          is invoked to check write access to the file", "type": "SecurityException"}], "funcname": "void setReadOnly (boolean value)", "descri": "  Updates the value of the read-only attribute. It is implementation specific if the attribute can be updated as an atomic operation with respect to other file system operations. An implementation may, for example, require to read the existing value of the DOS attribute in order to update this attribute.   ", "parameters": [{"scri": "boolean: the new value of the attribute", "name": "value"}]}, {"returns": null, "class": "java.nio.file.attribute.FileStoreAttributeView\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setSystem", "throws": [{"scri": "if an I/O error occurs", "type": "IOException"}, {"scri": "In the case of the default, and a security manager is installed,          its  checkWrite method          is invoked to check write access to the file", "type": "SecurityException"}], "funcname": "void setSystem (boolean value)", "descri": "  Updates the value of the system attribute. It is implementation specific if the attribute can be updated as an atomic operation with respect to other file system operations. An implementation may, for example, require to read the existing value of the DOS attribute in order to update this attribute.   ", "parameters": [{"scri": "boolean: the new value of the attribute", "name": "value"}]}, {"returns": null, "class": "java.security.cert.X509CertSelector\n", "type": "void", "name": "setOcspResponder", "throws": null, "funcname": "void setOcspResponder (URI uri)", "descri": "  Sets the URI that identifies the location of the OCSP responder. This overrides the ocsp.responderURL security property and any responder specified in a certificate's Authority Information Access Extension, as defined in RFC 5280. ", "parameters": [{"scri": "URI: the responder URI", "name": "uri"}]}, {"returns": null, "class": "java.security.DomainCombiner\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "checkAccess", "throws": [{"scri": "an implementation is required to support checking for          READ, WRITE, and EXECUTE access. This          exception is specified to allow for the Access enum to          be extended in future releases.", "type": "UnsupportedOperationException"}, {"scri": "if a file does not exist (optional specific exception)", "type": "NoSuchFileException"}, {"scri": "the requested access would be denied or the access cannot be          determined because the Java virtual machine has insufficient          privileges or other reasons. (optional specific exception)", "type": "AccessDeniedException"}, {"scri": "if an I/O error occurs", "type": "IOException"}, {"scri": "In the case of the default provider, and a security manager is          installed, the checkRead          is invoked when checking read access to the file or only the          existence of the file, the checkWrite is invoked when checking write access to the file,          and checkExec is invoked          when checking execute access.", "type": "SecurityException"}], "funcname": "void checkAccess (Path path,                 AccessMode... modes)", "descri": "  Checks the existence, and optionally the accessibility, of a file. This method may be used by the isReadable, isWritable and isExecutable methods to check the accessibility of a file. This method checks the existence of a file and that this Java virtual machine has appropriate privileges that would allow it access the file according to all of access modes specified in the modes parameter as follows: Value Description    READ   Checks that the file exists and that the Java virtual machine has     permission to read the file.     WRITE   Checks that the file exists and that the Java virtual machine has     permission to write to the file,     EXECUTE   Checks that the file exists and that the Java virtual machine has     permission to execute the file. The semantics     may differ when checking access to a directory. For example, on UNIX     systems, checking for EXECUTE access checks that the Java     virtual machine has permission to search the directory in order to     access file or subdirectories.  If the modes parameter is of length zero, then the existence of the file is checked. This method follows symbolic links if the file referenced by this object is a symbolic link. Depending on the implementation, this method may require to read file permissions, access control lists, or other file attributes in order to check the effective access to the file. To determine the effective access to a file may require access to several attributes and so in some implementations this method may not be atomic with respect to other file system operations.   ", "parameters": [{"scri": "Path: the path to the file to check", "name": "path"}, {"scri": "AccessMode: The access modes to check; may have zero elements", "name": "modes"}]}, {"returns": null, "class": "java.security.DomainCombiner\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "createDirectory", "throws": [{"scri": "if the array contains an attribute that cannot be set atomically          when creating the directory", "type": "UnsupportedOperationException"}, {"scri": "if a directory could not otherwise be created because a file of          that name already exists (optional specific exception)", "type": "FileAlreadyExistsException"}, {"scri": "if an I/O error occurs or the parent directory does not exist", "type": "IOException"}, {"scri": "In the case of the default provider, and a security manager is          installed, the checkWrite          method is invoked to check write access to the new directory.", "type": "SecurityException"}], "funcname": "void createDirectory (Path dir,                 FileAttribute...<?> attrs)", "descri": "  Creates a new directory. This method works in exactly the manner specified by the createDirectory(Path, FileAttribute>...) method.   ", "parameters": [{"scri": "Path: the directory to create", "name": "dir"}, {"scri": "FileAttribute: an optional list of file attributes to set atomically when          creating the directory", "name": "attrs"}]}, {"returns": null, "class": "java.security.DomainCombiner\n", "type": "void", "name": "createSymbolicLink", "throws": [{"scri": "if the implementation does not support symbolic links or the          array contains an attribute that cannot be set atomically when          creating the symbolic link", "type": "UnsupportedOperationException"}, {"scri": "if a file with the name already exists (optional specific          exception)", "type": "FileAlreadyExistsException"}, {"scri": "if an I/O error occurs", "type": "IOException"}, {"scri": "In the case of the default provider, and a security manager          is installed, it denies LinkPermission(\"symbolic\")          or its checkWrite          method denies write access to the path of the symbolic link.", "type": "SecurityException"}], "funcname": "void createSymbolicLink (Path link,                 Path target,                 FileAttribute...<?> attrs)", "descri": "  Creates a symbolic link to a target. This method works in exactly the manner specified by the createSymbolicLink(Path, Path, FileAttribute>...) method. The default implementation of this method throws UnsupportedOperationException.   ", "parameters": [{"scri": "Path: the path of the symbolic link to create", "name": "link"}, {"scri": "Path: the target of the symbolic link", "name": "target"}, {"scri": "FileAttribute: the array of attributes to set atomically when creating the          symbolic link", "name": "attrs"}]}, {"returns": null, "class": "java.security.KeyFactorySpi\n", "name": "DomainLoadStoreParameter", "throws": [{"scri": "if configuration or     protectionParams is null", "type": "NullPointerException"}], "funcname": "DomainLoadStoreParameter (URI configuration,                 Map<String,\u00a0KeyStore.ProtectionParameter> protectionParams)", "parameters": [{"scri": "URI: identifier for the domain configuration data.     The name of the target domain should be specified in the     java.net.URI fragment component when it is necessary     to distinguish between several domain configurations at the     same location.", "name": "configuration"}, {"scri": "Map: the map from keystore name to the parameter     used to protect keystore data.     A java.util.Collections.EMPTY_MAP should be used     when protection parameters are not required or when they have     been specified by properties in the domain configuration data.     It is cloned to prevent subsequent modification.", "name": "protectionParams"}], "descri": "  Constructs a DomainLoadStoreParameter for a keystore domain with the parameters used to protect keystore data.   "}, {"returns": null, "class": "java.security.KeyFactorySpi\n", "name": "DomainLoadStoreParameter", "throws": [{"scri": "if configuration or     protectionParams is null", "type": "NullPointerException"}], "funcname": "DomainLoadStoreParameter (URI configuration,                 Map<String,\u00a0KeyStore.ProtectionParameter> protectionParams)", "parameters": [{"scri": "URI: identifier for the domain configuration data.     The name of the target domain should be specified in the     java.net.URI fragment component when it is necessary     to distinguish between several domain configurations at the     same location.", "name": "configuration"}, {"scri": "Map: the map from keystore name to the parameter     used to protect keystore data.     A java.util.Collections.EMPTY_MAP should be used     when protection parameters are not required or when they have     been specified by properties in the domain configuration data.     It is cloned to prevent subsequent modification.", "name": "protectionParams"}], "descri": "  Constructs a DomainLoadStoreParameter for a keystore domain with the parameters used to protect keystore data.   "}, {"returns": [{"scri": "true if the sequence of char values is normalized; false otherwise.", "type": "boolean"}], "class": "java.text.RuleBasedCollator\n", "type": "static\n        \n        \n        boolean", "name": "isNormalized", "throws": [{"scri": "If src or form is null.", "type": "NullPointerException"}], "funcname": "boolean isNormalized (CharSequence src,                 Normalizer.Form form)", "descri": "  Determines if the given sequence of char values is normalized.    ", "parameters": [{"scri": "CharSequence: The sequence of char values to be checked.", "name": "src"}, {"scri": "Normalizer.Form: The normalization form; one of                   NFC,                   NFD,                   NFKC,                   NFKD", "name": "form"}]}, {"returns": [{"scri": "the value for the field", "type": "int"}], "class": "java.time.Month\n", "type": "int", "name": "get", "throws": [{"scri": "if a value for the field cannot be obtained or         the value is outside the range of valid values for the field", "type": "DateTimeException"}, {"scri": "if the field is not supported or         the range of values exceeds an int", "type": "UnsupportedTemporalTypeException"}, {"scri": "if numeric overflow occurs", "type": "ArithmeticException"}], "funcname": "int get (TemporalField field)", "descri": "  Gets the value of the specified field from this date-time as an int. This queries this date-time for the value of the specified field. The returned value will always be within the valid range of values for the field. If it is not possible to return the value, because the field is not supported or for some other reason, an exception is thrown. If the field is a ChronoField then the query is implemented here. The supported fields will return valid values based on this date-time, except NANO_OF_DAY, MICRO_OF_DAY, EPOCH_DAY, PROLEPTIC_MONTH and INSTANT_SECONDS which are too large to fit in an int and throw a DateTimeException. All other ChronoField instances will throw an UnsupportedTemporalTypeException. If the field is not a ChronoField, then the result of this method is obtained by invoking TemporalField.getFrom(TemporalAccessor) passing this as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.    ", "parameters": [{"scri": "TemporalField: the field to get, not null", "name": "field"}]}, {"returns": [{"scri": "true if the unit can be added/subtracted, false if not", "type": "boolean"}], "class": "java.time.Month\n", "type": "boolean", "name": "isSupported", "throws": null, "funcname": "boolean isSupported (TemporalUnit unit)", "descri": "  Checks if the specified unit is supported. This checks if the specified unit can be added to, or subtracted from, this date-time. If false, then calling the plus(long, TemporalUnit) and minus methods will throw an exception. If the unit is a ChronoUnit then the query is implemented here. The supported units are: NANOS MICROS MILLIS SECONDS MINUTES HOURS HALF_DAYS DAYS WEEKS MONTHS YEARS DECADES CENTURIES MILLENNIA ERAS All other ChronoUnit instances will return false. If the unit is not a ChronoUnit, then the result of this method is obtained by invoking TemporalUnit.isSupportedBy(Temporal) passing this as the argument. Whether the unit is supported is determined by the unit.  ", "parameters": [{"scri": "TemporalUnit: the unit to check, null returns false", "name": "unit"}]}, {"returns": [{"scri": "true if the field is supported on this date-time, false if not", "type": "boolean"}], "class": "java.time.Month\n", "type": "boolean", "name": "isSupported", "throws": null, "funcname": "boolean isSupported (TemporalField field)", "descri": "  Checks if the specified field is supported. This checks if this date-time can be queried for the specified field. If false, then calling the range, get and with(TemporalField, long) methods will throw an exception. If the field is a ChronoField then the query is implemented here. The supported fields are: NANO_OF_SECOND NANO_OF_DAY MICRO_OF_SECOND MICRO_OF_DAY MILLI_OF_SECOND MILLI_OF_DAY SECOND_OF_MINUTE SECOND_OF_DAY MINUTE_OF_HOUR MINUTE_OF_DAY HOUR_OF_AMPM CLOCK_HOUR_OF_AMPM HOUR_OF_DAY CLOCK_HOUR_OF_DAY AMPM_OF_DAY DAY_OF_WEEK ALIGNED_DAY_OF_WEEK_IN_MONTH ALIGNED_DAY_OF_WEEK_IN_YEAR DAY_OF_MONTH DAY_OF_YEAR EPOCH_DAY ALIGNED_WEEK_OF_MONTH ALIGNED_WEEK_OF_YEAR MONTH_OF_YEAR PROLEPTIC_MONTH YEAR_OF_ERA YEAR ERA INSTANT_SECONDS OFFSET_SECONDS All other ChronoField instances will return false. If the field is not a ChronoField, then the result of this method is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor) passing this as the argument. Whether the field is supported is determined by the field.  ", "parameters": [{"scri": "TemporalField: the field to check, null returns false", "name": "field"}]}, {"returns": [{"scri": "the amount of time between this date-time and the end date-time", "type": "long"}], "class": "java.time.Month\n", "type": "long", "name": "until", "throws": [{"scri": "if the amount cannot be calculated, or the end  temporal cannot be converted to a ZonedDateTime", "type": "DateTimeException"}, {"scri": "if the unit is not supported", "type": "UnsupportedTemporalTypeException"}, {"scri": "if numeric overflow occurs", "type": "ArithmeticException"}], "funcname": "long until (Temporal endExclusive,                 TemporalUnit unit)", "descri": "  Calculates the amount of time until another date-time in terms of the specified unit. This calculates the amount of time between two ZonedDateTime objects in terms of a single TemporalUnit. The start and end points are this and the specified date-time. The result will be negative if the end is before the start. For example, the amount in days between two date-times can be calculated using startDateTime.until(endDateTime, DAYS). The Temporal passed to this method is converted to a ZonedDateTime using from(TemporalAccessor). If the time-zone differs between the two zoned date-times, the specified end date-time is normalized to have the same zone as this date-time. The calculation returns a whole number, representing the number of complete units between the two date-times. For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z will only be one month as it is one minute short of two months. There are two equivalent ways of using this method. The first is to invoke this method. The second is to use between(Temporal, Temporal): // these two lines are equivalent   amount = start.until(end, MONTHS);   amount = MONTHS.between(start, end); The choice should be made based on which makes the code more readable. The calculation is implemented in this method for ChronoUnit. The units NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS and HALF_DAYS, DAYS, WEEKS, MONTHS, YEARS, DECADES, CENTURIES, MILLENNIA and ERAS are supported. Other ChronoUnit values will throw an exception. The calculation for date and time units differ. Date units operate on the local time-line, using the local date-time. For example, the period from noon on day 1 to noon the following day in days will always be counted as exactly one day, irrespective of whether there was a daylight savings change or not. Time units operate on the instant time-line. The calculation effectively converts both zoned date-times to instants and then calculates the period between the instants. For example, the period from noon on day 1 to noon the following day in hours may be 23, 24 or 25 hours (or some other amount) depending on whether there was a daylight savings change or not. If the unit is not a ChronoUnit, then the result of this method is obtained by invoking TemporalUnit.between(Temporal, Temporal) passing this as the first argument and the converted input temporal as the second argument. This instance is immutable and unaffected by this method call.    ", "parameters": [{"scri": "Temporal: the end date, exclusive, which is converted to a ZonedDateTime, not null", "name": "endExclusive"}, {"scri": "TemporalUnit: the unit to measure the amount in, not null", "name": "unit"}]}, {"returns": [{"scri": "the value for the field", "type": "int"}], "class": "java.time.OffsetDateTime\n", "type": "int", "name": "get", "throws": [{"scri": "if a value for the field cannot be obtained or         the value is outside the range of valid values for the field", "type": "DateTimeException"}, {"scri": "if the field is not supported or         the range of values exceeds an int", "type": "UnsupportedTemporalTypeException"}, {"scri": "if numeric overflow occurs", "type": "ArithmeticException"}], "funcname": "int get (TemporalField field)", "descri": "  Gets the value of the specified field from this date-time as an int. This queries this date-time for the value of the specified field. The returned value will always be within the valid range of values for the field. If it is not possible to return the value, because the field is not supported or for some other reason, an exception is thrown. If the field is a ChronoField then the query is implemented here. The supported fields will return valid values based on this date-time, except NANO_OF_DAY, MICRO_OF_DAY, EPOCH_DAY and PROLEPTIC_MONTH which are too large to fit in an int and throw a DateTimeException. All other ChronoField instances will throw an UnsupportedTemporalTypeException. If the field is not a ChronoField, then the result of this method is obtained by invoking TemporalField.getFrom(TemporalAccessor) passing this as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.    ", "parameters": [{"scri": "TemporalField: the field to get, not null", "name": "field"}]}, {"returns": [{"scri": "true if the unit can be added/subtracted, false if not", "type": "boolean"}], "class": "java.time.OffsetDateTime\n", "type": "boolean", "name": "isSupported", "throws": null, "funcname": "boolean isSupported (TemporalUnit unit)", "descri": "  Checks if the specified unit is supported. This checks if the specified unit can be added to, or subtracted from, this date-time. If false, then calling the plus(long, TemporalUnit) and minus methods will throw an exception. If the unit is a ChronoUnit then the query is implemented here. The supported units are: NANOS MICROS MILLIS SECONDS MINUTES HOURS HALF_DAYS DAYS WEEKS MONTHS YEARS DECADES CENTURIES MILLENNIA ERAS All other ChronoUnit instances will return false. If the unit is not a ChronoUnit, then the result of this method is obtained by invoking TemporalUnit.isSupportedBy(Temporal) passing this as the argument. Whether the unit is supported is determined by the unit.  ", "parameters": [{"scri": "TemporalUnit: the unit to check, null returns false", "name": "unit"}]}, {"returns": [{"scri": "true if the field is supported on this date-time, false if not", "type": "boolean"}], "class": "java.time.OffsetDateTime\n", "type": "boolean", "name": "isSupported", "throws": null, "funcname": "boolean isSupported (TemporalField field)", "descri": "  Checks if the specified field is supported. This checks if this date-time can be queried for the specified field. If false, then calling the range, get and with(TemporalField, long) methods will throw an exception. If the field is a ChronoField then the query is implemented here. The supported fields are: NANO_OF_SECOND NANO_OF_DAY MICRO_OF_SECOND MICRO_OF_DAY MILLI_OF_SECOND MILLI_OF_DAY SECOND_OF_MINUTE SECOND_OF_DAY MINUTE_OF_HOUR MINUTE_OF_DAY HOUR_OF_AMPM CLOCK_HOUR_OF_AMPM HOUR_OF_DAY CLOCK_HOUR_OF_DAY AMPM_OF_DAY DAY_OF_WEEK ALIGNED_DAY_OF_WEEK_IN_MONTH ALIGNED_DAY_OF_WEEK_IN_YEAR DAY_OF_MONTH DAY_OF_YEAR EPOCH_DAY ALIGNED_WEEK_OF_MONTH ALIGNED_WEEK_OF_YEAR MONTH_OF_YEAR PROLEPTIC_MONTH YEAR_OF_ERA YEAR ERA All other ChronoField instances will return false. If the field is not a ChronoField, then the result of this method is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor) passing this as the argument. Whether the field is supported is determined by the field.  ", "parameters": [{"scri": "TemporalField: the field to check, null returns false", "name": "field"}]}, {"returns": [{"scri": "the amount of time between this date-time and the end date-time", "type": "long"}], "class": "java.time.OffsetDateTime\n", "type": "long", "name": "until", "throws": [{"scri": "if the amount cannot be calculated, or the end  temporal cannot be converted to a LocalDateTime", "type": "DateTimeException"}, {"scri": "if the unit is not supported", "type": "UnsupportedTemporalTypeException"}, {"scri": "if numeric overflow occurs", "type": "ArithmeticException"}], "funcname": "long until (Temporal endExclusive,                 TemporalUnit unit)", "descri": "  Calculates the amount of time until another date-time in terms of the specified unit. This calculates the amount of time between two LocalDateTime objects in terms of a single TemporalUnit. The start and end points are this and the specified date-time. The result will be negative if the end is before the start. The Temporal passed to this method is converted to a LocalDateTime using from(TemporalAccessor). For example, the amount in days between two date-times can be calculated using startDateTime.until(endDateTime, DAYS). The calculation returns a whole number, representing the number of complete units between the two date-times. For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59 will only be one month as it is one minute short of two months. There are two equivalent ways of using this method. The first is to invoke this method. The second is to use between(Temporal, Temporal): // these two lines are equivalent   amount = start.until(end, MONTHS);   amount = MONTHS.between(start, end); The choice should be made based on which makes the code more readable. The calculation is implemented in this method for ChronoUnit. The units NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS and HALF_DAYS, DAYS, WEEKS, MONTHS, YEARS, DECADES, CENTURIES, MILLENNIA and ERAS are supported. Other ChronoUnit values will throw an exception. If the unit is not a ChronoUnit, then the result of this method is obtained by invoking TemporalUnit.between(Temporal, Temporal) passing this as the first argument and the converted input temporal as the second argument. This instance is immutable and unaffected by this method call.    ", "parameters": [{"scri": "Temporal: the end date, exclusive, which is converted to a LocalDateTime, not null", "name": "endExclusive"}, {"scri": "TemporalUnit: the unit to measure the amount in, not null", "name": "unit"}]}, {"returns": [{"scri": "the value for the field", "type": "int"}], "class": "java.time.OffsetTime\n", "type": "int", "name": "get", "throws": [{"scri": "if a value for the field cannot be obtained or         the value is outside the range of valid values for the field", "type": "DateTimeException"}, {"scri": "if the field is not supported or         the range of values exceeds an int", "type": "UnsupportedTemporalTypeException"}, {"scri": "if numeric overflow occurs", "type": "ArithmeticException"}], "funcname": "int get (TemporalField field)", "descri": "  Gets the value of the specified field from this time as an int. This queries this time for the value of the specified field. The returned value will always be within the valid range of values for the field. If it is not possible to return the value, because the field is not supported or for some other reason, an exception is thrown. If the field is a ChronoField then the query is implemented here. The supported fields will return valid values based on this time, except NANO_OF_DAY and MICRO_OF_DAY which are too large to fit in an int and throw a DateTimeException. All other ChronoField instances will throw an UnsupportedTemporalTypeException. If the field is not a ChronoField, then the result of this method is obtained by invoking TemporalField.getFrom(TemporalAccessor) passing this as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.    ", "parameters": [{"scri": "TemporalField: the field to get, not null", "name": "field"}]}, {"returns": [{"scri": "true if the unit can be added/subtracted, false if not", "type": "boolean"}], "class": "java.time.OffsetTime\n", "type": "boolean", "name": "isSupported", "throws": null, "funcname": "boolean isSupported (TemporalUnit unit)", "descri": "  Checks if the specified unit is supported. This checks if the specified unit can be added to, or subtracted from, this time. If false, then calling the plus(long, TemporalUnit) and minus methods will throw an exception. If the unit is a ChronoUnit then the query is implemented here. The supported units are: NANOS MICROS MILLIS SECONDS MINUTES HOURS HALF_DAYS All other ChronoUnit instances will return false. If the unit is not a ChronoUnit, then the result of this method is obtained by invoking TemporalUnit.isSupportedBy(Temporal) passing this as the argument. Whether the unit is supported is determined by the unit.  ", "parameters": [{"scri": "TemporalUnit: the unit to check, null returns false", "name": "unit"}]}, {"returns": [{"scri": "true if the field is supported on this time, false if not", "type": "boolean"}], "class": "java.time.OffsetTime\n", "type": "boolean", "name": "isSupported", "throws": null, "funcname": "boolean isSupported (TemporalField field)", "descri": "  Checks if the specified field is supported. This checks if this time can be queried for the specified field. If false, then calling the range, get and with(TemporalField, long) methods will throw an exception. If the field is a ChronoField then the query is implemented here. The supported fields are: NANO_OF_SECOND NANO_OF_DAY MICRO_OF_SECOND MICRO_OF_DAY MILLI_OF_SECOND MILLI_OF_DAY SECOND_OF_MINUTE SECOND_OF_DAY MINUTE_OF_HOUR MINUTE_OF_DAY HOUR_OF_AMPM CLOCK_HOUR_OF_AMPM HOUR_OF_DAY CLOCK_HOUR_OF_DAY AMPM_OF_DAY All other ChronoField instances will return false. If the field is not a ChronoField, then the result of this method is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor) passing this as the argument. Whether the field is supported is determined by the field.  ", "parameters": [{"scri": "TemporalField: the field to check, null returns false", "name": "field"}]}, {"returns": [{"scri": "the amount of time between this time and the end time", "type": "long"}], "class": "java.time.OffsetTime\n", "type": "long", "name": "until", "throws": [{"scri": "if the amount cannot be calculated, or the end  temporal cannot be converted to a LocalTime", "type": "DateTimeException"}, {"scri": "if the unit is not supported", "type": "UnsupportedTemporalTypeException"}, {"scri": "if numeric overflow occurs", "type": "ArithmeticException"}], "funcname": "long until (Temporal endExclusive,                 TemporalUnit unit)", "descri": "  Calculates the amount of time until another time in terms of the specified unit. This calculates the amount of time between two LocalTime objects in terms of a single TemporalUnit. The start and end points are this and the specified time. The result will be negative if the end is before the start. The Temporal passed to this method is converted to a LocalTime using from(TemporalAccessor). For example, the amount in hours between two times can be calculated using startTime.until(endTime, HOURS). The calculation returns a whole number, representing the number of complete units between the two times. For example, the amount in hours between 11:30 and 13:29 will only be one hour as it is one minute short of two hours. There are two equivalent ways of using this method. The first is to invoke this method. The second is to use between(Temporal, Temporal): // these two lines are equivalent   amount = start.until(end, MINUTES);   amount = MINUTES.between(start, end); The choice should be made based on which makes the code more readable. The calculation is implemented in this method for ChronoUnit. The units NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS and HALF_DAYS are supported. Other ChronoUnit values will throw an exception. If the unit is not a ChronoUnit, then the result of this method is obtained by invoking TemporalUnit.between(Temporal, Temporal) passing this as the first argument and the converted input temporal as the second argument. This instance is immutable and unaffected by this method call.    ", "parameters": [{"scri": "Temporal: the end time, exclusive, which is converted to a LocalTime, not null", "name": "endExclusive"}, {"scri": "TemporalUnit: the unit to measure the amount in, not null", "name": "unit"}]}, {"returns": [{"scri": "the value for the field", "type": "int"}], "class": "java.time.Year\n", "type": "int", "name": "get", "throws": [{"scri": "if a value for the field cannot be obtained or         the value is outside the range of valid values for the field", "type": "DateTimeException"}, {"scri": "if the field is not supported or         the range of values exceeds an int", "type": "UnsupportedTemporalTypeException"}, {"scri": "if numeric overflow occurs", "type": "ArithmeticException"}], "funcname": "int get (TemporalField field)", "descri": "  Gets the value of the specified field from this time as an int. This queries this time for the value of the specified field. The returned value will always be within the valid range of values for the field. If it is not possible to return the value, because the field is not supported or for some other reason, an exception is thrown. If the field is a ChronoField then the query is implemented here. The supported fields will return valid values based on this time, except NANO_OF_DAY and MICRO_OF_DAY which are too large to fit in an int and throw a DateTimeException. All other ChronoField instances will throw an UnsupportedTemporalTypeException. If the field is not a ChronoField, then the result of this method is obtained by invoking TemporalField.getFrom(TemporalAccessor) passing this as the argument. Whether the value can be obtained, and what the value represents, is determined by the field.    ", "parameters": [{"scri": "TemporalField: the field to get, not null", "name": "field"}]}, {"returns": [{"scri": "true if the unit can be added/subtracted, false if not", "type": "boolean"}], "class": "java.time.Year\n", "type": "boolean", "name": "isSupported", "throws": null, "funcname": "boolean isSupported (TemporalUnit unit)", "descri": "  Checks if the specified unit is supported. This checks if the specified unit can be added to, or subtracted from, this offset-time. If false, then calling the plus(long, TemporalUnit) and minus methods will throw an exception. If the unit is a ChronoUnit then the query is implemented here. The supported units are: NANOS MICROS MILLIS SECONDS MINUTES HOURS HALF_DAYS All other ChronoUnit instances will return false. If the unit is not a ChronoUnit, then the result of this method is obtained by invoking TemporalUnit.isSupportedBy(Temporal) passing this as the argument. Whether the unit is supported is determined by the unit.  ", "parameters": [{"scri": "TemporalUnit: the unit to check, null returns false", "name": "unit"}]}, {"returns": [{"scri": "true if the field is supported on this time, false if not", "type": "boolean"}], "class": "java.time.Year\n", "type": "boolean", "name": "isSupported", "throws": null, "funcname": "boolean isSupported (TemporalField field)", "descri": "  Checks if the specified field is supported. This checks if this time can be queried for the specified field. If false, then calling the range, get and with(TemporalField, long) methods will throw an exception. If the field is a ChronoField then the query is implemented here. The supported fields are: NANO_OF_SECOND NANO_OF_DAY MICRO_OF_SECOND MICRO_OF_DAY MILLI_OF_SECOND MILLI_OF_DAY SECOND_OF_MINUTE SECOND_OF_DAY MINUTE_OF_HOUR MINUTE_OF_DAY HOUR_OF_AMPM CLOCK_HOUR_OF_AMPM HOUR_OF_DAY CLOCK_HOUR_OF_DAY AMPM_OF_DAY OFFSET_SECONDS All other ChronoField instances will return false. If the field is not a ChronoField, then the result of this method is obtained by invoking TemporalField.isSupportedBy(TemporalAccessor) passing this as the argument. Whether the field is supported is determined by the field.  ", "parameters": [{"scri": "TemporalField: the field to check, null returns false", "name": "field"}]}, {"returns": [{"scri": "the amount of time between this time and the end time", "type": "long"}], "class": "java.time.Year\n", "type": "long", "name": "until", "throws": [{"scri": "if the amount cannot be calculated, or the end  temporal cannot be converted to an OffsetTime", "type": "DateTimeException"}, {"scri": "if the unit is not supported", "type": "UnsupportedTemporalTypeException"}, {"scri": "if numeric overflow occurs", "type": "ArithmeticException"}], "funcname": "long until (Temporal endExclusive,                 TemporalUnit unit)", "descri": "  Calculates the amount of time until another time in terms of the specified unit. This calculates the amount of time between two OffsetTime objects in terms of a single TemporalUnit. The start and end points are this and the specified time. The result will be negative if the end is before the start. For example, the amount in hours between two times can be calculated using startTime.until(endTime, HOURS). The Temporal passed to this method is converted to a OffsetTime using from(TemporalAccessor). If the offset differs between the two times, then the specified end time is normalized to have the same offset as this time. The calculation returns a whole number, representing the number of complete units between the two times. For example, the amount in hours between 11:30Z and 13:29Z will only be one hour as it is one minute short of two hours. There are two equivalent ways of using this method. The first is to invoke this method. The second is to use between(Temporal, Temporal): // these two lines are equivalent   amount = start.until(end, MINUTES);   amount = MINUTES.between(start, end); The choice should be made based on which makes the code more readable. The calculation is implemented in this method for ChronoUnit. The units NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS and HALF_DAYS are supported. Other ChronoUnit values will throw an exception. If the unit is not a ChronoUnit, then the result of this method is obtained by invoking TemporalUnit.between(Temporal, Temporal) passing this as the first argument and the converted input temporal as the second argument. This instance is immutable and unaffected by this method call.    ", "parameters": [{"scri": "Temporal: the end time, exclusive, which is converted to an OffsetTime, not null", "name": "endExclusive"}, {"scri": "TemporalUnit: the unit to measure the amount in, not null", "name": "unit"}]}, {"returns": [{"scri": "an array containing all of the elements in this collection", "type": "T[]"}], "class": "java.util.AbstractMap.SimpleImmutableEntry\n", "type": "<T>\n        T[]", "name": "toArray", "throws": [{"scri": "", "type": "ArrayStoreException"}, {"scri": "", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null.  (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() . This implementation returns an array containing all the elements returned by this collection's iterator in the same order, stored in consecutive elements of the array, starting with index 0. If the number of elements returned by the iterator is too large to fit into the specified array, then the elements are returned in a newly allocated array with length equal to the number of elements returned by the iterator, even if the size of this collection changes during iteration, as might happen if the collection permits concurrent modification during iteration.  The size method is called only as an optimization hint; the correct result is returned even if the iterator returns a different number of elements. This method is equivalent to: List<E> list = new ArrayList<E>(size()); for (E e : this)     list.add(e); return list.toArray(a);    ", "parameters": [{"scri": "T: the array into which the elements of this collection are to be        stored, if it is big enough; otherwise, a new array of the same        runtime type is allocated for this purpose.", "name": "a"}]}, {"returns": [{"scri": "true if successful. False return indicates that the actual value was not equal to the expected value.", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicLong\n", "type": "final\n        \n        boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (boolean expect,                 boolean update)", "descri": "  Atomically sets the value to the given updated value if the current value == the expected value.  ", "parameters": [{"scri": "boolean: the expected value", "name": "expect"}, {"scri": "boolean: the new value", "name": "update"}]}, {"returns": [{"scri": "the previous value", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicLong\n", "type": "final\n        \n        boolean", "name": "getAndSet", "throws": null, "funcname": "boolean getAndSet (boolean newValue)", "descri": "  Atomically sets to the given value and returns the previous value.  ", "parameters": [{"scri": "boolean: the new value", "name": "newValue"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicLong\n", "type": "boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (boolean expect,                 boolean update)", "descri": "  Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "boolean: the expected value", "name": "expect"}, {"scri": "boolean: the new value", "name": "update"}]}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLong\n", "name": "AtomicBoolean", "throws": null, "funcname": "AtomicBoolean (boolean initialValue)", "parameters": [{"scri": "boolean: the initial value", "name": "initialValue"}], "descri": "  Creates a new AtomicBoolean with the given initial value. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLong\n", "name": "AtomicBoolean", "throws": null, "funcname": "AtomicBoolean ()", "parameters": null, "descri": "  Creates a new AtomicBoolean with initial value false."}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLong\n", "name": "AtomicBoolean", "throws": null, "funcname": "AtomicBoolean (boolean initialValue)", "parameters": [{"scri": "boolean: the initial value", "name": "initialValue"}], "descri": "  Creates a new AtomicBoolean with the given initial value. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLong\n", "name": "AtomicBoolean", "throws": null, "funcname": "AtomicBoolean ()", "parameters": null, "descri": "  Creates a new AtomicBoolean with initial value false."}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "accumulateAndGet", "throws": null, "funcname": "int accumulateAndGet (int x,                 IntBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the current value with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "int: the update value", "name": "x"}, {"scri": "IntBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "addAndGet", "throws": null, "funcname": "int addAndGet (int delta)", "descri": "  Atomically adds the given value to the current value.  ", "parameters": [{"scri": "int: the value to add", "name": "delta"}]}, {"returns": [{"scri": "true if successful. False return indicates that the actual value was not equal to the expected value.", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (int expect,                 int update)", "descri": "  Atomically sets the value to the given updated value if the current value == the expected value.  ", "parameters": [{"scri": "int: the expected value", "name": "expect"}, {"scri": "int: the new value", "name": "update"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "decrementAndGet", "throws": null, "funcname": "int decrementAndGet ()", "descri": "  Atomically decrements by one the current value. ", "parameters": null}, {"returns": [{"scri": "the numeric value represented by this object after conversion          to type double.", "type": "double"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "double", "name": "doubleValue", "throws": null, "funcname": "double doubleValue ()", "descri": "  Returns the value of this AtomicInteger as a double after a widening primitive conversion. ", "parameters": null}, {"returns": [{"scri": "the numeric value represented by this object after conversion          to type float.", "type": "float"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "float", "name": "floatValue", "throws": null, "funcname": "float floatValue ()", "descri": "  Returns the value of this AtomicInteger as a float after a widening primitive conversion. ", "parameters": null}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "getAndAccumulate", "throws": null, "funcname": "int getAndAccumulate (int x,                 IntBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the current value with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "int: the update value", "name": "x"}, {"scri": "IntBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "getAndAdd", "throws": null, "funcname": "int getAndAdd (int delta)", "descri": "  Atomically adds the given value to the current value.  ", "parameters": [{"scri": "int: the value to add", "name": "delta"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "getAndDecrement", "throws": null, "funcname": "int getAndDecrement ()", "descri": "  Atomically decrements by one the current value. ", "parameters": null}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "getAndIncrement", "throws": null, "funcname": "int getAndIncrement ()", "descri": "  Atomically increments by one the current value. ", "parameters": null}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "getAndSet", "throws": null, "funcname": "int getAndSet (int newValue)", "descri": "  Atomically sets to the given value and returns the old value.  ", "parameters": [{"scri": "int: the new value", "name": "newValue"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "getAndUpdate", "throws": null, "funcname": "int getAndUpdate (IntUnaryOperator updateFunction)", "descri": "  Atomically updates the current value with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "IntUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "incrementAndGet", "throws": null, "funcname": "int incrementAndGet ()", "descri": "  Atomically increments by one the current value. ", "parameters": null}, {"returns": [{"scri": "the numeric value represented by this object after conversion          to type int.", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "int", "name": "intValue", "throws": null, "funcname": "int intValue ()", "descri": "  Returns the value of this AtomicInteger as an int. Equivalent to get(). ", "parameters": null}, {"returns": [{"scri": "the numeric value represented by this object after conversion          to type long.", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "long", "name": "longValue", "throws": null, "funcname": "long longValue ()", "descri": "  Returns the value of this AtomicInteger as a long after a widening primitive conversion. ", "parameters": null}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        int", "name": "updateAndGet", "throws": null, "funcname": "int updateAndGet (IntUnaryOperator updateFunction)", "descri": "  Atomically updates the current value with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "IntUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicLongArray\n", "type": "final\n        \n        boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (int expect,                 int update)", "descri": "  Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "int: the expected value", "name": "expect"}, {"scri": "int: the new value", "name": "update"}]}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLongArray\n", "name": "AtomicInteger", "throws": null, "funcname": "AtomicInteger (int initialValue)", "parameters": [{"scri": "int: the initial value", "name": "initialValue"}], "descri": "  Creates a new AtomicInteger with the given initial value. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLongArray\n", "name": "AtomicInteger", "throws": null, "funcname": "AtomicInteger ()", "parameters": null, "descri": "  Creates a new AtomicInteger with initial value 0."}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLongArray\n", "name": "AtomicInteger", "throws": null, "funcname": "AtomicInteger (int initialValue)", "parameters": [{"scri": "int: the initial value", "name": "initialValue"}], "descri": "  Creates a new AtomicInteger with the given initial value. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLongArray\n", "name": "AtomicInteger", "throws": null, "funcname": "AtomicInteger ()", "parameters": null, "descri": "  Creates a new AtomicInteger with initial value 0."}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "accumulateAndGet", "throws": null, "funcname": "int accumulateAndGet (int i,                 int x,                 IntBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value at index i as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "int: the update value", "name": "x"}, {"scri": "IntBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "addAndGet", "throws": null, "funcname": "int addAndGet (int i,                 int delta)", "descri": "  Atomically adds the given value to the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "int: the value to add", "name": "delta"}]}, {"returns": [{"scri": "true if successful. False return indicates that the actual value was not equal to the expected value.", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (int i,                 int expect,                 int update)", "descri": "  Atomically sets the element at position i to the given updated value if the current value == the expected value.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "int: the expected value", "name": "expect"}, {"scri": "int: the new value", "name": "update"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "decrementAndGet", "throws": null, "funcname": "int decrementAndGet (int i)", "descri": "  Atomically decrements by one the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "getAndAccumulate", "throws": null, "funcname": "int getAndAccumulate (int i,                 int x,                 IntBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value at index i as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "int: the update value", "name": "x"}, {"scri": "IntBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "getAndAdd", "throws": null, "funcname": "int getAndAdd (int i,                 int delta)", "descri": "  Atomically adds the given value to the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "int: the value to add", "name": "delta"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "getAndDecrement", "throws": null, "funcname": "int getAndDecrement (int i)", "descri": "  Atomically decrements by one the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "getAndIncrement", "throws": null, "funcname": "int getAndIncrement (int i)", "descri": "  Atomically increments by one the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "getAndSet", "throws": null, "funcname": "int getAndSet (int i,                 int newValue)", "descri": "  Atomically sets the element at position i to the given value and returns the old value.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "int: the new value", "name": "newValue"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "getAndUpdate", "throws": null, "funcname": "int getAndUpdate (int i,                 IntUnaryOperator updateFunction)", "descri": "  Atomically updates the element at index i with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "IntUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "incrementAndGet", "throws": null, "funcname": "int incrementAndGet (int i)", "descri": "  Atomically increments by one the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        int", "name": "updateAndGet", "throws": null, "funcname": "int updateAndGet (int i,                 IntUnaryOperator updateFunction)", "descri": "  Atomically updates the element at index i with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "IntUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "type": "final\n        \n        boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (int i,                 int expect,                 int update)", "descri": "  Atomically sets the element at position i to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "int: the expected value", "name": "expect"}, {"scri": "int: the new value", "name": "update"}]}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "name": "AtomicIntegerArray", "throws": null, "funcname": "AtomicIntegerArray (int length)", "parameters": [{"scri": "int: the length of the array", "name": "length"}], "descri": "  Creates a new AtomicIntegerArray of the given length, with all elements initially zero. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "name": "AtomicIntegerArray", "throws": [{"scri": "if array is null", "type": "NullPointerException"}], "funcname": "AtomicIntegerArray (int[] array)", "parameters": [{"scri": "int: the array to copy elements from", "name": "array"}], "descri": "  Creates a new AtomicIntegerArray with the same length as, and all elements copied from, the given array.   "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "name": "AtomicIntegerArray", "throws": null, "funcname": "AtomicIntegerArray (int length)", "parameters": [{"scri": "int: the length of the array", "name": "length"}], "descri": "  Creates a new AtomicIntegerArray of the given length, with all elements initially zero. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicLongFieldUpdater\n", "name": "AtomicIntegerArray", "throws": [{"scri": "if array is null", "type": "NullPointerException"}], "funcname": "AtomicIntegerArray (int[] array)", "parameters": [{"scri": "int: the array to copy elements from", "name": "array"}], "descri": "  Creates a new AtomicIntegerArray with the same length as, and all elements copied from, the given array.   "}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "final\n        \n        int", "name": "accumulateAndGet", "throws": null, "funcname": "int accumulateAndGet (T obj,                 int x,                 IntBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "int: the update value", "name": "x"}, {"scri": "IntBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "int", "name": "addAndGet", "throws": null, "funcname": "int addAndGet (T obj,                 int delta)", "descri": "  Atomically adds the given value to the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "int: the value to add", "name": "delta"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "compareAndSet", "throws": [{"scri": "if obj is not an instance of the class possessing the field established in the constructor", "type": "ClassCastException"}], "funcname": "boolean compareAndSet (T obj,                 int expect,                 int update)", "descri": "  Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field.    ", "parameters": [{"scri": "T: An object whose field to conditionally set", "name": "obj"}, {"scri": "int: the expected value", "name": "expect"}, {"scri": "int: the new value", "name": "update"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "int", "name": "decrementAndGet", "throws": null, "funcname": "int decrementAndGet (T obj)", "descri": "  Atomically decrements by one the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "final\n        \n        int", "name": "getAndAccumulate", "throws": null, "funcname": "int getAndAccumulate (T obj,                 int x,                 IntBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "int: the update value", "name": "x"}, {"scri": "IntBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "int", "name": "getAndAdd", "throws": null, "funcname": "int getAndAdd (T obj,                 int delta)", "descri": "  Atomically adds the given value to the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "int: the value to add", "name": "delta"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "int", "name": "getAndDecrement", "throws": null, "funcname": "int getAndDecrement (T obj)", "descri": "  Atomically decrements by one the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "int", "name": "getAndIncrement", "throws": null, "funcname": "int getAndIncrement (T obj)", "descri": "  Atomically increments by one the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "int", "name": "getAndSet", "throws": null, "funcname": "int getAndSet (T obj,                 int newValue)", "descri": "  Atomically sets the field of the given object managed by this updater to the given value and returns the old value.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "int: the new value", "name": "newValue"}]}, {"returns": [{"scri": "the previous value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "final\n        \n        int", "name": "getAndUpdate", "throws": null, "funcname": "int getAndUpdate (T obj,                 IntUnaryOperator updateFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "IntUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "int", "name": "incrementAndGet", "throws": null, "funcname": "int incrementAndGet (T obj)", "descri": "  Atomically increments by one the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}]}, {"returns": [{"scri": "the updated value", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "final\n        \n        int", "name": "updateAndGet", "throws": null, "funcname": "int updateAndGet (T obj,                 IntUnaryOperator updateFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "IntUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicMarkableReference\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "weakCompareAndSet", "throws": [{"scri": "if obj is not an instance of the class possessing the field established in the constructor", "type": "ClassCastException"}], "funcname": "boolean weakCompareAndSet (T obj,                 int expect,                 int update)", "descri": "  Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.    ", "parameters": [{"scri": "T: An object whose field to conditionally set", "name": "obj"}, {"scri": "int: the expected value", "name": "expect"}, {"scri": "int: the new value", "name": "update"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "accumulateAndGet", "throws": null, "funcname": "long accumulateAndGet (long x,                 LongBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the current value with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "long: the update value", "name": "x"}, {"scri": "LongBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "addAndGet", "throws": null, "funcname": "long addAndGet (long delta)", "descri": "  Atomically adds the given value to the current value.  ", "parameters": [{"scri": "long: the value to add", "name": "delta"}]}, {"returns": [{"scri": "true if successful. False return indicates that the actual value was not equal to the expected value.", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (long expect,                 long update)", "descri": "  Atomically sets the value to the given updated value if the current value == the expected value.  ", "parameters": [{"scri": "long: the expected value", "name": "expect"}, {"scri": "long: the new value", "name": "update"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "decrementAndGet", "throws": null, "funcname": "long decrementAndGet ()", "descri": "  Atomically decrements by one the current value. ", "parameters": null}, {"returns": [{"scri": "the numeric value represented by this object after conversion          to type double.", "type": "double"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "double", "name": "doubleValue", "throws": null, "funcname": "double doubleValue ()", "descri": "  Returns the value of this AtomicLong as a double after a widening primitive conversion. ", "parameters": null}, {"returns": [{"scri": "the numeric value represented by this object after conversion          to type float.", "type": "float"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "float", "name": "floatValue", "throws": null, "funcname": "float floatValue ()", "descri": "  Returns the value of this AtomicLong as a float after a widening primitive conversion. ", "parameters": null}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "getAndAccumulate", "throws": null, "funcname": "long getAndAccumulate (long x,                 LongBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the current value with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "long: the update value", "name": "x"}, {"scri": "LongBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "getAndAdd", "throws": null, "funcname": "long getAndAdd (long delta)", "descri": "  Atomically adds the given value to the current value.  ", "parameters": [{"scri": "long: the value to add", "name": "delta"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "getAndDecrement", "throws": null, "funcname": "long getAndDecrement ()", "descri": "  Atomically decrements by one the current value. ", "parameters": null}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "getAndIncrement", "throws": null, "funcname": "long getAndIncrement ()", "descri": "  Atomically increments by one the current value. ", "parameters": null}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "getAndSet", "throws": null, "funcname": "long getAndSet (long newValue)", "descri": "  Atomically sets to the given value and returns the old value.  ", "parameters": [{"scri": "long: the new value", "name": "newValue"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "getAndUpdate", "throws": null, "funcname": "long getAndUpdate (LongUnaryOperator updateFunction)", "descri": "  Atomically updates the current value with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "LongUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "incrementAndGet", "throws": null, "funcname": "long incrementAndGet ()", "descri": "  Atomically increments by one the current value. ", "parameters": null}, {"returns": [{"scri": "the numeric value represented by this object after conversion          to type int.", "type": "int"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "int", "name": "intValue", "throws": null, "funcname": "int intValue ()", "descri": "  Returns the value of this AtomicLong as an int after a narrowing primitive conversion. ", "parameters": null}, {"returns": [{"scri": "the numeric value represented by this object after conversion          to type long.", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "long", "name": "longValue", "throws": null, "funcname": "long longValue ()", "descri": "  Returns the value of this AtomicLong as a long. Equivalent to get(). ", "parameters": null}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        long", "name": "updateAndGet", "throws": null, "funcname": "long updateAndGet (LongUnaryOperator updateFunction)", "descri": "  Atomically updates the current value with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "LongUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicReference\n", "type": "final\n        \n        boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (long expect,                 long update)", "descri": "  Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "long: the expected value", "name": "expect"}, {"scri": "long: the new value", "name": "update"}]}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicReference\n", "name": "AtomicLong", "throws": null, "funcname": "AtomicLong (long initialValue)", "parameters": [{"scri": "long: the initial value", "name": "initialValue"}], "descri": "  Creates a new AtomicLong with the given initial value. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicReference\n", "name": "AtomicLong", "throws": null, "funcname": "AtomicLong ()", "parameters": null, "descri": "  Creates a new AtomicLong with initial value 0."}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicReference\n", "name": "AtomicLong", "throws": null, "funcname": "AtomicLong (long initialValue)", "parameters": [{"scri": "long: the initial value", "name": "initialValue"}], "descri": "  Creates a new AtomicLong with the given initial value. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicReference\n", "name": "AtomicLong", "throws": null, "funcname": "AtomicLong ()", "parameters": null, "descri": "  Creates a new AtomicLong with initial value 0."}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "accumulateAndGet", "throws": null, "funcname": "long accumulateAndGet (int i,                 long x,                 LongBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value at index i as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "long: the update value", "name": "x"}, {"scri": "LongBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "long", "name": "addAndGet", "throws": null, "funcname": "long addAndGet (int i,                 long delta)", "descri": "  Atomically adds the given value to the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "long: the value to add", "name": "delta"}]}, {"returns": [{"scri": "true if successful. False return indicates that the actual value was not equal to the expected value.", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (int i,                 long expect,                 long update)", "descri": "  Atomically sets the element at position i to the given updated value if the current value == the expected value.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "long: the expected value", "name": "expect"}, {"scri": "long: the new value", "name": "update"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "decrementAndGet", "throws": null, "funcname": "long decrementAndGet (int i)", "descri": "  Atomically decrements by one the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "getAndAccumulate", "throws": null, "funcname": "long getAndAccumulate (int i,                 long x,                 LongBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value at index i as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "long: the update value", "name": "x"}, {"scri": "LongBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "getAndAdd", "throws": null, "funcname": "long getAndAdd (int i,                 long delta)", "descri": "  Atomically adds the given value to the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "long: the value to add", "name": "delta"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "getAndDecrement", "throws": null, "funcname": "long getAndDecrement (int i)", "descri": "  Atomically decrements by one the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "getAndIncrement", "throws": null, "funcname": "long getAndIncrement (int i)", "descri": "  Atomically increments by one the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "getAndSet", "throws": null, "funcname": "long getAndSet (int i,                 long newValue)", "descri": "  Atomically sets the element at position i to the given value and returns the old value.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "long: the new value", "name": "newValue"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "getAndUpdate", "throws": null, "funcname": "long getAndUpdate (int i,                 LongUnaryOperator updateFunction)", "descri": "  Atomically updates the element at index i with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "LongUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "incrementAndGet", "throws": null, "funcname": "long incrementAndGet (int i)", "descri": "  Atomically increments by one the element at index i.  ", "parameters": [{"scri": "int: the index", "name": "i"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        long", "name": "updateAndGet", "throws": null, "funcname": "long updateAndGet (int i,                 LongUnaryOperator updateFunction)", "descri": "  Atomically updates the element at index i with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "LongUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "type": "final\n        \n        boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (int i,                 long expect,                 long update)", "descri": "  Atomically sets the element at position i to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "int: the index", "name": "i"}, {"scri": "long: the expected value", "name": "expect"}, {"scri": "long: the new value", "name": "update"}]}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "name": "AtomicLongArray", "throws": null, "funcname": "AtomicLongArray (int length)", "parameters": [{"scri": "int: the length of the array", "name": "length"}], "descri": "  Creates a new AtomicLongArray of the given length, with all elements initially zero. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "name": "AtomicLongArray", "throws": [{"scri": "if array is null", "type": "NullPointerException"}], "funcname": "AtomicLongArray (long[] array)", "parameters": [{"scri": "long: the array to copy elements from", "name": "array"}], "descri": "  Creates a new AtomicLongArray with the same length as, and all elements copied from, the given array.   "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "name": "AtomicLongArray", "throws": null, "funcname": "AtomicLongArray (int length)", "parameters": [{"scri": "int: the length of the array", "name": "length"}], "descri": "  Creates a new AtomicLongArray of the given length, with all elements initially zero. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicReferenceArray\n", "name": "AtomicLongArray", "throws": [{"scri": "if array is null", "type": "NullPointerException"}], "funcname": "AtomicLongArray (long[] array)", "parameters": [{"scri": "long: the array to copy elements from", "name": "array"}], "descri": "  Creates a new AtomicLongArray with the same length as, and all elements copied from, the given array.   "}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "final\n        \n        long", "name": "accumulateAndGet", "throws": null, "funcname": "long accumulateAndGet (T obj,                 long x,                 LongBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "long: the update value", "name": "x"}, {"scri": "LongBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "long", "name": "addAndGet", "throws": null, "funcname": "long addAndGet (T obj,                 long delta)", "descri": "  Atomically adds the given value to the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "long: the value to add", "name": "delta"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "compareAndSet", "throws": [{"scri": "if obj is not an instance of the class possessing the field established in the constructor", "type": "ClassCastException"}], "funcname": "boolean compareAndSet (T obj,                 long expect,                 long update)", "descri": "  Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field.    ", "parameters": [{"scri": "T: An object whose field to conditionally set", "name": "obj"}, {"scri": "long: the expected value", "name": "expect"}, {"scri": "long: the new value", "name": "update"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "long", "name": "decrementAndGet", "throws": null, "funcname": "long decrementAndGet (T obj)", "descri": "  Atomically decrements by one the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "final\n        \n        long", "name": "getAndAccumulate", "throws": null, "funcname": "long getAndAccumulate (T obj,                 long x,                 LongBinaryOperator accumulatorFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "long: the update value", "name": "x"}, {"scri": "LongBinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "long", "name": "getAndAdd", "throws": null, "funcname": "long getAndAdd (T obj,                 long delta)", "descri": "  Atomically adds the given value to the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "long: the value to add", "name": "delta"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "long", "name": "getAndDecrement", "throws": null, "funcname": "long getAndDecrement (T obj)", "descri": "  Atomically decrements by one the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "long", "name": "getAndIncrement", "throws": null, "funcname": "long getAndIncrement (T obj)", "descri": "  Atomically increments by one the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "long", "name": "getAndSet", "throws": null, "funcname": "long getAndSet (T obj,                 long newValue)", "descri": "  Atomically sets the field of the given object managed by this updater to the given value and returns the old value.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "long: the new value", "name": "newValue"}]}, {"returns": [{"scri": "the previous value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "final\n        \n        long", "name": "getAndUpdate", "throws": null, "funcname": "long getAndUpdate (T obj,                 LongUnaryOperator updateFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "LongUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "long", "name": "incrementAndGet", "throws": null, "funcname": "long incrementAndGet (T obj)", "descri": "  Atomically increments by one the current value of the field of the given object managed by this updater.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}]}, {"returns": [{"scri": "the updated value", "type": "long"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "final\n        \n        long", "name": "updateAndGet", "throws": null, "funcname": "long updateAndGet (T obj,                 LongUnaryOperator updateFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "LongUnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicReferenceFieldUpdater\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "weakCompareAndSet", "throws": [{"scri": "if obj is not an instance of the class possessing the field established in the constructor", "type": "ClassCastException"}], "funcname": "boolean weakCompareAndSet (T obj,                 long expect,                 long update)", "descri": "  Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.    ", "parameters": [{"scri": "T: An object whose field to conditionally set", "name": "obj"}, {"scri": "long: the expected value", "name": "expect"}, {"scri": "long: the new value", "name": "update"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicStampedReference\n", "type": "boolean", "name": "attemptMark", "throws": null, "funcname": "boolean attemptMark (V expectedReference,                 boolean newMark)", "descri": "  Atomically sets the value of the mark to the given update value if the current reference is == to the expected reference.  Any given invocation of this operation may fail (return false) spuriously, but repeated invocation when the current value holds the expected value and no other thread is also attempting to set the value will eventually succeed.  ", "parameters": [{"scri": "V: the expected value of the reference", "name": "expectedReference"}, {"scri": "boolean: the new value for the mark", "name": "newMark"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicStampedReference\n", "type": "boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (V expectedReference,                 V newReference,                 boolean expectedMark,                 boolean newMark)", "descri": "  Atomically sets the value of both the reference and mark to the given update values if the current reference is == to the expected reference and the current mark is equal to the expected mark.  ", "parameters": [{"scri": "V: the expected value of the reference", "name": "expectedReference"}, {"scri": "V: the new value for the reference", "name": "newReference"}, {"scri": "boolean: the expected value of the mark", "name": "expectedMark"}, {"scri": "boolean: the new value for the mark", "name": "newMark"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.AtomicStampedReference\n", "type": "boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (V expectedReference,                 V newReference,                 boolean expectedMark,                 boolean newMark)", "descri": "  Atomically sets the value of both the reference and mark to the given update values if the current reference is == to the expected reference and the current mark is equal to the expected mark. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "V: the expected value of the reference", "name": "expectedReference"}, {"scri": "V: the new value for the reference", "name": "newReference"}, {"scri": "boolean: the expected value of the mark", "name": "expectedMark"}, {"scri": "boolean: the new value for the mark", "name": "newMark"}]}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicStampedReference\n", "name": "AtomicMarkableReference", "throws": null, "funcname": "AtomicMarkableReference (V initialRef,                 boolean initialMark)", "parameters": [{"scri": "V: the initial reference", "name": "initialRef"}, {"scri": "boolean: the initial mark", "name": "initialMark"}], "descri": "  Creates a new AtomicMarkableReference with the given initial values. "}, {"returns": null, "class": "java.util.concurrent.atomic.AtomicStampedReference\n", "name": "AtomicMarkableReference", "throws": null, "funcname": "AtomicMarkableReference (V initialRef,                 boolean initialMark)", "parameters": [{"scri": "V: the initial reference", "name": "initialRef"}, {"scri": "boolean: the initial mark", "name": "initialMark"}], "descri": "  Creates a new AtomicMarkableReference with the given initial values. "}, {"returns": [{"scri": "the updated value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "type": "final\n        \n        V", "name": "accumulateAndGet", "throws": null, "funcname": "V accumulateAndGet (V x,                 BinaryOperator<V> accumulatorFunction)", "descri": "  Atomically updates the current value with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "V: the update value", "name": "x"}, {"scri": "BinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "true if successful. False return indicates that the actual value was not equal to the expected value.", "type": "boolean"}], "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "type": "final\n        \n        boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (V expect,                 V update)", "descri": "  Atomically sets the value to the given updated value if the current value == the expected value.  ", "parameters": [{"scri": "V: the expected value", "name": "expect"}, {"scri": "V: the new value", "name": "update"}]}, {"returns": [{"scri": "the previous value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "type": "final\n        \n        V", "name": "getAndAccumulate", "throws": null, "funcname": "V getAndAccumulate (V x,                 BinaryOperator<V> accumulatorFunction)", "descri": "  Atomically updates the current value with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "V: the update value", "name": "x"}, {"scri": "BinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the previous value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "type": "final\n        \n        V", "name": "getAndSet", "throws": null, "funcname": "V getAndSet (V newValue)", "descri": "  Atomically sets to the given value and returns the old value.  ", "parameters": [{"scri": "V: the new value", "name": "newValue"}]}, {"returns": [{"scri": "the previous value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "type": "final\n        \n        V", "name": "getAndUpdate", "throws": null, "funcname": "V getAndUpdate (UnaryOperator<V> updateFunction)", "descri": "  Atomically updates the current value with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "UnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "the updated value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "type": "final\n        \n        V", "name": "updateAndGet", "throws": null, "funcname": "V updateAndGet (UnaryOperator<V> updateFunction)", "descri": "  Atomically updates the current value with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "UnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "type": "final\n        \n        boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (V expect,                 V update)", "descri": "  Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "V: the expected value", "name": "expect"}, {"scri": "V: the new value", "name": "update"}]}, {"returns": null, "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "name": "AtomicReference", "throws": null, "funcname": "AtomicReference (V initialValue)", "parameters": [{"scri": "V: the initial value", "name": "initialValue"}], "descri": "  Creates a new AtomicReference with the given initial value. "}, {"returns": null, "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "name": "AtomicReference", "throws": null, "funcname": "AtomicReference ()", "parameters": null, "descri": "  Creates a new AtomicReference with null initial value."}, {"returns": null, "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "name": "AtomicReference", "throws": null, "funcname": "AtomicReference (V initialValue)", "parameters": [{"scri": "V: the initial value", "name": "initialValue"}], "descri": "  Creates a new AtomicReference with the given initial value. "}, {"returns": null, "class": "java.util.concurrent.atomic.DoubleAccumulator\n", "name": "AtomicReference", "throws": null, "funcname": "AtomicReference ()", "parameters": null, "descri": "  Creates a new AtomicReference with null initial value."}, {"returns": [{"scri": "the updated value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAdder\n", "type": "final\n        \n        V", "name": "accumulateAndGet", "throws": null, "funcname": "V accumulateAndGet (T obj,                 V x,                 BinaryOperator<V> accumulatorFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "V: the update value", "name": "x"}, {"scri": "BinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.DoubleAdder\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (T obj,                 V expect,                 V update)", "descri": "  Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field.  ", "parameters": [{"scri": "T: An object whose field to conditionally set", "name": "obj"}, {"scri": "V: the expected value", "name": "expect"}, {"scri": "V: the new value", "name": "update"}]}, {"returns": [{"scri": "the previous value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAdder\n", "type": "final\n        \n        V", "name": "getAndAccumulate", "throws": null, "funcname": "V getAndAccumulate (T obj,                 V x,                 BinaryOperator<V> accumulatorFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  The function is applied with the current value as its first argument, and the given update as the second argument.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "V: the update value", "name": "x"}, {"scri": "BinaryOperator: a side-effect-free function of two arguments", "name": "accumulatorFunction"}]}, {"returns": [{"scri": "the previous value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAdder\n", "type": "V", "name": "getAndSet", "throws": null, "funcname": "V getAndSet (T obj,                 V newValue)", "descri": "  Atomically sets the field of the given object managed by this updater to the given value and returns the old value.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "V: the new value", "name": "newValue"}]}, {"returns": [{"scri": "the previous value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAdder\n", "type": "final\n        \n        V", "name": "getAndUpdate", "throws": null, "funcname": "V getAndUpdate (T obj,                 UnaryOperator<V> updateFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "UnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "the updated value", "type": "V"}], "class": "java.util.concurrent.atomic.DoubleAdder\n", "type": "final\n        \n        V", "name": "updateAndGet", "throws": null, "funcname": "V updateAndGet (T obj,                 UnaryOperator<V> updateFunction)", "descri": "  Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.  ", "parameters": [{"scri": "T: An object whose field to get and set", "name": "obj"}, {"scri": "UnaryOperator: a side-effect-free function", "name": "updateFunction"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.DoubleAdder\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (T obj,                 V expect,                 V update)", "descri": "  Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "T: An object whose field to conditionally set", "name": "obj"}, {"scri": "V: the expected value", "name": "expect"}, {"scri": "V: the new value", "name": "update"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.LongAccumulator\n", "type": "boolean", "name": "attemptStamp", "throws": null, "funcname": "boolean attemptStamp (V expectedReference,                 int newStamp)", "descri": "  Atomically sets the value of the stamp to the given update value if the current reference is == to the expected reference.  Any given invocation of this operation may fail (return false) spuriously, but repeated invocation when the current value holds the expected value and no other thread is also attempting to set the value will eventually succeed.  ", "parameters": [{"scri": "V: the expected value of the reference", "name": "expectedReference"}, {"scri": "int: the new value for the stamp", "name": "newStamp"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.LongAccumulator\n", "type": "boolean", "name": "compareAndSet", "throws": null, "funcname": "boolean compareAndSet (V expectedReference,                 V newReference,                 int expectedStamp,                 int newStamp)", "descri": "  Atomically sets the value of both the reference and stamp to the given update values if the current reference is == to the expected reference and the current stamp is equal to the expected stamp.  ", "parameters": [{"scri": "V: the expected value of the reference", "name": "expectedReference"}, {"scri": "V: the new value for the reference", "name": "newReference"}, {"scri": "int: the expected value of the stamp", "name": "expectedStamp"}, {"scri": "int: the new value for the stamp", "name": "newStamp"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.atomic.LongAccumulator\n", "type": "boolean", "name": "weakCompareAndSet", "throws": null, "funcname": "boolean weakCompareAndSet (V expectedReference,                 V newReference,                 int expectedStamp,                 int newStamp)", "descri": "  Atomically sets the value of both the reference and stamp to the given update values if the current reference is == to the expected reference and the current stamp is equal to the expected stamp. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.  ", "parameters": [{"scri": "V: the expected value of the reference", "name": "expectedReference"}, {"scri": "V: the new value for the reference", "name": "newReference"}, {"scri": "int: the expected value of the stamp", "name": "expectedStamp"}, {"scri": "int: the new value for the stamp", "name": "newStamp"}]}, {"returns": null, "class": "java.util.concurrent.atomic.LongAccumulator\n", "name": "AtomicStampedReference", "throws": null, "funcname": "AtomicStampedReference (V initialRef,                 int initialStamp)", "parameters": [{"scri": "V: the initial reference", "name": "initialRef"}, {"scri": "int: the initial stamp", "name": "initialStamp"}], "descri": "  Creates a new AtomicStampedReference with the given initial values. "}, {"returns": null, "class": "java.util.concurrent.atomic.LongAccumulator\n", "name": "AtomicStampedReference", "throws": null, "funcname": "AtomicStampedReference (V initialRef,                 int initialStamp)", "parameters": [{"scri": "V: the initial reference", "name": "initialRef"}, {"scri": "int: the initial stamp", "name": "initialStamp"}], "descri": "  Creates a new AtomicStampedReference with the given initial values. "}, {"returns": [{"scri": "the current value", "type": "double"}], "class": "java.util.concurrent.atomic.LongAdder\n", "type": "double", "name": "get", "throws": null, "funcname": "double get ()", "descri": "  Returns the current value.  The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the value is being calculated might not be incorporated. ", "parameters": null}, {"returns": [{"scri": "the new value associated with the specified key, or null if none", "type": "V"}], "class": "java.util.concurrent.ConcurrentSkipListMap\n", "type": "V", "name": "compute", "throws": [{"scri": "if the specified key or remappingFunction         is null", "type": "NullPointerException"}, {"scri": "if the computation detectably         attempts a recursive update to this map that would         otherwise never complete", "type": "IllegalStateException"}, {"scri": "or Error if the remappingFunction does so,         in which case the mapping is unchanged", "type": "RuntimeException"}], "funcname": "V compute (K key,                 BiFunction<?\u00a0super\u00a0K,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "BiFunction: the function to compute a value", "name": "remappingFunction"}]}, {"returns": [{"scri": "the current (existing or computed) value associated with         the specified key, or null if the computed value is null", "type": "V"}], "class": "java.util.concurrent.ConcurrentSkipListMap\n", "type": "V", "name": "computeIfAbsent", "throws": [{"scri": "if the specified key or mappingFunction         is null", "type": "NullPointerException"}, {"scri": "if the computation detectably         attempts a recursive update to this map that would         otherwise never complete", "type": "IllegalStateException"}, {"scri": "or Error if the mappingFunction does so,         in which case the mapping is left unestablished", "type": "RuntimeException"}], "funcname": "V computeIfAbsent (K key,                 Function<?\u00a0super\u00a0K,\u00a0?\u00a0extends\u00a0V> mappingFunction)", "descri": "  If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null.  The entire method invocation is performed atomically, so the function is applied at most once per key.  Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "Function: the function to compute a value", "name": "mappingFunction"}]}, {"returns": [{"scri": "the new value associated with the specified key, or null if none", "type": "V"}], "class": "java.util.concurrent.ConcurrentSkipListMap\n", "type": "V", "name": "computeIfPresent", "throws": [{"scri": "if the specified key or remappingFunction         is null", "type": "NullPointerException"}, {"scri": "if the computation detectably         attempts a recursive update to this map that would         otherwise never complete", "type": "IllegalStateException"}, {"scri": "or Error if the remappingFunction does so,         in which case the mapping is unchanged", "type": "RuntimeException"}], "funcname": "V computeIfPresent (K key,                 BiFunction<?\u00a0super\u00a0K,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value.  The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.    ", "parameters": [{"scri": "K: key with which a value may be associated", "name": "key"}, {"scri": "BiFunction: the function to compute a value", "name": "remappingFunction"}]}, {"returns": [{"scri": "the new value associated with the specified key, or null if none", "type": "V"}], "class": "java.util.concurrent.ConcurrentSkipListMap\n", "type": "V", "name": "merge", "throws": [{"scri": "if the specified key or the         remappingFunction is null", "type": "NullPointerException"}, {"scri": "or Error if the remappingFunction does so,         in which case the mapping is unchanged", "type": "RuntimeException"}], "funcname": "V merge (K key,                 V value,                 BiFunction<?\u00a0super\u00a0V,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if null. The entire method invocation is performed atomically.  Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "V: the value to use if absent", "name": "value"}, {"scri": "BiFunction: the function to recompute a value if present", "name": "remappingFunction"}]}, {"returns": [{"scri": "the previous value associated with the specified key,         or null if there was no mapping for the key", "type": "V"}], "class": "java.util.concurrent.ConcurrentSkipListMap\n", "type": "V", "name": "putIfAbsent", "throws": [{"scri": "if the specified key or value is null", "type": "NullPointerException"}], "funcname": "V putIfAbsent (K key,                 V value)", "descri": "  If the specified key is not already associated with a value, associates it with the given value. This is equivalent to, for this map: if (!map.containsKey(key))   return map.put(key, value); else   return map.get(key); except that the action is performed atomically.   ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "V: value to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "true if the value was removed", "type": "boolean"}], "class": "java.util.concurrent.ConcurrentSkipListMap\n", "type": "V", "name": "remove", "throws": [{"scri": "if the specified key is null", "type": "NullPointerException"}], "funcname": "boolean remove (Object key,                 Object value)", "descri": "  Removes the entry for a key only if currently mapped to a given value. This is equivalent to, for this map: if (map.containsKey(key)     && Objects.equals(map.get(key), value)) {   map.remove(key);   return true; } else {   return false; } except that the action is performed atomically.   ", "parameters": [{"scri": "Object: key with which the specified value is associated", "name": "key"}, {"scri": "Object: value expected to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "true if the value was replaced", "type": "boolean"}], "class": "java.util.concurrent.ConcurrentSkipListMap\n", "type": "boolean", "name": "replace", "throws": [{"scri": "if any of the arguments are null", "type": "NullPointerException"}], "funcname": "boolean replace (K key,                 V oldValue,                 V newValue)", "descri": "  Replaces the entry for a key only if currently mapped to a given value. This is equivalent to, for this map: if (map.containsKey(key)     && Objects.equals(map.get(key), oldValue)) {   map.put(key, newValue);   return true; } else {   return false; } except that the action is performed atomically.   ", "parameters": [{"scri": "K: key with which the specified value is associated", "name": "key"}, {"scri": "V: value expected to be associated with the specified key", "name": "oldValue"}, {"scri": "V: value to be associated with the specified key", "name": "newValue"}]}, {"returns": [{"scri": "the previous value associated with the specified key,         or null if there was no mapping for the key", "type": "V"}], "class": "java.util.concurrent.ConcurrentSkipListMap\n", "type": "boolean", "name": "replace", "throws": [{"scri": "if the specified key or value is null", "type": "NullPointerException"}], "funcname": "V replace (K key,                 V value)", "descri": "  Replaces the entry for a key only if currently mapped to some value. This is equivalent to, for this map: if (map.containsKey(key))   return map.put(key, value); else   return null; except that the action is performed atomically.   ", "parameters": [{"scri": "K: key with which the specified value is associated", "name": "key"}, {"scri": "V: value to be associated with the specified key", "name": "value"}]}, {"returns": null, "class": "java.util.concurrent.ConcurrentSkipListMap\n", "name": "ConcurrentHashMap", "throws": [{"scri": "if the initial capacity of elements is negative", "type": "IllegalArgumentException"}], "funcname": "ConcurrentHashMap (int initialCapacity)", "parameters": [{"scri": "int: The implementation performs internal sizing to accommodate this many elements.", "name": "initialCapacity"}], "descri": "  Creates a new, empty map with an initial table size accommodating the specified number of elements without the need to dynamically resize.   "}, {"returns": null, "class": "java.util.concurrent.ConcurrentSkipListMap\n", "name": "ConcurrentHashMap", "throws": [{"scri": "if the initial capacity of elements is negative", "type": "IllegalArgumentException"}], "funcname": "ConcurrentHashMap (int initialCapacity)", "parameters": [{"scri": "int: The implementation performs internal sizing to accommodate this many elements.", "name": "initialCapacity"}], "descri": "  Creates a new, empty map with an initial table size accommodating the specified number of elements without the need to dynamically resize.   "}, {"returns": [{"scri": "an array containing all of the elements in this collection", "type": "T[]"}], "class": "java.util.concurrent.ConcurrentSkipListSet\n", "type": "final\n        <T>\n        T[]", "name": "toArray", "throws": null, "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null.  (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() . ", "parameters": [{"scri": "T: the array into which the elements of this collection are to be        stored, if it is big enough; otherwise, a new array of the same        runtime type is allocated for this purpose.", "name": "a"}]}, {"returns": [{"scri": "an array containing all of the elements in this deque", "type": "T[]"}], "class": "java.util.concurrent.CopyOnWriteArrayList\n", "type": "<T>\n        T[]", "name": "toArray", "throws": [{"scri": "if the runtime type of the specified array         is not a supertype of the runtime type of every element in         this deque", "type": "ArrayStoreException"}, {"scri": "if the specified array is null", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this deque, in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array.  If the deque fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() .   ", "parameters": [{"scri": "T: the array into which the elements of the deque are to          be stored, if it is big enough; otherwise, a new array of the          same runtime type is allocated for this purpose", "name": "a"}]}, {"returns": [{"scri": "an array containing all of the elements in this queue", "type": "T[]"}], "class": "java.util.concurrent.CopyOnWriteArraySet\n", "type": "<T>\n        T[]", "name": "toArray", "throws": [{"scri": "if the runtime type of the specified array         is not a supertype of the runtime type of every element in         this queue", "type": "ArrayStoreException"}, {"scri": "if the specified array is null", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array.  If the queue fits in the specified array, it is returned therein.  Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() .   ", "parameters": [{"scri": "T: the array into which the elements of the queue are to          be stored, if it is big enough; otherwise, a new array of the          same runtime type is allocated for this purpose", "name": "a"}]}, {"returns": [{"scri": "the new value associated with the specified key, or null if none", "type": "V"}], "class": "java.util.concurrent.CountDownLatch\n", "type": "V", "name": "compute", "throws": [{"scri": "if the specified key is null         or the remappingFunction is null", "type": "NullPointerException"}], "funcname": "V compute (K key,                 BiFunction<?\u00a0super\u00a0K,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). The function is NOT guaranteed to be applied once atomically.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "BiFunction: the function to compute a value", "name": "remappingFunction"}]}, {"returns": [{"scri": "the current (existing or computed) value associated with         the specified key, or null if the computed value is null", "type": "V"}], "class": "java.util.concurrent.CountDownLatch\n", "type": "V", "name": "computeIfAbsent", "throws": [{"scri": "if the specified key is null         or the mappingFunction is null", "type": "NullPointerException"}], "funcname": "V computeIfAbsent (K key,                 Function<?\u00a0super\u00a0K,\u00a0?\u00a0extends\u00a0V> mappingFunction)", "descri": "  If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null.  The function is NOT guaranteed to be applied once atomically only if the value is not present.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "Function: the function to compute a value", "name": "mappingFunction"}]}, {"returns": [{"scri": "the new value associated with the specified key, or null if none", "type": "V"}], "class": "java.util.concurrent.CountDownLatch\n", "type": "V", "name": "computeIfPresent", "throws": [{"scri": "if the specified key is null         or the remappingFunction is null", "type": "NullPointerException"}], "funcname": "V computeIfPresent (K key,                 BiFunction<?\u00a0super\u00a0K,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The function is NOT guaranteed to be applied once atomically.    ", "parameters": [{"scri": "K: key with which a value may be associated", "name": "key"}, {"scri": "BiFunction: the function to compute a value", "name": "remappingFunction"}]}, {"returns": [{"scri": "the new value associated with the specified key, or null if none", "type": "V"}], "class": "java.util.concurrent.CountDownLatch\n", "type": "V", "name": "merge", "throws": [{"scri": "if the specified key or value is null         or the remappingFunction is null", "type": "NullPointerException"}], "funcname": "V merge (K key,                 V value,                 BiFunction<?\u00a0super\u00a0V,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  If the specified key is not already associated with a value, associates it with the given value.  Otherwise, replaces the value with the results of the given remapping function, or removes if null. The function is NOT guaranteed to be applied once atomically.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "V: the value to use if absent", "name": "value"}, {"scri": "BiFunction: the function to recompute a value if present", "name": "remappingFunction"}]}, {"returns": [{"scri": "the previous value associated with the specified key,         or null if there was no mapping for the key", "type": "V"}], "class": "java.util.concurrent.CountDownLatch\n", "type": "V", "name": "putIfAbsent", "throws": [{"scri": "if the specified key cannot be compared         with the keys currently in the map", "type": "ClassCastException"}, {"scri": "if the specified key or value is null", "type": "NullPointerException"}], "funcname": "V putIfAbsent (K key,                 V value)", "descri": "  If the specified key is not already associated with a value, associates it with the given value. This is equivalent to, for this map: if (!map.containsKey(key))   return map.put(key, value); else   return map.get(key); except that the action is performed atomically.   ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "V: value to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "true if the value was removed", "type": "boolean"}], "class": "java.util.concurrent.CountDownLatch\n", "type": "boolean", "name": "remove", "throws": [{"scri": "if the specified key cannot be compared         with the keys currently in the map", "type": "ClassCastException"}, {"scri": "if the specified key is null", "type": "NullPointerException"}], "funcname": "boolean remove (Object key,                 Object value)", "descri": "  Removes the entry for a key only if currently mapped to a given value. This is equivalent to, for this map: if (map.containsKey(key)     && Objects.equals(map.get(key), value)) {   map.remove(key);   return true; } else {   return false; } except that the action is performed atomically.   ", "parameters": [{"scri": "Object: key with which the specified value is associated", "name": "key"}, {"scri": "Object: value expected to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "true if the value was replaced", "type": "boolean"}], "class": "java.util.concurrent.CountDownLatch\n", "type": "boolean", "name": "replace", "throws": [{"scri": "if the specified key cannot be compared         with the keys currently in the map", "type": "ClassCastException"}, {"scri": "if any of the arguments are null", "type": "NullPointerException"}], "funcname": "boolean replace (K key,                 V oldValue,                 V newValue)", "descri": "  Replaces the entry for a key only if currently mapped to a given value. This is equivalent to, for this map: if (map.containsKey(key)     && Objects.equals(map.get(key), oldValue)) {   map.put(key, newValue);   return true; } else {   return false; } except that the action is performed atomically.   ", "parameters": [{"scri": "K: key with which the specified value is associated", "name": "key"}, {"scri": "V: value expected to be associated with the specified key", "name": "oldValue"}, {"scri": "V: value to be associated with the specified key", "name": "newValue"}]}, {"returns": [{"scri": "the previous value associated with the specified key,         or null if there was no mapping for the key", "type": "V"}], "class": "java.util.concurrent.CountDownLatch\n", "type": "boolean", "name": "replace", "throws": [{"scri": "if the specified key cannot be compared         with the keys currently in the map", "type": "ClassCastException"}, {"scri": "if the specified key or value is null", "type": "NullPointerException"}], "funcname": "V replace (K key,                 V value)", "descri": "  Replaces the entry for a key only if currently mapped to some value. This is equivalent to, for this map: if (map.containsKey(key))   return map.put(key, value); else   return null; except that the action is performed atomically.   ", "parameters": [{"scri": "K: key with which the specified value is associated", "name": "key"}, {"scri": "V: value to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "an array containing all the elements in this set", "type": "T[]"}], "class": "java.util.concurrent.CyclicBarrier\n", "type": "<T>\n        T[]", "name": "toArray", "throws": [{"scri": "if the runtime type of the specified array         is not a supertype of the runtime type of every element in this         set", "type": "ArrayStoreException"}, {"scri": "if the specified array is null", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. If this set fits in the specified array with room to spare (i.e., the array has more elements than this set), the element in the array immediately following the end of the set is set to null.  (This is useful in determining the length of this set only if the caller knows that this set does not contain any null elements.) If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a set known to contain only strings. The following code can be used to dump the set into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() .   ", "parameters": [{"scri": "T: the array into which the elements of this set are to be        stored, if it is big enough; otherwise, a new array of the same        runtime type is allocated for this purpose.", "name": "a"}]}, {"returns": [{"scri": "the previous value associated with the specified key, or         null if there was no mapping for the key.         (A null return can also indicate that the map         previously associated null with the key,         if the implementation supports null values.)", "type": "V"}], "class": "java.util.concurrent.Executor\n", "type": "abstract\n        \n        \n        \n        \n        V", "name": "putIfAbsent", "throws": [{"scri": "if the put operation         is not supported by this map", "type": "UnsupportedOperationException"}, {"scri": "if the class of the specified key or value         prevents it from being stored in this map", "type": "ClassCastException"}, {"scri": "if the specified key or value is null,         and this map does not permit null keys or values", "type": "NullPointerException"}, {"scri": "if some property of the specified key         or value prevents it from being stored in this map", "type": "IllegalArgumentException"}], "funcname": "V putIfAbsent (K key,                 V value)", "descri": "  If the specified key is not already associated with a value, associates it with the given value. This is equivalent to, for this map: if (!map.containsKey(key))   return map.put(key, value); else   return map.get(key); except that the action is performed atomically. Implementation Note: This implementation intentionally re-abstracts the inappropriate default provided in Map.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "V: value to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "true if the value was removed", "type": "boolean"}], "class": "java.util.concurrent.Executor\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "remove", "throws": [{"scri": "if the remove operation         is not supported by this map", "type": "UnsupportedOperationException"}, {"scri": "if the key or value is of an inappropriate         type for this map (optional)", "type": "ClassCastException"}, {"scri": "if the specified key or value is null,         and this map does not permit null keys or values (optional)", "type": "NullPointerException"}], "funcname": "boolean remove (Object key,                 Object value)", "descri": "  Removes the entry for a key only if currently mapped to a given value. This is equivalent to, for this map: if (map.containsKey(key)     && Objects.equals(map.get(key), value)) {   map.remove(key);   return true; } else {   return false; } except that the action is performed atomically. Implementation Note: This implementation intentionally re-abstracts the inappropriate default provided in Map.    ", "parameters": [{"scri": "Object: key with which the specified value is associated", "name": "key"}, {"scri": "Object: value expected to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "true if the value was replaced", "type": "boolean"}], "class": "java.util.concurrent.Executor\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "replace", "throws": [{"scri": "if the put operation         is not supported by this map", "type": "UnsupportedOperationException"}, {"scri": "if the class of a specified key or value         prevents it from being stored in this map", "type": "ClassCastException"}, {"scri": "if a specified key or value is null,         and this map does not permit null keys or values", "type": "NullPointerException"}, {"scri": "if some property of a specified key         or value prevents it from being stored in this map", "type": "IllegalArgumentException"}], "funcname": "boolean replace (K key,                 V oldValue,                 V newValue)", "descri": "  Replaces the entry for a key only if currently mapped to a given value. This is equivalent to, for this map: if (map.containsKey(key)     && Objects.equals(map.get(key), oldValue)) {   map.put(key, newValue);   return true; } else {   return false; } except that the action is performed atomically. Implementation Note: This implementation intentionally re-abstracts the inappropriate default provided in Map.    ", "parameters": [{"scri": "K: key with which the specified value is associated", "name": "key"}, {"scri": "V: value expected to be associated with the specified key", "name": "oldValue"}, {"scri": "V: value to be associated with the specified key", "name": "newValue"}]}, {"returns": [{"scri": "the previous value associated with the specified key, or         null if there was no mapping for the key.         (A null return can also indicate that the map         previously associated null with the key,         if the implementation supports null values.)", "type": "V"}], "class": "java.util.concurrent.Executor\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "replace", "throws": [{"scri": "if the put operation         is not supported by this map", "type": "UnsupportedOperationException"}, {"scri": "if the class of the specified key or value         prevents it from being stored in this map", "type": "ClassCastException"}, {"scri": "if the specified key or value is null,         and this map does not permit null keys or values", "type": "NullPointerException"}, {"scri": "if some property of the specified key         or value prevents it from being stored in this map", "type": "IllegalArgumentException"}], "funcname": "V replace (K key,                 V value)", "descri": "  Replaces the entry for a key only if currently mapped to some value. This is equivalent to, for this map: if (map.containsKey(key))   return map.put(key, value); else   return null; except that the action is performed atomically. Implementation Note: This implementation intentionally re-abstracts the inappropriate default provided in Map.    ", "parameters": [{"scri": "K: key with which the specified value is associated", "name": "key"}, {"scri": "V: value to be associated with the specified key", "name": "value"}]}, {"returns": null, "class": "java.util.concurrent.ExecutorCompletionService\n", "type": "final\n        \n        void", "name": "addToPendingCount", "throws": null, "funcname": "void addToPendingCount (int delta)", "descri": "  Adds (atomically) the given value to the pending count. ", "parameters": [{"scri": "int: the value to add", "name": "delta"}]}, {"returns": [{"scri": "true if successful", "type": "boolean"}], "class": "java.util.concurrent.ExecutorCompletionService\n", "type": "final\n        \n        boolean", "name": "compareAndSetPendingCount", "throws": null, "funcname": "boolean compareAndSetPendingCount (int expected,                 int count)", "descri": "  Sets (atomically) the pending count to the given count only if it currently holds the given expected value.  ", "parameters": [{"scri": "int: the expected value", "name": "expected"}, {"scri": "int: the new value", "name": "count"}]}, {"returns": [{"scri": "the initial (undecremented) pending count holding on entry to this method", "type": "int"}], "class": "java.util.concurrent.ExecutorCompletionService\n", "type": "final\n        \n        int", "name": "decrementPendingCountUnlessZero", "throws": null, "funcname": "int decrementPendingCountUnlessZero ()", "descri": "  If the pending count is nonzero, (atomically) decrements it. ", "parameters": null}, {"returns": [{"scri": "true if successful; i.e., the current value was equal to expect and was changed to update.", "type": "boolean"}], "class": "java.util.concurrent.LinkedBlockingDeque\n", "type": "final\n        \n        boolean", "name": "compareAndSetForkJoinTaskTag", "throws": null, "funcname": "boolean compareAndSetForkJoinTaskTag (short expect,                 short update)", "descri": "  Atomically conditionally sets the tag value for this task. Among other applications, tags can be used as visit markers in tasks operating on graphs, as in methods that check: if (task.compareAndSetForkJoinTaskTag((short)0, (short)1)) before processing, otherwise exiting because the node has already been visited.  ", "parameters": [{"scri": "short: the expected tag value", "name": "expect"}, {"scri": "short: the new tag value", "name": "update"}]}, {"returns": [{"scri": "the previous value of the tag", "type": "short"}], "class": "java.util.concurrent.LinkedBlockingDeque\n", "type": "final\n        \n        short", "name": "setForkJoinTaskTag", "throws": null, "funcname": "short setForkJoinTaskTag (short newValue)", "descri": "  Atomically sets the tag value for this task and returns the old value.  ", "parameters": [{"scri": "short: the new tag value", "name": "newValue"}]}, {"returns": null, "class": "java.util.concurrent.locks.AbstractOwnableSynchronizer\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "await", "throws": [{"scri": "if the current thread is interrupted         (and interruption of thread suspension is supported)", "type": "InterruptedException"}], "funcname": "void await ()", "descri": "  Causes the current thread to wait until it is signalled or interrupted. The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens: Some other thread invokes the signal() method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll() method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or A \"spurious wakeup\" occurs.  In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.  ", "parameters": null}, {"returns": [{"scri": "an estimate of the nanosTimeout value minus         the time spent waiting upon return from this method.         A positive value may be used as the argument to a         subsequent call to this method to finish waiting out         the desired time.  A value less than or equal to zero         indicates that no time remains.", "type": "long"}], "class": "java.util.concurrent.locks.AbstractOwnableSynchronizer\n", "type": "abstract\n        \n        \n        \n        \n        long", "name": "awaitNanos", "throws": [{"scri": "if the current thread is interrupted         (and interruption of thread suspension is supported)", "type": "InterruptedException"}], "funcname": "long awaitNanos (long nanosTimeout)", "descri": "  Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of five things happens: Some other thread invokes the signal() method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll() method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or The specified waiting time elapses; or A \"spurious wakeup\" occurs.  In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. The method returns an estimate of the number of nanoseconds remaining to wait given the supplied nanosTimeout value upon return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the following form: boolean aMethod(long timeout, TimeUnit unit) {   long nanos = unit.toNanos(timeout);   lock.lock();   try {     while (!conditionBeingWaitedFor()) {       if (nanos <= 0L)         return false;       nanos = theCondition.awaitNanos(nanos);     }     // ...   } finally {     lock.unlock();   } }  Design note: This method requires a nanosecond argument so as to avoid truncation errors in reporting remaining times. Such precision loss would make it difficult for programmers to ensure that total waiting times are not systematically shorter than specified when re-waits occur. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal, or over indicating the elapse of the specified waiting time. In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.    ", "parameters": [{"scri": "long: the maximum time to wait, in nanoseconds", "name": "nanosTimeout"}]}, {"returns": null, "class": "java.util.concurrent.locks.AbstractOwnableSynchronizer\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "awaitUninterruptibly", "throws": null, "funcname": "void awaitUninterruptibly ()", "descri": "  Causes the current thread to wait until it is signalled. The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens: Some other thread invokes the signal() method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll() method for this Condition; or A \"spurious wakeup\" occurs.  In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread's interrupted status is set when it enters this method, or it is interrupted while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact.", "parameters": null}, {"returns": [{"scri": "false if the deadline has elapsed upon return, else         true", "type": "boolean"}], "class": "java.util.concurrent.locks.AbstractOwnableSynchronizer\n", "type": "abstract\n        \n        \n        \n        \n        boolean", "name": "awaitUntil", "throws": [{"scri": "if the current thread is interrupted         (and interruption of thread suspension is supported)", "type": "InterruptedException"}], "funcname": "boolean awaitUntil (Date deadline)", "descri": "  Causes the current thread to wait until it is signalled or interrupted, or the specified deadline elapses. The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of five things happens: Some other thread invokes the signal() method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll() method for this Condition; or Some other thread interrupts the current thread, and interruption of thread suspension is supported; or The specified deadline elapses; or A \"spurious wakeup\" occurs.  In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting and interruption of thread suspension is supported, then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. The return value indicates whether the deadline has elapsed, which can be used as follows: boolean aMethod(Date deadline) {   boolean stillWaiting = true;   lock.lock();   try {     while (!conditionBeingWaitedFor()) {       if (!stillWaiting)         return false;       stillWaiting = theCondition.awaitUntil(deadline);     }     // ...   } finally {     lock.unlock();   } }  Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal, or over indicating the passing of the specified deadline. In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.    ", "parameters": [{"scri": "Date: the absolute time to wait until", "name": "deadline"}]}, {"returns": [{"scri": "the estimated number of threads waiting to acquire", "type": "int"}], "class": "java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject\n", "type": "final\n        \n        int", "name": "getQueueLength", "throws": null, "funcname": "int getQueueLength ()", "descri": "  Returns an estimate of the number of threads waiting to acquire.  The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures.  This method is designed for use in monitoring system state, not for synchronization control. ", "parameters": null}, {"returns": [{"scri": "true if successful. False return indicates that the actual         value was not equal to the expected value.", "type": "boolean"}], "class": "java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject\n", "type": "final\n        \n        boolean", "name": "compareAndSetState", "throws": null, "funcname": "boolean compareAndSetState (long expect,                 long update)", "descri": "  Atomically sets synchronization state to the given updated value if the current state value equals the expected value. This operation has memory semantics of a volatile read and write.  ", "parameters": [{"scri": "long: the expected value", "name": "expect"}, {"scri": "long: the new value", "name": "update"}]}, {"returns": [{"scri": "the sum", "type": "double"}], "class": "java.util.concurrent.locks.Condition\n", "type": "double", "name": "sum", "throws": null, "funcname": "double sum ()", "descri": "  Returns the current sum.  The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the sum is being calculated might not be incorporated.  Also, because floating-point arithmetic is not strictly associative, the returned result need not be identical to the value that would be obtained in a sequential series of updates to a single variable. ", "parameters": null}, {"returns": [{"scri": "the current value", "type": "long"}], "class": "java.util.concurrent.locks.Lock\n", "type": "long", "name": "get", "throws": null, "funcname": "long get ()", "descri": "  Returns the current value.  The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the value is being calculated might not be incorporated. ", "parameters": null}, {"returns": [{"scri": "the sum", "type": "long"}], "class": "java.util.concurrent.locks.ReadWriteLock\n", "type": "long", "name": "sum", "throws": null, "funcname": "long sum ()", "descri": "  Returns the current sum.  The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the sum is being calculated might not be incorporated. ", "parameters": null}, {"returns": [{"scri": "the estimated number of threads waiting to acquire", "type": "int"}], "class": "java.util.concurrent.locks.ReentrantLock\n", "type": "final\n        \n        int", "name": "getQueueLength", "throws": null, "funcname": "int getQueueLength ()", "descri": "  Returns an estimate of the number of threads waiting to acquire.  The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures.  This method is designed for use in monitoring system state, not for synchronization control. ", "parameters": null}, {"returns": [{"scri": "true if successful. False return indicates that the actual         value was not equal to the expected value.", "type": "boolean"}], "class": "java.util.concurrent.locks.ReentrantLock\n", "type": "final\n        \n        boolean", "name": "compareAndSetState", "throws": null, "funcname": "boolean compareAndSetState (int expect,                 int update)", "descri": "  Atomically sets synchronization state to the given updated value if the current state value equals the expected value. This operation has memory semantics of a volatile read and write.  ", "parameters": [{"scri": "int: the expected value", "name": "expect"}, {"scri": "int: the new value", "name": "update"}]}, {"returns": [{"scri": "the estimated number of threads waiting for this lock", "type": "int"}], "class": "java.util.concurrent.locks.StampedLock\n", "type": "final\n        \n        int", "name": "getQueueLength", "throws": null, "funcname": "int getQueueLength ()", "descri": "  Returns an estimate of the number of threads waiting to acquire either the read or write lock.  The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures.  This method is designed for use in monitoring system state, not for synchronization control. ", "parameters": null}, {"returns": [{"scri": "the collection of threads", "type": "Collection<Thread>"}], "class": "java.util.concurrent.locks.StampedLock\n", "type": "Collection<Thread>", "name": "getQueuedReaderThreads", "throws": null, "funcname": "Collection<Thread> getQueuedReaderThreads ()", "descri": "  Returns a collection containing threads that may be waiting to acquire the read lock.  Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate.  The elements of the returned collection are in no particular order.  This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities. ", "parameters": null}, {"returns": [{"scri": "the collection of threads", "type": "Collection<Thread>"}], "class": "java.util.concurrent.locks.StampedLock\n", "type": "Collection<Thread>", "name": "getQueuedThreads", "throws": null, "funcname": "Collection<Thread> getQueuedThreads ()", "descri": "  Returns a collection containing threads that may be waiting to acquire either the read or write lock.  Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order.  This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities. ", "parameters": null}, {"returns": [{"scri": "the collection of threads", "type": "Collection<Thread>"}], "class": "java.util.concurrent.locks.StampedLock\n", "type": "Collection<Thread>", "name": "getQueuedWriterThreads", "throws": null, "funcname": "Collection<Thread> getQueuedWriterThreads ()", "descri": "  Returns a collection containing threads that may be waiting to acquire the write lock.  Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate.  The elements of the returned collection are in no particular order.  This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities. ", "parameters": null}, {"returns": [{"scri": "the collection of threads", "type": "Collection<Thread>"}], "class": "java.util.concurrent.locks.StampedLock\n", "type": "Collection<Thread>", "name": "getWaitingThreads", "throws": [{"scri": "if this lock is not held", "type": "IllegalMonitorStateException"}, {"scri": "if the given condition is         not associated with this lock", "type": "IllegalArgumentException"}, {"scri": "if the condition is null", "type": "NullPointerException"}], "funcname": "Collection<Thread> getWaitingThreads (Condition condition)", "descri": "  Returns a collection containing those threads that may be waiting on the given condition associated with the write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order.  This method is designed to facilitate construction of subclasses that provide more extensive condition monitoring facilities.    ", "parameters": [{"scri": "Condition: the condition", "name": "condition"}]}, {"returns": null, "class": "java.util.concurrent.Phaser\n", "type": "void", "name": "clear", "throws": null, "funcname": "void clear ()", "descri": "  Atomically removes all of the elements from this deque. The deque will be empty after this call returns.", "parameters": null}, {"returns": [{"scri": "an array containing all of the elements in this deque", "type": "T[]"}], "class": "java.util.concurrent.Phaser\n", "type": "<T>\n        T[]", "name": "toArray", "throws": [{"scri": "if the runtime type of the specified array         is not a supertype of the runtime type of every element in         this deque", "type": "ArrayStoreException"}, {"scri": "if the specified array is null", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this deque, in proper sequence; the runtime type of the returned array is that of the specified array.  If the deque fits in the specified array, it is returned therein.  Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() .   ", "parameters": [{"scri": "T: the array into which the elements of the deque are to          be stored, if it is big enough; otherwise, a new array of the          same runtime type is allocated for this purpose", "name": "a"}]}, {"returns": null, "class": "java.util.concurrent.PriorityBlockingQueue\n", "type": "void", "name": "clear", "throws": null, "funcname": "void clear ()", "descri": "  Atomically removes all of the elements from this queue. The queue will be empty after this call returns.", "parameters": null}, {"returns": [{"scri": "an array containing all of the elements in this queue", "type": "T[]"}], "class": "java.util.concurrent.PriorityBlockingQueue\n", "type": "<T>\n        T[]", "name": "toArray", "throws": [{"scri": "if the runtime type of the specified array         is not a supertype of the runtime type of every element in         this queue", "type": "ArrayStoreException"}, {"scri": "if the specified array is null", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array.  If the queue fits in the specified array, it is returned therein.  Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() .   ", "parameters": [{"scri": "T: the array into which the elements of the queue are to          be stored, if it is big enough; otherwise, a new array of the          same runtime type is allocated for this purpose", "name": "a"}]}, {"returns": [{"scri": "an array containing all of the elements in this queue", "type": "T[]"}], "class": "java.util.concurrent.RecursiveTask\n", "type": "<T>\n        T[]", "name": "toArray", "throws": [{"scri": "if the runtime type of the specified array         is not a supertype of the runtime type of every element in         this queue", "type": "ArrayStoreException"}, {"scri": "if the specified array is null", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array.  If the queue fits in the specified array, it is returned therein.  Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() .   ", "parameters": [{"scri": "T: the array into which the elements of the queue are to          be stored, if it is big enough; otherwise, a new array of the          same runtime type is allocated for this purpose", "name": "a"}]}, {"returns": null, "class": "java.util.concurrent.ThreadPoolExecutor.AbortPolicy\n", "type": "void", "name": "acquire", "throws": [{"scri": "if the current thread is interrupted", "type": "InterruptedException"}, {"scri": "if permits is negative", "type": "IllegalArgumentException"}], "funcname": "void acquire (int permits)", "descri": "  Acquires the given number of permits from this semaphore, blocking until all are available, or the thread is interrupted. Acquires the given number of permits, if they are available, and returns immediately, reducing the number of available permits by the given amount. This method has the same effect as the loop for (int i = 0; i < permits; ++i) acquire(); except that it atomically acquires the permits all at once: If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens: Some other thread invokes one of the release methods for this semaphore and the current thread is next to be assigned permits and the number of available permits satisfies this request; or Some other thread interrupts the current thread.  If the current thread: has its interrupted status set on entry to this method; or is interrupted while waiting for a permit, then InterruptedException is thrown and the current thread's interrupted status is cleared. Any permits that were to be assigned to this thread are instead assigned to other threads trying to acquire permits, as if permits had been made available by a call to release() .  ", "parameters": [{"scri": "int: the number of permits to acquire", "name": "permits"}]}, {"returns": null, "class": "java.util.concurrent.ThreadPoolExecutor.AbortPolicy\n", "type": "void", "name": "acquireUninterruptibly", "throws": [{"scri": "if permits is negative", "type": "IllegalArgumentException"}], "funcname": "void acquireUninterruptibly (int permits)", "descri": "  Acquires the given number of permits from this semaphore, blocking until all are available. Acquires the given number of permits, if they are available, and returns immediately, reducing the number of available permits by the given amount. This method has the same effect as the loop for (int i = 0; i < permits; ++i) acquireUninterruptibly(); except that it atomically acquires the permits all at once: If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the release methods for this semaphore and the current thread is next to be assigned permits and the number of available permits satisfies this request. If the current thread is interrupted while waiting for permits then it will continue to wait and its position in the queue is not affected.  When the thread does return from this method its interrupt status will be set.   ", "parameters": [{"scri": "int: the number of permits to acquire", "name": "permits"}]}, {"returns": [{"scri": "the estimated number of threads waiting for this lock", "type": "int"}], "class": "java.util.concurrent.ThreadPoolExecutor.AbortPolicy\n", "type": "final\n        \n        int", "name": "getQueueLength", "throws": null, "funcname": "int getQueueLength ()", "descri": "  Returns an estimate of the number of threads waiting to acquire. The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures.  This method is designed for use in monitoring system state, not for synchronization control. ", "parameters": null}, {"returns": [{"scri": "the collection of threads", "type": "Collection<Thread>"}], "class": "java.util.concurrent.ThreadPoolExecutor.AbortPolicy\n", "type": "Collection<Thread>", "name": "getQueuedThreads", "throws": null, "funcname": "Collection<Thread> getQueuedThreads ()", "descri": "  Returns a collection containing threads that may be waiting to acquire. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate.  The elements of the returned collection are in no particular order.  This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities. ", "parameters": null}, {"returns": [{"scri": "the next pseudorandom value from this random number         generator's sequence", "type": "int"}], "class": "java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy\n", "type": "int", "name": "next", "throws": null, "funcname": "int next (int bits)", "descri": "  Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods. The general contract of next is that it returns an int value and if the argument bits is between 1 and 32 (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be 0 or 1. The method next is implemented by class Random by atomically updating the seed to (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) and returning (int)(seed >>> (48 - bits)). This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms , section 3.2.1. ", "parameters": [{"scri": "int: random bits", "name": "bits"}]}, {"returns": [{"scri": "the number of tasks", "type": "long"}], "class": "java.util.concurrent.ThreadPoolExecutor.DiscardPolicy\n", "type": "long", "name": "getCompletedTaskCount", "throws": null, "funcname": "long getCompletedTaskCount ()", "descri": "  Returns the approximate total number of tasks that have completed execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation, but one that does not ever decrease across successive calls. ", "parameters": null}, {"returns": [{"scri": "the number of tasks", "type": "long"}], "class": "java.util.concurrent.ThreadPoolExecutor.DiscardPolicy\n", "type": "long", "name": "getTaskCount", "throws": null, "funcname": "long getTaskCount ()", "descri": "  Returns the approximate total number of tasks that have ever been scheduled for execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation. ", "parameters": null}, {"returns": [{"scri": "an array containing all of the elements in this collection", "type": "T[]"}], "class": "java.util.Enumeration\n", "type": "abstract\n        \n        \n        \n        <T>\n        T[]", "name": "toArray", "throws": [{"scri": "if the runtime type of the specified array         is not a supertype of the runtime type of every element in         this collection", "type": "ArrayStoreException"}, {"scri": "if the specified array is null", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null.  (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() .   ", "parameters": [{"scri": "T: the array into which the elements of this collection are to be        stored, if it is big enough; otherwise, a new array of the same        runtime type is allocated for this purpose.", "name": "a"}]}, {"returns": [{"scri": "the new value associated with the specified key, or null if none", "type": "V"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        V", "name": "compute", "throws": [{"scri": "if the specified key is null and         this map does not support null keys, or the         remappingFunction is null", "type": "NullPointerException"}, {"scri": "if the put operation         is not supported by this map         (optional)", "type": "UnsupportedOperationException"}, {"scri": "if the class of the specified key or value         prevents it from being stored in this map         (optional)", "type": "ClassCastException"}, {"scri": "if some property of the specified key         or value prevents it from being stored in this map         (optional)", "type": "IllegalArgumentException"}], "funcname": "V compute (K key,                 BiFunction<?\u00a0super\u00a0K,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). For example, to either create or append a String msg to a value mapping: map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg)) (Method merge() is often simpler to use for such purposes.) If the remapping function returns null, the mapping is removed (or remains absent if initially absent).  If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged. The remapping function should not modify this map during computation.  Implementation Requirements: The default implementation is equivalent to performing the following steps for this map, then returning the current value or null if absent:  V oldValue = map.get(key); V newValue = remappingFunction.apply(key, oldValue); if (oldValue != null) {    if (newValue != null)       map.put(key, newValue);    else       map.remove(key); } else {    if (newValue != null)       map.put(key, newValue);    else       return null; }  The default implementation makes no guarantees about detecting if the remapping function modifies this map during computation and, if appropriate, reporting an error. Non-concurrent implementations should override this method and, on a best-effort basis, throw a ConcurrentModificationException if it is detected that the remapping function modifies this map during computation. Concurrent implementations should override this method and, on a best-effort basis, throw an IllegalStateException if it is detected that the remapping function modifies this map during computation and as a result computation would never complete. The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties. In particular, all implementations of subinterface ConcurrentMap must document whether the remapping function is applied once atomically only if the value is not present.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "BiFunction: the remapping function to compute a value", "name": "remappingFunction"}]}, {"returns": [{"scri": "the current (existing or computed) value associated with         the specified key, or null if the computed value is null", "type": "V"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        V", "name": "computeIfAbsent", "throws": [{"scri": "if the specified key is null and         this map does not support null keys, or the mappingFunction         is null", "type": "NullPointerException"}, {"scri": "if the put operation         is not supported by this map         (optional)", "type": "UnsupportedOperationException"}, {"scri": "if the class of the specified key or value         prevents it from being stored in this map         (optional)", "type": "ClassCastException"}, {"scri": "if some property of the specified key         or value prevents it from being stored in this map         (optional)", "type": "IllegalArgumentException"}], "funcname": "V computeIfAbsent (K key,                 Function<?\u00a0super\u00a0K,\u00a0?\u00a0extends\u00a0V> mappingFunction)", "descri": "  If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the mapping function returns null, no mapping is recorded. If the mapping function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded.  The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in: map.computeIfAbsent(key, k -> new Value(f(k)));  Or to implement a multi-value map, Map<K,Collection<V>>, supporting multiple values per key: map.computeIfAbsent(key, k -> new HashSet<V>()).add(v);  The mapping function should not modify this map during computation.  Implementation Requirements: The default implementation is equivalent to the following steps for this map, then returning the current value or null if now absent:  if (map.get(key) == null) {     V newValue = mappingFunction.apply(key);     if (newValue != null)         map.put(key, newValue); }  The default implementation makes no guarantees about detecting if the mapping function modifies this map during computation and, if appropriate, reporting an error. Non-concurrent implementations should override this method and, on a best-effort basis, throw a ConcurrentModificationException if it is detected that the mapping function modifies this map during computation. Concurrent implementations should override this method and, on a best-effort basis, throw an IllegalStateException if it is detected that the mapping function modifies this map during computation and as a result computation would never complete. The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties. In particular, all implementations of subinterface ConcurrentMap must document whether the mapping function is applied once atomically only if the value is not present.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "Function: the mapping function to compute a value", "name": "mappingFunction"}]}, {"returns": [{"scri": "the new value associated with the specified key, or null if none", "type": "V"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        V", "name": "computeIfPresent", "throws": [{"scri": "if the specified key is null and         this map does not support null keys, or the         remappingFunction is null", "type": "NullPointerException"}, {"scri": "if the put operation         is not supported by this map         (optional)", "type": "UnsupportedOperationException"}, {"scri": "if the class of the specified key or value         prevents it from being stored in this map         (optional)", "type": "ClassCastException"}, {"scri": "if some property of the specified key         or value prevents it from being stored in this map         (optional)", "type": "IllegalArgumentException"}], "funcname": "V computeIfPresent (K key,                 BiFunction<?\u00a0super\u00a0K,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value. If the remapping function returns null, the mapping is removed. If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged. The remapping function should not modify this map during computation.  Implementation Requirements: The default implementation is equivalent to performing the following steps for this map, then returning the current value or null if now absent:  if (map.get(key) != null) {     V oldValue = map.get(key);     V newValue = remappingFunction.apply(key, oldValue);     if (newValue != null)         map.put(key, newValue);     else         map.remove(key); }  The default implementation makes no guarantees about detecting if the remapping function modifies this map during computation and, if appropriate, reporting an error. Non-concurrent implementations should override this method and, on a best-effort basis, throw a ConcurrentModificationException if it is detected that the remapping function modifies this map during computation. Concurrent implementations should override this method and, on a best-effort basis, throw an IllegalStateException if it is detected that the remapping function modifies this map during computation and as a result computation would never complete. The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties. In particular, all implementations of subinterface ConcurrentMap must document whether the remapping function is applied once atomically only if the value is not present.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "BiFunction: the remapping function to compute a value", "name": "remappingFunction"}]}, {"returns": null, "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        void", "name": "forEach", "throws": [{"scri": "if the specified action is null", "type": "NullPointerException"}, {"scri": "if an entry is found to be removed during iteration", "type": "ConcurrentModificationException"}], "funcname": "void forEach (BiConsumer<?\u00a0super\u00a0K,\u00a0?\u00a0super\u00a0V> action)", "descri": "  Performs the given action for each entry in this map until all entries have been processed or the action throws an exception.   Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller.  Implementation Requirements: The default implementation is equivalent to, for this map:  for (Map.Entry<K, V> entry : map.entrySet())     action.accept(entry.getKey(), entry.getValue());  The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties.   ", "parameters": [{"scri": "BiConsumer: The action to be performed for each entry", "name": "action"}]}, {"returns": [{"scri": "the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key", "type": "V"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        V", "name": "getOrDefault", "throws": [{"scri": "if the key is of an inappropriate type for this map (optional)", "type": "ClassCastException"}, {"scri": "if the specified key is null and this map does not permit null keys (optional)", "type": "NullPointerException"}], "funcname": "V getOrDefault (Object key,                 V defaultValue)", "descri": "  Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.  Implementation Requirements: The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties.    ", "parameters": [{"scri": "Object: the key whose associated value is to be returned", "name": "key"}, {"scri": "V: the default mapping of the key", "name": "defaultValue"}]}, {"returns": [{"scri": "the new value associated with the specified key, or null if no         value is associated with the key", "type": "V"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        V", "name": "merge", "throws": [{"scri": "if the put operation         is not supported by this map         (optional)", "type": "UnsupportedOperationException"}, {"scri": "if the class of the specified key or value         prevents it from being stored in this map         (optional)", "type": "ClassCastException"}, {"scri": "if some property of the specified key         or value prevents it from being stored in this map         (optional)", "type": "IllegalArgumentException"}, {"scri": "if the specified key is null and this map         does not support null keys or the value or remappingFunction is         null", "type": "NullPointerException"}], "funcname": "V merge (K key,                 V value,                 BiFunction<?\u00a0super\u00a0V,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> remappingFunction)", "descri": "  If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping: map.merge(key, msg, String::concat)  If the remapping function returns null, the mapping is removed. If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged. The remapping function should not modify this map during computation.  Implementation Requirements: The default implementation is equivalent to performing the following steps for this map, then returning the current value or null if absent:  V oldValue = map.get(key); V newValue = (oldValue == null) ? value :              remappingFunction.apply(oldValue, value); if (newValue == null)     map.remove(key); else     map.put(key, newValue);  The default implementation makes no guarantees about detecting if the remapping function modifies this map during computation and, if appropriate, reporting an error. Non-concurrent implementations should override this method and, on a best-effort basis, throw a ConcurrentModificationException if it is detected that the remapping function modifies this map during computation. Concurrent implementations should override this method and, on a best-effort basis, throw an IllegalStateException if it is detected that the remapping function modifies this map during computation and as a result computation would never complete. The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties. In particular, all implementations of subinterface ConcurrentMap must document whether the remapping function is applied once atomically only if the value is not present.    ", "parameters": [{"scri": "K: key with which the resulting value is to be associated", "name": "key"}, {"scri": "V: the non-null value to be merged with the existing value        associated with the key or, if no existing value or a null value        is associated with the key, to be associated with the key", "name": "value"}, {"scri": "BiFunction: the remapping function to recompute a value if        present", "name": "remappingFunction"}]}, {"returns": [{"scri": "the previous value associated with the specified key, or         null if there was no mapping for the key.         (A null return can also indicate that the map         previously associated null with the key,         if the implementation supports null values.)", "type": "V"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        V", "name": "putIfAbsent", "throws": [{"scri": "if the put operation         is not supported by this map         (optional)", "type": "UnsupportedOperationException"}, {"scri": "if the key or value is of an inappropriate         type for this map         (optional)", "type": "ClassCastException"}, {"scri": "if the specified key or value is null,         and this map does not permit null keys or values         (optional)", "type": "NullPointerException"}, {"scri": "if some property of the specified key         or value prevents it from being stored in this map         (optional)", "type": "IllegalArgumentException"}], "funcname": "V putIfAbsent (K key,                 V value)", "descri": "  If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.  Implementation Requirements: The default implementation is equivalent to, for this map:  V v = map.get(key); if (v == null)     v = map.put(key, value); return v;  The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties.    ", "parameters": [{"scri": "K: key with which the specified value is to be associated", "name": "key"}, {"scri": "V: value to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "true if the value was removed", "type": "boolean"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        boolean", "name": "remove", "throws": [{"scri": "if the remove operation         is not supported by this map         (optional)", "type": "UnsupportedOperationException"}, {"scri": "if the key or value is of an inappropriate         type for this map         (optional)", "type": "ClassCastException"}, {"scri": "if the specified key or value is null,         and this map does not permit null keys or values         (optional)", "type": "NullPointerException"}], "funcname": "boolean remove (Object key,                 Object value)", "descri": "  Removes the entry for the specified key only if it is currently mapped to the specified value.  Implementation Requirements: The default implementation is equivalent to, for this map:  if (map.containsKey(key) && Objects.equals(map.get(key), value)) {     map.remove(key);     return true; } else     return false;  The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties.    ", "parameters": [{"scri": "Object: key with which the specified value is associated", "name": "key"}, {"scri": "Object: value expected to be associated with the specified key", "name": "value"}]}, {"returns": [{"scri": "true if the value was replaced", "type": "boolean"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        boolean", "name": "replace", "throws": [{"scri": "if the put operation         is not supported by this map         (optional)", "type": "UnsupportedOperationException"}, {"scri": "if the class of a specified key or value         prevents it from being stored in this map", "type": "ClassCastException"}, {"scri": "if a specified key or newValue is null,         and this map does not permit null keys or values", "type": "NullPointerException"}, {"scri": "if oldValue is null and this map does not         permit null values         (optional)", "type": "NullPointerException"}, {"scri": "if some property of a specified key         or value prevents it from being stored in this map", "type": "IllegalArgumentException"}], "funcname": "boolean replace (K key,                 V oldValue,                 V newValue)", "descri": "  Replaces the entry for the specified key only if currently mapped to the specified value.  Implementation Requirements: The default implementation is equivalent to, for this map:  if (map.containsKey(key) && Objects.equals(map.get(key), value)) {     map.put(key, newValue);     return true; } else     return false;  The default implementation does not throw NullPointerException for maps that do not support null values if oldValue is null unless newValue is also null. The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties.    ", "parameters": [{"scri": "K: key with which the specified value is associated", "name": "key"}, {"scri": "V: value expected to be associated with the specified key", "name": "oldValue"}, {"scri": "V: value to be associated with the specified key", "name": "newValue"}]}, {"returns": [{"scri": "the previous value associated with the specified key, or         null if there was no mapping for the key.         (A null return can also indicate that the map         previously associated null with the key,         if the implementation supports null values.)", "type": "V"}], "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        boolean", "name": "replace", "throws": [{"scri": "if the put operation         is not supported by this map         (optional)", "type": "UnsupportedOperationException"}, {"scri": "if the class of the specified key or value         prevents it from being stored in this map         (optional)", "type": "ClassCastException"}, {"scri": "if the specified key or value is null,         and this map does not permit null keys or values", "type": "NullPointerException"}, {"scri": "if some property of the specified key         or value prevents it from being stored in this map", "type": "IllegalArgumentException"}], "funcname": "V replace (K key,                 V value)", "descri": "  Replaces the entry for the specified key only if it is currently mapped to some value.  Implementation Requirements: The default implementation is equivalent to, for this map:  if (map.containsKey(key)) {     return map.put(key, value); } else     return null;  The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties.    ", "parameters": [{"scri": "K: key with which the specified value is associated", "name": "key"}, {"scri": "V: value to be associated with the specified key", "name": "value"}]}, {"returns": null, "class": "java.util.PrimitiveIterator\n", "type": "default\n        \n        \n        \n        void", "name": "replaceAll", "throws": [{"scri": "if the set operation is not supported by this map's entry set iterator.", "type": "UnsupportedOperationException"}, {"scri": "if the class of a replacement value prevents it from being stored in this map", "type": "ClassCastException"}, {"scri": "if the specified function is null, or the specified replacement value is null, and this map does not permit null values", "type": "NullPointerException"}, {"scri": "if a replacement value is of an inappropriate         type for this map         (optional)", "type": "ClassCastException"}, {"scri": "if function or a replacement value is null,         and this map does not permit null keys or values         (optional)", "type": "NullPointerException"}, {"scri": "if some property of a replacement value         prevents it from being stored in this map         (optional)", "type": "IllegalArgumentException"}, {"scri": "if an entry is found to be removed during iteration", "type": "ConcurrentModificationException"}], "funcname": "void replaceAll (BiFunction<?\u00a0super\u00a0K,\u00a0?\u00a0super\u00a0V,\u00a0?\u00a0extends\u00a0V> function)", "descri": "  Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception.  Exceptions thrown by the function are relayed to the caller.  Implementation Requirements: The default implementation is equivalent to, for this map:  for (Map.Entry<K, V> entry : map.entrySet())     entry.setValue(function.apply(entry.getKey(), entry.getValue()));  The default implementation makes no guarantees about synchronization or atomicity properties of this method. Any implementation providing atomicity guarantees must override this method and document its concurrency properties.   ", "parameters": [{"scri": "BiFunction: the function to apply to each entry", "name": "function"}]}, {"returns": [{"scri": "an array containing all of the elements in this queue", "type": "T[]"}], "class": "java.util.PropertyResourceBundle\n", "type": "<T>\n        T[]", "name": "toArray", "throws": [{"scri": "if the runtime type of the specified array         is not a supertype of the runtime type of every element in         this queue", "type": "ArrayStoreException"}, {"scri": "if the specified array is null", "type": "NullPointerException"}], "funcname": "T[] toArray (T[] a)", "descri": "  Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs.  Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray() .   ", "parameters": [{"scri": "T: the array into which the elements of the queue are to          be stored, if it is big enough; otherwise, a new array of the          same runtime type is allocated for this purpose.", "name": "a"}]}, {"returns": null, "class": "java.util.ServiceLoader\n", "type": "void", "name": "setSeed", "throws": null, "funcname": "void setSeed (long seed)", "descri": "  Sets the seed of this random number generator using a single long seed. The general contract of setSeed is that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argument seed as a seed. The method setSeed is implemented by class Random by atomically updating the seed to (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1) and clearing the haveNextNextGaussian flag used by nextGaussian() . The implementation of setSeed by class Random happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the long argument as a seed value. ", "parameters": [{"scri": "long: the initial seed", "name": "seed"}]}, {"returns": [{"scri": "the next pseudorandom value from this random number         generator's sequence", "type": "int"}], "class": "java.util.ServiceLoader\n", "type": "int", "name": "next", "throws": null, "funcname": "int next (int bits)", "descri": "  Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods. The general contract of next is that it returns an int value and if the argument bits is between 1 and 32 (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be 0 or 1. The method next is implemented by class Random by atomically updating the seed to (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) and returning (int)(seed >>> (48 - bits)). This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms , section 3.2.1. ", "parameters": [{"scri": "int: random bits", "name": "bits"}]}, {"returns": null, "class": "java.util.zip.GZIPOutputStream\n", "type": "void", "name": "setDictionary", "throws": null, "funcname": "void setDictionary (byte[] b,                 int off,                 int len)", "descri": "  Sets preset dictionary for compression. A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with Inflater.inflate(), Inflater.getAdler() can be called in order to get the Adler-32 value of the dictionary required for decompression.   See also: inflate(byte[])getAdler()", "parameters": [{"scri": "byte: the dictionary data bytes", "name": "b"}, {"scri": "int: the start offset of the data", "name": "off"}, {"scri": "int: the length of the data", "name": "len"}]}, {"returns": null, "class": "java.util.zip.GZIPOutputStream\n", "type": "void", "name": "setDictionary", "throws": null, "funcname": "void setDictionary (byte[] b)", "descri": "  Sets preset dictionary for compression. A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with Inflater.inflate(), Inflater.getAdler() can be called in order to get the Adler-32 value of the dictionary required for decompression.   See also: inflate(byte[])getAdler()", "parameters": [{"scri": "byte: the dictionary data bytes", "name": "b"}]}, {"returns": null, "class": "javax.xml.validation.SchemaFactoryLoader\n", "type": "void", "name": "setPublicId", "throws": null, "funcname": "void setPublicId (String publicId)", "descri": "  Set the public identifier for this Source. The public identifier is always optional: if the application writer includes one, it will be provided as part of the location information. ", "parameters": [{"scri": "String: The public identifier as a string.", "name": "publicId"}]}, {"returns": null, "class": "org.w3c.dom.DOMConfiguration\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setDocumentURI", "throws": null, "funcname": "void setDocumentURI (String documentURI)", "descri": "  The location of the document or null if undefined or if the Document was created using DOMImplementation.createDocument. No lexical checking is performed when setting this attribute; this could result in a null value returned when using Node.baseURI .  Beware that when the Document supports the feature \"HTML\" [DOM Level 2 HTML] , the href attribute of the HTML BASE element takes precedence over this attribute when computing Node.baseURI. ", "parameters": [{"scri": "String", "name": "documentURI"}]}, {"returns": null, "class": "org.w3c.dom.ls.LSParserFilter\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setPublicId", "throws": null, "funcname": "void setPublicId (String publicId)", "descri": "  The public identifier for this input source. This may be mapped to an input source using an implementation dependent mechanism (such as catalogues or other mappings). The public identifier, if specified, may also be reported as part of the location information when errors are reported. ", "parameters": [{"scri": "String", "name": "publicId"}]}, {"returns": null, "class": "org.xml.sax.EntityResolver\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setDocumentLocator", "throws": null, "funcname": "void setDocumentLocator (Locator locator)", "descri": "  Receive an object for locating the origin of SAX document events. SAX parsers are strongly encouraged (though not absolutely required) to supply a locator: if it does so, it must supply the locator to the application by invoking this method before invoking any of the other methods in the ContentHandler interface.  The locator allows the application to determine the end position of any document-related event, even if the parser is not reporting an error.  Typically, the application will use this information for reporting its own errors (such as character content that does not match an application's business rules).  The information returned by the locator is probably not sufficient for use with a search engine.  Note that the locator will return correct information only during the invocation SAX event callbacks after startDocument returns and before endDocument is called.  The application should not attempt to use it at any other time.   See also: Locator", "parameters": [{"scri": "Locator: an object that can return the location of                any SAX document event", "name": "locator"}]}, {"returns": null, "class": "org.xml.sax.ErrorHandler\n", "type": "abstract\n        \n        \n        \n        \n        void", "name": "setDocumentLocator", "throws": null, "funcname": "void setDocumentLocator (Locator locator)", "descri": "  Receive an object for locating the origin of SAX document events. SAX parsers are strongly encouraged (though not absolutely required) to supply a locator: if it does so, it must supply the locator to the application by invoking this method before invoking any of the other methods in the DocumentHandler interface.  The locator allows the application to determine the end position of any document-related event, even if the parser is not reporting an error.  Typically, the application will use this information for reporting its own errors (such as character content that does not match an application's business rules).  The information returned by the locator is probably not sufficient for use with a search engine.  Note that the locator will return correct information only during the invocation of the events in this interface.  The application should not attempt to use it at any other time.   See also: Locator", "parameters": [{"scri": "Locator: An object that can return the location of                any SAX document event.", "name": "locator"}]}, {"returns": null, "class": "org.xml.sax.helpers.AttributesImpl\n", "type": "void", "name": "startDTD", "throws": [{"scri": "", "type": "SAXException"}], "funcname": "void startDTD (String name,                 String publicId,                 String systemId)", "descri": "  Report the start of DTD declarations, if any. This method is intended to report the beginning of the DOCTYPE declaration; if the document has no DOCTYPE declaration, this method will not be invoked.  All declarations reported through DTDHandler or DeclHandler events must appear between the startDTD and endDTD events. Declarations are assumed to belong to the internal DTD subset unless they appear between startEntity and endEntity events.  Comments and processing instructions from the DTD should also be reported between the startDTD and endDTD events, in their original order of (logical) occurrence; they are not required to appear in their correct locations relative to DTDHandler or DeclHandler events, however.  Note that the start/endDTD events will appear within the start/endDocument events from ContentHandler and before the first startElement event.   ", "parameters": [{"scri": "String: The document type name.", "name": "name"}, {"scri": "String: The declared public identifier for the        external DTD subset, or null if none was declared.", "name": "publicId"}, {"scri": "String: The declared system identifier for the        external DTD subset, or null if none was declared.        (Note that this is not resolved against the document        base URI.)", "name": "systemId"}]}, {"returns": null, "class": "org.xml.sax.SAXParseException\n", "type": "void", "name": "setPublicId", "throws": null, "funcname": "void setPublicId (String publicId)", "descri": "  Set the public identifier for this input source. The public identifier is always optional: if the application writer includes one, it will be provided as part of the location information.   See also: getPublicId()getPublicId()getPublicId()", "parameters": [{"scri": "String: The public identifier as a string.", "name": "publicId"}]}]